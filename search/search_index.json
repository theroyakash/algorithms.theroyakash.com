{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"theroyakash algorithms","text":"theroyakash algorithms    Materials for FAANG and top startup coding interview and running notes on that. Made by theroyakash. <p> Getting started \u2022   Freebies \u2022   theroyakash Learning Platform \u2022   License </p> Support this project on GitHub by becoming a sponsor <p>This project is completely free and funded by @theroyakash and private sponsors.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>This material categorizes coding interview problems into a set of 8 patterns. Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems.</p> <p>Complete guide and roadmap for SDE I and SDE II algorithm round.</p>"},{"location":"#content-overview","title":"Content overview","text":"<ol> <li>Sliding Window Pattern, more is being added.</li> <li>Arrays and Strings (Coming soon)</li> <li>Recursion overview and recursion problems (more) coming soon</li> <li>Linked lists overview and problems</li> <li>Stacks overview and stack problems and Queues (coming soon)</li> <li>Binary Search overview and Problems (more coming soon)</li> <li>Trees overview and tree problem</li> <li>Graphs overview, graph bfs and dfs and Graph Problems,</li> <li>Heaps overview and heap problems and 2 heaps problems.</li> <li>Greedy algorithms</li> <li>Dynamic Programming</li> <li>Bit Manipulation (With C/C++) (coming soon)</li> </ol>"},{"location":"#problem-counter","title":"Problem Counter","text":"<p>The following table is meant to represent the amount of problems has a full analysis in the website. Maybe incorrectly represented upto 1-2 problems.</p> Problem Concepts Number of problems with detailed solutions Linked List Problems \\(15\\) Binary Search (Interview Problems) \\(22\\) Tree Problems \\(26\\) Graph Traversals, BFS, DFS and applications \\(3\\) Graph Standard Problems \\(4\\) Graph Interview Problems \\(8\\) Stack Problems \\(10\\) Heap Problems \\(7\\) 2 Heap Problems \\(2\\) problem scheduled to be added Array Problems \\(22\\) Array + Sliding window concept Problems \\(4\\) Recursion Problems \\(3\\), more will be added soon Dynamic Programming \\(11\\) Greedy Algorithms 2 Total Number of Problems with Full analysis \\(139\\) problems with FULL analysis"},{"location":"#also-coming-soon","title":"Also Coming Soon","text":"<p>Few more freebies coming soon - Distributed Systems Book (expected 2025 Summer).</p>"},{"location":"#other-products","title":"Other Products","text":"<p>See the freebies page to see more products available for free to use.</p>"},{"location":"#who-am-i","title":"Who am I?","text":"This is me! <p>I go by theroyakash on the internet. I am a computer scientist, a masters student in computer science from Indian Institute of Technology (IIT) Madras, with research in high-performance algorithms, data structures, distributed systems, and beyond. I am an upcoming software engineering intern at Amazon India. See my work searching google for theroyakash and on Github.</p>"},{"location":"#other-links","title":"Other links","text":"<ul> <li>Visit my website here.</li> <li>More about me here</li> <li>My Github,</li> <li>More about me,</li> <li>Send me an email.</li> </ul>"},{"location":"blind75/","title":"Blind 75 problems","text":"<p>This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions.</p> <p>Find the blind 75 problems on leetcode \\(\\to\\)</p> <p>Linked List problems</p> <ul> <li>Reverse a Linked List</li> <li>Detect Cycle in a Linked List</li> <li>Merge 2 Sorted Lists</li> <li>Merge K Sorted lists</li> <li>Remove Nth Node From End Of List</li> <li>Reorder List</li> </ul> <p>Heap</p> <ul> <li>Merge K Sorted Lists</li> <li>Top K Frequent Elements</li> <li>Find Median from Data Stream</li> </ul> <p>Tree</p> <ul> <li>Maximum Depth of Binary Tree</li> <li>Same Tree</li> <li>Invert/Flip Binary Tree</li> <li>Binary Tree Maximum Path Sum</li> <li>Binary Tree Level Order Traversal</li> <li>Serialize and Deserialize Binary Tree</li> <li>Subtree of Another Tree</li> <li>Construct Binary Tree from Preorder and Inorder Traversal</li> <li>Validate Binary Search Tree</li> <li>Kth Smallest Element in a BST</li> <li>Lowest Common Ancestor of BST</li> <li>Implement Trie (Prefix Tree)</li> <li>Add and Search Word</li> <li>Word Search II</li> </ul> <p>String</p> <ul> <li>Longest Substring Without Repeating Characters</li> <li>Longest Repeating Character Replacement</li> <li>Minimum Window Substring</li> <li>Valid Anagram</li> <li>Group Anagrams</li> <li>Valid Parentheses</li> <li>Valid Palindrome</li> <li>Longest Palindromic Substring</li> <li>Palindromic Substrings</li> <li>Encode and Decode Strings (Leetcode Premium)</li> </ul> <p>Binary (bitwise operations)</p> <ul> <li>Sum of Two Integers</li> <li>Number of 1 Bits</li> <li>Counting Bits</li> <li>Missing Number</li> <li>Reverse Bits</li> </ul> <p>Array</p> <ul> <li>Two Sum II</li> <li>Best Time to Buy and Sell Stock</li> <li>Contains Duplicate</li> <li>Product of Array Except Self</li> <li>Maximum Subarray</li> <li>Maximum Product Subarray</li> <li>Find Minimum in Rotated Sorted Array</li> <li>Search in Rotated Sorted Array</li> <li>3 Sum</li> <li>Container With Most Water</li> </ul> <p>Dynamic Programming</p> <ul> <li>Climbing Stairs</li> <li>Coin Change</li> <li>Longest Increasing Subsequence</li> <li>Longest Common Subsequence</li> <li>Word Break Problem</li> <li>Combination Sum</li> <li>House Robber</li> <li>House Robber II</li> <li>Decode Ways</li> <li>Unique Paths</li> <li>Jump Game</li> </ul>","tags":["Blind 75","ONGOING SERIES"]},{"location":"cses/","title":"CSES Problem Set","text":"<p>The CSES Problem Set contains a collection of algorithm programming practice problems. These problems are identified to be one of the best set of problems to build algorithmic thinking in the CP community. This can be one of the best resources for learning algorithmic thinking. </p> <p>Why should you look at my apporaches?</p> <p>My texts are Object Oriented Solutions for Competitive programing problems which you will find nowhere else. Everywhere you'll see solutions with bunch of <code>#define</code> and variables named <code>i, j, k, a, b, c</code> with not exact in depth explaination given. My solutions are readable, extensible, reusable.</p> <p>Below are few solutions for the CSES problem set. Find the CSES problem set here \\(\\to\\)</p>"},{"location":"cses/#problems-and-solution-list","title":"Problems and solution list","text":""},{"location":"cses/#graph-problems","title":"Graph Problems","text":"<ul> <li>Building Roads</li> <li>Download Speed</li> </ul>"},{"location":"cses/#dynamic-programming-problems","title":"Dynamic Programming Problems","text":"<ul> <li>Minimizing Coins</li> <li>Coin Combinations I</li> <li>Coin Combinations II</li> <li>Removing Digits</li> <li>Grid Paths</li> </ul>"},{"location":"freebies/","title":"Freebies","text":"<p>Here are things that you get for free if you wish to work in Python.</p> <ul> <li>AKDSFramework, a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\).</li> <li>Benchmarking decorator: Use an one line import to profile any python function, <code>from AKDSFramework.applications.decorators import benchmark</code>. More on this here in this blog post \\(\\to\\).</li> <li>A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\).</li> <li>A big O analyser, find it here \\(\\to\\). It works with most of the python programs but is not a good fit for more complex functions.</li> <li>TinyDS, small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked.</li> </ul>"},{"location":"freebies/#c","title":"C++","text":"<ul> <li>I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\).</li> <li>How to use the <code>stdin</code> and <code>stdout</code> and take input from files and write output to text files to quickly submit solutions to online coding platforms. Here is an article with that information.</li> </ul>"},{"location":"freebies/#writing-c-output-with-color","title":"Writing C++ Output with color","text":"<p>Distinguishing C++ output inside the terminal is a hard job. Use the following color pallette to distinguish the outputs.</p> <pre><code>#define RESET \"\\033[0m\"\n#define BLACK \"\\033[30m\"              /* Black */\n#define RED \"\\033[31m\"                /* Red */\n#define GREEN \"\\033[32m\"              /* Green */\n#define YELLOW \"\\033[33m\"             /* Yellow */\n#define BLUE \"\\033[34m\"               /* Blue */\n#define MAGENTA \"\\033[35m\"            /* Magenta */\n#define CYAN \"\\033[36m\"               /* Cyan */\n#define WHITE \"\\033[37m\"              /* White */\n#define BOLDBLACK \"\\033[1m\\033[30m\"   /* Bold Black */\n#define BOLDRED \"\\033[1m\\033[31m\"     /* Bold Red */\n#define BOLDGREEN \"\\033[1m\\033[32m\"   /* Bold Green */\n#define BOLDYELLOW \"\\033[1m\\033[33m\"  /* Bold Yellow */\n#define BOLDBLUE \"\\033[1m\\033[34m\"    /* Bold Blue */\n#define BOLDMAGENTA \"\\033[1m\\033[35m\" /* Bold Magenta */\n#define BOLDCYAN \"\\033[1m\\033[36m\"    /* Bold Cyan */\n#define BOLDWHITE \"\\033[1m\\033[37m\"   /* Bold White */\n</code></pre>"},{"location":"freebies/#usage-with-stdcout","title":"Usage with <code>std::cout</code>","text":"<p>Everytime you use any of the color you must reset the color from the terminal like the following:</p> <pre><code>int main() {\nvector&lt;int&gt; v = {1, 0, 1, 0, 0};\nfor (auto i : v)\ncout &lt;&lt; BOLDCYAN &lt;&lt; i &lt;&lt; \" \" &lt;&lt; RESET;\ncout &lt;&lt; \" \\n\";\nreturn 0;\n}\n</code></pre>"},{"location":"freebies/#algorithms-c","title":"Algorithms C++","text":"<p>C++ Algorithms is a simple data structure implementation library that you can remember to implement in an interview setting.</p>"},{"location":"freebies/#contributing","title":"Contributing","text":"<p>There is some open positions for contribution in AKDSFramework tinyds, and C++ Algorithms projects. If you are willing to work open source please reach out to me at hey@theroyakash.com.</p> <p>Warning</p> <p>Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.</p>"},{"location":"io/","title":"Standard input output usage","text":""},{"location":"io/#taking-data-in-and-writing-data-out-to-a-file","title":"Taking data in and writing data out to a file","text":"<p>In some of the problems in SDE 1 and SDE 2 online coding rounds, you have to take care of the program inputs.</p> <p>Here is an example of how we can write all inputs to a text file and then run our algorithms.</p> <p>You must add 2 files called \"input.txt\" and \"output.txt\" in the same directory add the function in the code, then in the <code>main()</code> function just call the function <code>fileIO()</code> to have the input taken from input.txt and the output written to output.txt.</p> <pre><code>void fileIO() {\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\n}\nint main() {\nfileIO();\n// ... YOUR CODE ...\nreturn 0;\n}\n</code></pre>"},{"location":"io/#input","title":"Input","text":"<p>Now in the input.txt file, you design as the inputs are given in the following case the input was</p> <pre><code>3\na\nb\nc\n4\na b 12\nc b 2\nb a 99\nc a 8\n</code></pre>"},{"location":"io/#output","title":"Output","text":"<p>The corresponding output file is written as <pre><code>c [a: 8][b: 2]\nb [a: 99]\na [b: 12]\n\na-&gt;b\nc-&gt;b\nb-&gt;a\nc-&gt;a\n</code></pre></p>"},{"location":"io/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\nusing namespace std;\n// Directed graph implementation\nclass Graph{\nprivate:\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; adj_list;\nvector&lt;pair&lt;char, char&gt;&gt; E; // edge set\npublic:\nvector&lt;pair&lt;char, char&gt;&gt; edges(){\nreturn E;\n}\nvoid add_edge(char vertex1, char vertex2, int weight){\nadj_list[vertex1].push_front(make_pair(\nvertex2, weight\n));\nE.push_back({vertex1, vertex2});\n}\nvoid register_vertex(vector&lt;char&gt; vertices){\nfor (auto v:vertices){\nlist&lt;pair&lt;char, int&gt;&gt; l;\nadj_list.insert({v, l});\n}\n}\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; view(){\nreturn adj_list;\n}\n};\nint main() {\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\nGraph g;\nint vertex;\ncin &gt;&gt; vertex;\nvector&lt;char&gt; v;\nwhile (vertex != 0){\nchar vertex_label;\ncin &gt;&gt; vertex_label;\nv.push_back(vertex_label);\nvertex--;\n}\ng.register_vertex(v);\nint numberofedges;\ncin &gt;&gt; numberofedges;\nwhile(numberofedges != 0){\nchar from, to;\nint weight;\ncin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;\ng.add_edge(from, to, weight);\nnumberofedges--;\n}\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; map = g.view();\nfor (auto data:map){\ncout &lt;&lt; data.first &lt;&lt; \" \";\nfor (auto neighbor:data.second)\ncout &lt;&lt; \"[\" &lt;&lt; neighbor.first &lt;&lt; \": \" &lt;&lt; neighbor.second &lt;&lt; \"]\";\ncout &lt;&lt; \"\\n\";\n}\ncout &lt;&lt; \"\\n\";\n// print all the edges\nauto edges = g.edges();\nfor (auto edge:edges){\ncout &lt;&lt; edge.first &lt;&lt; \"-&gt;\" &lt;&lt; edge.second &lt;&lt; \"\\n\";\n}\ncout &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"2heaps/problems/","title":"Two heaps problems","text":"<p>These are the problems that generally requires two binary heaps i.e. a min heap and a max heap. We can divide the problem in two parts, we'll use a Min Heap to find the smallest element and a Max Heap to find the biggest element and combine the parts together.</p> <p>Let's see some questions on this.</p>"},{"location":"2heaps/problems/#find-the-median-of-a-number-stream","title":"Find the Median of a Number Stream","text":"<p>Design a class to calculate the median of a number stream. The class should have the following two methods</p> <ul> <li><code>insertNum(int num)</code>: stores the number in the class</li> <li><code>findMedian()</code>: returns the median of all numbers inserted in the class</li> </ul> <p>Just like a normal median function, if the count of numbers inserted in the class is even, the median will be the average of the middle two numbers.</p>"},{"location":"2heaps/problems/#example","title":"Example","text":"<ol> <li><code>insertNum(3)</code></li> <li><code>insertNum(1)</code></li> <li><code>findMedian()</code> \\(\\to\\) output: 2</li> <li><code>insertNum(5)</code></li> <li><code>findMedian()</code> \\(\\to\\) output: 3</li> <li><code>insertNum(4)</code></li> <li><code>findMedian()</code> \\(\\to\\) output: 3.5</li> </ol>"},{"location":"2heaps/problems/#sliding-window-median","title":"Sliding Window Median","text":"<p>Given an array of numbers and a number \u2018k\u2019, find the median of all the \u2018k\u2019 sized sub-arrays (or windows) of the array.</p>"},{"location":"2heaps/problems/#examples","title":"Examples","text":"<p>Input: <code>nums</code>=\\([1, 2, -1, 3, 5]\\), \\(k = 2\\)</p> <p>Output: \\([1.5, 0.5, 1.0, 4.0]\\)</p> <p>Explanation: Lets consider all windows of size \\(2\\):</p> <ol> <li>\\([1, 2, -1, 3, 5] \\to\\) median is \\(1.5\\)</li> <li>\\([1, 2, -1, 3, 5] \\to\\) median is \\(0.5\\)</li> <li>\\([1, 2, -1, 3, 5] \\to\\) median is \\(1.0\\)</li> <li>\\([1, 2, -1, 3, 5] \\to\\) median is \\(4.0\\)</li> </ol>"},{"location":"LinkedLists/problems/","title":"Linked List problems","text":"<p>Questions discussed</p> <ul> <li>Implement Linked list and write <code>reverse()</code></li> <li>Problem Statement</li> <li>Middle of the Linked List</li> <li>Merge 2 sorted lists</li> <li>Delete Node in a Linked List</li> <li>Remove Nth Node From End of List</li> <li>Add Two Numbers Given as LinkedLists</li> <li>Intersection of Two Linked Lists</li> <li>Detect a cycle in linked list</li> <li>Palindrome Linked list</li> <li>Find the starting point of cycle in linked list</li> <li>Given the head of a linked list, rotate the list to the right by k places</li> <li>Copy List with Random Pointer</li> <li>Merge k Sorted Lists</li> <li>Reverse Nodes in k-Group</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#implement-linked-list-and-write-reverse","title":"Implement Linked list and write <code>reverse()</code>","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement","title":"Problem Statement","text":"<p>Implement Linked list and write <code>reverse()</code> method that reverse the list in-place.</p> <p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach","title":"Approach","text":"<p>Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code-for-linked-list","title":"C++ Code for Linked List","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\ntemplate &lt;class T&gt;\nclass Node {\npublic:\nT data;\nNode&lt;T&gt;* next;\nNode(T value) {\ndata = value;\nnext = nullptr;\n}\n};\ntemplate &lt;class T&gt;\nclass LinkedList {\nprivate:\nint size;\npublic:\nNode&lt;T&gt;* head;\nNode&lt;T&gt;* end;\nLinkedList() {\nhead = nullptr;\nend = nullptr;\n}\n~LinkedList() {\n// delete each and every node that is allocated\nwhile (head) {\nNode&lt;T&gt;* temp = head-&gt;next;\ndelete(head);\nhead = temp;\n}\n}\nvoid push_front(T value) {\nNode&lt;T&gt;* newNode = new Node&lt;T&gt;(value);\nif (not head and not end) {\nhead = newNode;\nend = newNode;\n} else {\nnewNode-&gt;next = head;\nhead = newNode;\n}\nsize++;\n}\nvoid push_back(T value) {\nNode&lt;T&gt;* newNode = new Node&lt;T&gt;(value);\nif (not head and not end) {\nhead = newNode;\nend = newNode;\n} else {\nend-&gt;next = newNode;\nend = newNode;\n}\n}\nvoid out() const{\nNode&lt;T&gt;* traveller = head;\nwhile (traveller) {\ncout &lt;&lt; traveller-&gt;data &lt;&lt; \" \";\ntraveller = traveller-&gt;next;\n}\n}\nT front() {\nreturn head-&gt;data;\n}\nT back() {\nreturn end-&gt;data;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#linkedlist_reverse-method","title":"<code>linkedlist_reverse()</code> method","text":"<p>We'll implement <code>linkedlist_reverse()</code> method to reverse a linked list. For doubly linked lists reverse is easy.</p> <p>For doubly linked lists reverse is essentially these 2 steps: - Set <code>list.end()</code> as the new <code>list.begin()</code> - Set <code>list.begin()</code> as the new <code>list.end()</code>.</p> <p>Let's implement this for a singly linked list. <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\nListNode* reverseList(ListNode* head) {\nListNode* prev = NULL;\nwhile(head != NULL){\nListNode* next = head-&gt;next;\nhead-&gt;next = prev;\nprev = head;\nhead = next;\n}\nreturn prev;\n}\n};\n</code></pre></p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#middle-of-the-linked-list","title":"Middle of the Linked List","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_1","title":"Problem Statement","text":"<p>Given the head of a singly linked list, return the middle node of the linked list.</p> <p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_1","title":"Approach","text":"<p>Use 2 pointers with different speed. Return the slow pointer.</p> <p></p> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\nListNode* middleNode(ListNode* head) {\nif (!head-&gt;next){\nreturn head;\n}\nListNode* slowPointer = head;\nListNode* fastPointer = head;\nwhile(fastPointer!= NULL &amp;&amp; fastPointer-&gt;next != NULL){\nslowPointer = slowPointer-&gt;next;\nfastPointer = fastPointer-&gt;next-&gt;next;\n}\nreturn slowPointer;\n}\n};\n</code></pre> <p>Same function implementation but on <code>std::forward_list&lt;typename&gt;</code> container.</p> <pre><code>#include &lt;forward_list&gt;\n#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\nusing std::forward_list;\ntemplate &lt;class T&gt;\nT findMiddleElement(forward_list&lt;T&gt; *list) {\n// Using 2 pointer approach\nauto slowPointer = list-&gt;begin();\nauto fastPointer = list-&gt;begin();\n// Update the slowPointer slowly and fastPointer quickly\nwhile (fastPointer != list-&gt;end() &amp;&amp; std::next(fastPointer, 1) != list-&gt;end()) {\nstd::advance(slowPointer, 1);\nstd::advance(fastPointer, 2);\n}\nreturn *slowPointer;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#merge-2-sorted-lists","title":"Merge 2 sorted lists","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_2","title":"Problem Statement","text":"<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p> <p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p> <p>Return the head of the merged linked list.</p> <p></p> <pre><code>Input: list1 = [1,2,4], and list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_2","title":"Approach","text":"<p>We'll use the <code>merge</code> subroutine from the merge sort in order to merge these two lists. One problem is that the <code>std::forward_list&lt;typename&gt;</code> do not have a <code>push_back()</code> method. Only have a <code>push_front()</code> method. So we need to reverse the list before returning it. Using <code>std::list&lt;typename&gt;</code> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#code","title":"Code","text":"<pre><code>#include &lt;forward_list&gt;\n#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\nusing std::forward_list;\ntemplate &lt;class T&gt;\nforward_list&lt;T&gt; mergeTwoSortedLists(forward_list&lt;T&gt; *list1, forward_list&lt;T&gt; *list2) {\nforward_list&lt;T&gt; mergeList; // Output linked list O(N) space.\nauto list1_ptr = list1-&gt;begin();\nauto list2_ptr = list2-&gt;begin();\nwhile (list1_ptr != list1-&gt;end() &amp;&amp; list2_ptr != list2-&gt;end()) {\nif (*list1_ptr &lt; *list2_ptr) {\nmergeList.push_front(*list1_ptr);\nstd::advance(list1_ptr, 1);\n} else if (*list1_ptr &gt; *list2_ptr) {\nmergeList.push_front(*list2_ptr);\nstd::advance(list2_ptr, 1);\n} else {\nmergeList.push_front(*list1_ptr);\nstd::advance(list1_ptr, 1);\nstd::advance(list2_ptr, 1);\n}\n}\nif (list1_ptr == list1-&gt;end() &amp;&amp; list2_ptr != list2-&gt;end()) {\nwhile (list2_ptr != list2-&gt;end()) {\nmergeList.push_front(*list2_ptr);\nstd::advance(list2_ptr, 1);\n}\n} else if (list1_ptr != list1-&gt;end() &amp;&amp; list2_ptr == list2-&gt;end()) {\nwhile (list1_ptr != list1-&gt;end()) {\nmergeList.push_front(*list1_ptr);\nstd::advance(list1_ptr, 1);\n}\n}\nmergeList.reverse();\nreturn mergeList;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity","title":"Time and Space complexity","text":"<p>Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#implementing-this-problem-in-place","title":"Implementing this problem in-place","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#step-wise-iteration-explainer","title":"Step wise iteration explainer","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#iteration-1","title":"Iteration 1","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#iteration-2","title":"Iteration 2","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#iteration-3","title":"Iteration 3","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#iteration-4","title":"Iteration 4","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#iteration-5-and-so-on-and-the-last","title":"Iteration 5, and so on and the last","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\nif (list1 == NULL)\nreturn list2;\nif (list2 == NULL)\nreturn list1;\nauto* dummyNode = new ListNode();\nauto* temp = dummyNode;\nwhile (list1 &amp;&amp; list2){\nif (list1-&gt;val &lt; list2-&gt;val){\ntemp-&gt;next = list1;\nlist1 = list1-&gt;next;\n}else{\ntemp-&gt;next = list2;\nlist2 = list2-&gt;next;\n}\ntemp = temp-&gt;next;\n}\nif (list1){\ntemp-&gt;next = list1;\n}else if (list2){\ntemp-&gt;next = list2;\n}\nreturn dummyNode-&gt;next;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#delete-node-in-a-linked-list","title":"Delete Node in a Linked List","text":"<p>Problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_3","title":"Problem Statement","text":"<p>Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#example","title":"Example","text":"<p>Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list.</p> <p>Output: [4,1,9],</p> <p>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_3","title":"Approach","text":"<ul> <li>Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space.</li> </ul> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\nvoid deleteNode(ListNode* node) {\nListNode* nextNode = node-&gt;next;\nint valueAtNext = nextNode-&gt;val;\nnode-&gt;val = valueAtNext;\nListNode* nextToNextNode = nextNode-&gt;next;\nnode-&gt;next = nextToNextNode;\ndelete(nextNode);\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#remove-nth-node-from-end-of-list","title":"Remove Nth Node From End of List","text":"<p>Given the head of a linked list, remove the nth node from the end of the list and return its head</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#video-explaination","title":"Video Explaination","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#example_1","title":"Example","text":"<p>For elements \\([1, 2, 3, 4, 5]\\), remove the second node from the last. This will return \\([1, 2, 3, 5]\\). Similarly \\([1]\\) and \\(n = 1\\) will return \\([]\\). </p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#constraints","title":"Constraints","text":"<p>Nodes are given either in a <code>forward_list&lt;typename&gt;</code> or in a custom linked list which is defined below. <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n</code></pre></p> <ul> <li>The number of nodes in the list is \\(\\mathcal{N}\\)</li> <li>1 &lt;= \\(\\mathcal{N}\\) &lt;= 30</li> <li>0 &lt;= <code>(new ListNode())-&gt;val</code> &lt;= 100</li> <li>1 &lt;= n &lt;= \\(\\mathcal{N}\\) (n is within the bounds).</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_4","title":"Approach","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#implementation-with-two-pass","title":"Implementation with two pass","text":"<ul> <li>Find the size of the linked list.</li> <li>We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1).</li> <li>Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution.</li> </ul> <pre><code>struct ListNode{\nint value;\nListNode *following;\n};\nListNode *removeFromEnd(ListNode*head, int end){\nint size = 0;\nListNode *start = head;\nwhile (start){\nstart = start-&gt;following;\nsize++;\n}\nif (size &lt;= 1){\n// This means only one element is there and removing that\n// should return nothing.\nreturn NULL;\n}\nint indexToRemove = size - end + 1;   // Index starts from 1 in this case\nif (indexToRemove == 1){\n// Return head-&gt;following if indexToRemove is the first one.\nreturn head-&gt;following;\n}\nListNode* prev = head;\nListNode* current = head-&gt;following;  // Mark at the 2nd element\nint indxpos = 2;  // Starting from 2nd element\nwhile (indxpos != indexToRemove){\nprev = prev-&gt;following;\ncurrent = current-&gt;following;\nindxpos+=1;\n}\nListNode* following = current-&gt;following;\nprev-&gt;following = following;\nreturn head;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#implementation-with-one-pass-only","title":"Implementation with one pass only","text":"<ul> <li>With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list.</li> <li>Observation: If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last. </li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#a-bit-modification","title":"A bit modification","text":"<p>We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this</p> <p></p> <p>Now walking backwards the starting arrangement of those pointers should be this way</p> <p></p> <p>To make that arrangement we need to traverse through the list like the following</p> <p></p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#edge-case","title":"Edge Case","text":"<p>There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list.</p> <p>For second case you should add the following check <pre><code>if (head-&gt;following == NULL) return NULL;\n</code></pre></p> <p>And for the first case let's run the above algorithm and see what happens.</p> <p></p> <p>So in this case the size of the linked list is 5 and \\(N = 5\\). So now at <code>gap = 5</code> right points to <code>NULL;</code>. We could add the check like this: <pre><code>if (right){\nListNode *ref = left-&gt;following;\nleft-&gt;following = left-&gt;following-&gt;following;\n}else{\n// Delete the first Node, because right points to NULL\nreturn head-&gt;following;\n}\n</code></pre></p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code","title":"C++ Code","text":"<pre><code>ListNode *removeFromEndOnePass(ListNode*head, int end){\nif (head-&gt;following == NULL) return NULL;\nint currentGap = 0;\nListNode *left = head;\nListNode *right = head;\nwhile (currentGap!= end){\ncurrentGap++;\nright = right-&gt;following;\n}\nif (right){\nListNode *ref = left-&gt;following;\nleft-&gt;following = left-&gt;following-&gt;following;\n}else{\nreturn head-&gt;following;\n}\nreturn head;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity_1","title":"Time and space complexity","text":"<ul> <li>For both the solution \\(O(N)\\). But 2 pass solution will take more time.</li> <li>Both are cosntant space solution.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#add-two-numbers-given-as-linkedlists","title":"Add Two Numbers Given as LinkedLists","text":"<p>Asked in Amazon, Microsoft, Facebook, Qualcomm.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#elsewhere","title":"Elsewhere","text":"<ol> <li>Find the Problem on Leetcode \\(\\to\\)</li> <li>Problem on Binary Search \\(\\to\\)</li> </ol>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_4","title":"Problem Statement","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#testcase-examples","title":"Testcase Examples","text":"<p>\\(l_1 = [2,4,3] \\:\\&amp;\\: l_2 = [5,6,4]\\). Corrosponding Output \\(= [7,0,8]\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_5","title":"Approach","text":"<ul> <li>Do normal addition from 1st standard and add digit by digit in a new linked list.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_1","title":"C++ code","text":"<pre><code>#include &lt;forward_list&gt;\n#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\nusing std::forward_list;\nforward_list&lt;int&gt; addTwoNumbers(forward_list&lt;int&gt; *number1, forward_list&lt;int&gt; *number2) {\nforward_list&lt;int&gt; result;\nint digit_sum;\nint carryFlag = 0;\nauto n1iter = number1-&gt;begin();\nauto n2iter = number2-&gt;begin();\nwhile (n1iter != number1-&gt;end() &amp;&amp; n2iter != number2-&gt;end()) {\nif (carryFlag == 0) {\ndigit_sum = 0;\n} else {\ndigit_sum = 1;\n}\ndigit_sum += (*n1iter + *n2iter);\nif (digit_sum &gt;= 10) {\ncarryFlag = 1;\n} else {\ncarryFlag = 0;\n}\nresult.push_front(digit_sum % 10);\nstd::advance(n1iter, 1);\nstd::advance(n2iter, 1);\n}\n// While loop broken meaning both are same or any one\n// of the numbers have more digits.\nif (n1iter != number1-&gt;end() &amp;&amp; n2iter == number2-&gt;end()) {\n// Means n2 got finished and n1 remains\nwhile (n1iter != number2-&gt;end()) {\nif (carryFlag == 0) {\ndigit_sum = (*n1iter);\n} else {\ndigit_sum = (*n1iter) + 1;\n}\nif (digit_sum &gt;= 10) {\ncarryFlag = 1;\n} else {\ncarryFlag = 0;\n}\nresult.push_front(digit_sum % 10);\nstd::advance(n1iter, 1);\n}\n} else if (n1iter == number1-&gt;end() &amp;&amp; n2iter != number2-&gt;end()) {\n// Means n1 got finished and n2 remains\nwhile (n2iter != number2-&gt;end()) {\nif (carryFlag == 0) {\ndigit_sum = (*n2iter);\n} else {\ndigit_sum = (*n2iter) + 1;\n}\nif (digit_sum &gt;= 10) {\ncarryFlag = 1;\n} else {\ncarryFlag = 0;\n}\nresult.push_front(digit_sum % 10);\nstd::advance(n2iter, 1);\n}\n}\nif (n1iter == number1-&gt;end() &amp;&amp; n2iter == number2-&gt;end()) {\n// Both got ended, then add 1 from the carry to the result\nif (carryFlag) {\nresult.push_front(1);\n}\n}\nreturn result;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code-for-leetcode-with-custom-definition-for-singly-linked-list","title":"C++ code for leetcode with custom definition for singly-linked list","text":"<p>Instead of using the <code>stl</code> itself C++ solution on a custom linked list.</p> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode* answer = new ListNode(-999999);\nListNode* temp = answer;\nint digitLevelSum;\nint carry = 0;\nwhile(l1 &amp;&amp; l2){\ndigitLevelSum = 0;\nif (carry == 0){\ndigitLevelSum = l1-&gt;val + l2-&gt;val;\n}else{\ndigitLevelSum = l1-&gt;val + l2-&gt;val + 1;\n}\nif (digitLevelSum &gt;= 10){\ncarry = 1;\n}else{\ncarry = 0;\n}\nListNode* digitLevelEntry = new ListNode(digitLevelSum % 10);\ntemp-&gt;next = digitLevelEntry;\ntemp = digitLevelEntry;\nl1 = l1-&gt;next;\nl2 = l2-&gt;next;\n}\nif (l1 != NULL &amp;&amp; l2 == NULL){\nwhile(l1){\ndigitLevelSum = 0;\nif (carry == 0){\ndigitLevelSum = l1-&gt;val;\n}else{\ndigitLevelSum = l1-&gt;val + 1;\n}\nif (digitLevelSum &gt;= 10){\ncarry = 1;\n}else{\ncarry = 0;\n}\nListNode* digitLevelEntry = new ListNode(digitLevelSum % 10);\ntemp-&gt;next = digitLevelEntry;\ntemp = digitLevelEntry;\nl1 = l1-&gt;next;\n}\n} else if (l1 == NULL &amp;&amp; l2 != NULL){\nwhile(l2){\ndigitLevelSum = 0;\nif (carry == 0){\ndigitLevelSum = l2-&gt;val;\n}else{\ndigitLevelSum = l2-&gt;val + 1;\n}\nif (digitLevelSum &gt;= 10){\ncarry = 1;\n}else{\ncarry = 0;\n}\nListNode* digitLevelEntry = new ListNode(digitLevelSum % 10);\ntemp-&gt;next = digitLevelEntry;\ntemp = digitLevelEntry;\nl2 = l2-&gt;next;\n}\n} if (!(l1&amp;&amp;l2)){\nif (carry == 1){\nListNode* digitLevelEntry = new ListNode(1);\ntemp-&gt;next = digitLevelEntry; }\n}\nreturn answer-&gt;next;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#intersection-of-two-linked-lists","title":"Intersection of Two Linked Lists","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_5","title":"Problem Statement","text":"<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return <code>null</code>.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#example_2","title":"Example","text":"<p>For the following problem, head1 and head2 are given, find the marked blue intersection point. </p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_6","title":"Approach","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#brute-force-approach","title":"Brute Force approach","text":"<ul> <li>For each element in <code>list1</code>, check if the element is in <code>list2</code> by comparing the addresses not the values because values can be same in different lists.</li> <li>This takes \\(O(M*N)\\) time and no extra space.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#using-hash-table","title":"Using Hash table","text":"<ul> <li>As we have to compare if something is present or not we can use hash table to do so.</li> <li>If the node is present in both the list means, they must have the same value and the same address.</li> <li>First we'll create an <code>std::unordered_map&lt;long long int, int&gt; dict;</code>. The key should be <code>long long int</code> address of list nodes, and the value should be the value at that address.</li> <li>Now for each element in the second list check that <code>std::unordered_map&lt;long long int, int&gt; dict;</code> has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_2","title":"C++ Code","text":"<pre><code>class Solution {\npublic:\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n// address to value mapping\nstd::unordered_map&lt;long long int, int&gt; dict;\n// Iterate and Add all the entries of listA\nauto listAiterator = headA;\nwhile(listAiterator){\n// Convert the address to a long long int\n// This is the virtual address only, NOT the physical address.\nlong long int address = reinterpret_cast&lt;long long int&gt;(listAiterator);\ndict.insert(make_pair(address, listAiterator-&gt;val));\nlistAiterator = listAiterator-&gt;next;\n}\n// Now for all element see if the address is already in the map?\n// If it's in the map means this is the merge point.\nauto listBiterator = headB;\nwhile(listBiterator){\n// cast the address to a long long int\nlong long int address = reinterpret_cast&lt;long long int&gt;(listBiterator);\nauto search = dict.find(address);\nif (search != dict.end()){\nbreak;\n} else {\nlistBiterator = listBiterator-&gt;next;\n}\n}\nif (listBiterator){\nreturn listBiterator;\n}\nreturn NULL;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity_2","title":"Time and Space Complexity","text":"<ul> <li>As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists.</li> <li>Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#linear-time-and-constant-space-approach","title":"Linear time and Constant Space Approach","text":"<ul> <li>Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean:</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code-for-most-optimal-approach","title":"C++ Code for Most Optimal Approach","text":"<pre><code>class Solution {\npublic:\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\nint sizeA = 0;\nint sizeB = 0;\n// O(max(m, n))\nListNode* Aptr = headA;\nListNode* Bptr = headB;\nwhile(Aptr || Bptr){\nif (Aptr){\nsizeA++;\nAptr = Aptr-&gt;next;\n}\nif (Bptr){\nsizeB++;\nBptr = Bptr-&gt;next;\n}\n}\nint headerDifference = sizeA - sizeB;\nif (headerDifference &lt; 0){\n// Size B is higher\n// So advance B upto headerDifference\nwhile (headerDifference!=0){\nheadB = headB-&gt;next;\nheaderDifference++;\n}\n} else {\n// Size A is higher\n// So advance A upto headerDifference\nwhile (headerDifference!=0){\nheadA = headA-&gt;next;\nheaderDifference--;\n}\n}\nwhile(headA &amp;&amp; headB){\nif (headA == headB){\nreturn headA;\n}else{\nheadA = headA-&gt;next;\nheadB = headB-&gt;next;\n}\n}\nreturn NULL;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity_3","title":"Time and Space Complexity","text":"<ul> <li>The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity.</li> <li>No extra space required.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#detect-a-cycle-in-linked-list","title":"Detect a cycle in linked list","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_7","title":"Approach","text":"<ul> <li>Create 2 pointers and then move ahead,</li> <li>slow pointer will move one step up,</li> <li>fast pointer will move twos step up,</li> <li>if fast pointer reaches <code>NULL</code> somehow, this means there is no cycle in linked list.</li> <li>If that does not happens and some time after <code>fast == slow</code>, means there is a cycle in linked list. Return <code>true</code>.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_3","title":"C++ Code","text":"<pre><code>class Solution {\npublic:\nbool hasCycle(ListNode *head) {\nListNode* slow = head;\nListNode* fast = head;\nwhile (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next){\nslow = slow-&gt;next;\nfast = fast-&gt;next-&gt;next;\nif(slow == fast){\nreturn true;\n}\n}\nreturn false;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity_4","title":"Time and space complexity","text":"<ul> <li>\\(O(N)\\) time and no extra space.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#palindrome-linked-list","title":"Palindrome Linked list","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_7","title":"Problem Statement","text":"<p>Given the head of a singly linked list, return true if it is a palindrome.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach-with-more-space","title":"Approach With More Space","text":"<ul> <li>First we push all the value to a new stack.</li> <li>Then we pop the value and compare it to the list head. If same we move forward and if not we return <code>false</code>.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_4","title":"C++ Code","text":"<pre><code>class Solution {\npublic:\nbool isPalindrome(ListNode* head) {\nif (head == NULL or head-&gt;next == NULL) return true;\nvector&lt;int&gt; stk;\nListNode* headIterator = head;\nwhile(headIterator){\nstk.push_back(headIterator-&gt;val);\nheadIterator = headIterator-&gt;next;\n}\nListNode* headIterator2 = head;\nwhile(stk.size() != 0 and headIterator2){\nif (stk.back() != headIterator2-&gt;val){\nreturn false;\n}\nheadIterator2 = headIterator2-&gt;next;\nstk.pop_back();\n}\nreturn true;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#more-optimized-approach","title":"More optimized approach","text":"<ul> <li>Break down the linked list into 2 parts by finding the middle.</li> <li>From the middle element reverse the linked list.</li> <li>Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return <code>false</code>.</li> </ul> <pre><code>class Solution {\nprivate:\nListNode* reverseSubRoutine(ListNode *head){\nListNode* current = head;\nListNode* prev = NULL;\nwhile(current){\nListNode *nextToCurrent = current-&gt;next;\ncurrent-&gt;next = prev;\nprev = current;\ncurrent = nextToCurrent;\n}\nreturn prev;\n}\nListNode *findMidPoint(ListNode* head){\nListNode *slow = head;\nListNode *fast = head;\nwhile(fast and fast-&gt;next){\nslow = slow-&gt;next;\nfast = fast-&gt;next-&gt;next;\n}\nreturn slow;\n}\nint listSize(ListNode *head){\nint sz = 0;\nListNode*i_ptr = head;\nwhile(i_ptr){\ni_ptr = i_ptr-&gt;next;\nsz++;\n}\nreturn sz;\n}\npublic:\nbool isPalindrome(ListNode* head) {\nif (head == NULL or head-&gt;next == NULL) return true;\nListNode *midpoint = findMidPoint(head);\n// Reverse from mid point\nListNode *reversedHead = reverseSubRoutine(midpoint);\nListNode *traverse = head;\nwhile(traverse-&gt;next != midpoint){\ntraverse = traverse-&gt;next;\n}\ntraverse-&gt;next = reversedHead;\n// Now the thing is reversed.\n// Now get the length of the list\nint size = listSize(head);\nif (size % 2 != 0){\n// The list is not even length means there is one random element at the middle\nListNode *newMidPoint = findMidPoint(head);\nListNode *traveler = newMidPoint;\nwhile(traveler-&gt;next){\nif (head-&gt;val != traveler-&gt;val){\nreturn false;\n}\ntraveler = traveler-&gt;next;\nhead = head-&gt;next;\n}\n} else {\n// The list is even length.\nListNode *newMidPoint = findMidPoint(head);\nListNode *traveler = newMidPoint;\nwhile(traveler){\nif (head-&gt;val != traveler-&gt;val){\nreturn false;\n}\ntraveler = traveler-&gt;next;\nhead = head-&gt;next;\n}\n}\nreturn true;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#find-the-starting-point-of-cycle-in-linked-list","title":"Find the starting point of cycle in linked list","text":"<p>Problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_8","title":"Problem Statement","text":"<p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p> <p></p> <p>Do not modify the linked list.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#constraints_1","title":"Constraints","text":"<ul> <li>The number of the nodes in the list is in the range [\\(0\\), \\(10^4\\)].</li> <li>\\(-10^5\\) &lt;= <code>Node.val</code> &lt;= \\(10^5\\)</li> <li>You solve it using \\(O(1)\\) (i.e. constant) memory,</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#linked-list-definition","title":"Linked List definition","text":"<pre><code>// Definition for singly-linked list.\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(NULL) {}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach-with-extra-space","title":"Approach with extra space","text":"<ul> <li>We can hash all the nodes while traversing the list,</li> <li>If we find a <code>node == nullptr</code> we stop and say NO cycle present.</li> <li>Else if we find a node that has been already hashed then we say this is the entry point of the cycle.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#pseudocode-for-this-apporach","title":"Pseudocode for this apporach","text":"<pre><code>ListNode* hash = HashTable();\nListNode* node = LinkedListHead();\nwhile(node){\nif (hash.contains(node)){\nreturn node;\n}\nhash(node);\nnode = node.next;\n}\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-space-complexity_5","title":"Time and Space complexity","text":"<ul> <li>Time is \\(O(N)\\),</li> <li>Space is \\(O(N)\\) for the hashtable.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach-with-no-extra-space","title":"Approach with no extra space","text":"<ul> <li>First we run the sub-routine of <code>if_has_loop()</code>,</li> <li>That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node.</li> <li>If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started.     </li> <li>Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#video-for-intuition","title":"Video for intuition","text":"<p>The following is a video explaining why this apporach works?</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_5","title":"C++ Code","text":"<pre><code>class Solution {\npublic:\nListNode *detectCycle(ListNode *head) {\nif (head == nullptr or head-&gt;next == nullptr) return nullptr;\nListNode *slowPointer = head;\nListNode *fastPointer = head;\nListNode *traveller = head;\nwhile((fastPointer!=nullptr) and (fastPointer-&gt;next!=nullptr)){\nslowPointer = slowPointer-&gt;next;\nfastPointer = fastPointer-&gt;next-&gt;next;\nif (slowPointer == fastPointer){\nbreak;\n}\n}\nif ((fastPointer) and (fastPointer-&gt;next)){\n// Means there is cycle in the list\nwhile(slowPointer != traveller){\nslowPointer = slowPointer-&gt;next;\ntraveller = traveller-&gt;next;\n}\nreturn traveller;\n}\n// Means there is no cycle in the list\nreturn nullptr;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#given-the-head-of-a-linked-list-rotate-the-list-to-the-right-by-k-places","title":"Given the head of a linked list, rotate the list to the right by k places","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_9","title":"Problem Statement","text":"<p>Given the head of a linked list, rotate the list to the right by k places.</p> <p>Test case examples</p> <p>Input: head = <code>[1,2,3,4,5]</code>, k = 2 Output: <code>[4,5,1,2,3]</code></p> <p>Input: head = [0,1,2], k = 4 Output: [2,0,1]</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#constraints_2","title":"Constraints:","text":"<ol> <li>The number of nodes in the list is in the range \\([0, 500]\\)</li> <li>\\(-100\\) &lt;= <code>Node.val</code> &lt;= \\(100\\)</li> <li>\\(0\\) &lt;= k &lt;= \\(2 * 10^9\\)</li> </ol>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_8","title":"Approach","text":"<ul> <li>First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example     </li> <li>So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list.</li> <li>Now armed with this knowledge, we can think of what it means to be rotating the list?     <ul> <li>In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = <code>NULL</code>,</li> <li>and add the last <code>2</code> elements to the front of the list.</li> </ul> </li> <li>We can approach this via the following way:<ul> <li>First set the final element's next = <code>firstNode</code>.</li> <li>Now set the point where it supposed to be the new head by breaking off the <code>prevNode</code>'s next = <code>NULL</code>.</li> </ul> </li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_6","title":"C++ Code","text":"<pre><code>class Solution {\nprivate:\npair&lt;int, ListNode *&gt; getSizeAndLastNode(ListNode *head){\nint size = 0;\nListNode *headref = head;\nwhile(headref-&gt;next){\nsize++;\nheadref = headref-&gt;next;\n}\nsize++;\nreturn make_pair(size, headref);\n}\npublic:\nListNode* rotateRight(ListNode* head, int k) {\nif (head == NULL || head-&gt;next == NULL) {\nreturn head;\n}\npair&lt;int, ListNode*&gt; p = getSizeAndLastNode(head);\nint size = p.first;\nListNode *last = p.second;\nint numberOfRotation = k % size;  // Number of effective rotation\n// now last points to the last node\n// making it full circle\nlast -&gt; next = head;\n// figure out the break point?\nint breakPoint = size - numberOfRotation;\nint index = 1;\nwhile(index!=breakPoint){\nindex++;\nhead = head -&gt; next;\n}\nListNode *newHead = head-&gt;next;\nhead-&gt;next = nullptr;\nreturn newHead;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#another-approach","title":"Another Approach","text":"<ul> <li>We get hold of the last node and the size of the list,</li> <li>Rotating k times to the right means rotating \\(\\text{size} - k\\) times to the left,</li> <li>Once we have that, rotating left is as easy as the following<ul> <li>Set markers on start and end of the list,</li> <li>Set new head as the <code>head-&gt;next</code>,</li> <li>Set <code>end-&gt;next</code> as the node previously at the start of the list,</li> <li>Set new end as this node, and</li> <li>Set new <code>end-&gt;next</code> as <code>nullptr</code></li> </ul> </li> <li>This is how we can easily rotate the list.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-code_7","title":"C++ Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\nint sizeOf(ListNode* head) {\nint size = 0;\nwhile(head) {\nhead = head-&gt;next;\nsize++;\n}\nreturn size;\n}\npublic:\nListNode* rotateRight(ListNode* head, int k) {\nif (not head or not head-&gt;next) return head;\nint size = sizeOf(head);\n// k times rotate to the right means size - k  times rotate to left\nint rotations = size - (k % size);\n// set the end pointer\nListNode* end = head;\nwhile (end-&gt;next) end = end-&gt;next;\nwhile (rotations &gt; 0) {\nListNode* tempHead = head;\nhead = head-&gt;next;\nListNode* tempEnd = end;\nend-&gt;next = tempHead;\ntempHead-&gt;next = nullptr;\nend = tempHead;\nrotations--;\n}\nreturn head;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#copy-list-with-random-pointer","title":"Copy List with Random Pointer","text":"<p>Find the Problem on leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_10","title":"Problem Statement","text":"<p>A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.</p> <p>Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.</p> <p>For example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y.</p> <p>Return the head of the copied linked list.</p> <p>The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p> <ul> <li><code>val</code>: an integer representing <code>Node.val</code></li> <li><code>random_index</code>: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#c-node-definition","title":"C++ Node definition","text":"<pre><code>class Node {\npublic:\nint val;\nNode* next;\nNode* random;\nNode(int _val) {\nval = _val;\nnext = NULL;\nrandom = NULL;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_9","title":"Approach","text":"<ul> <li>Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list.</li> <li>During this time also record a <code>unordered_map&lt;long long int, long long int&gt;</code> of list nodes and corrosponding deep copy of the node's address.</li> <li>Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of <code>map[list.random]</code>.</li> </ul> <pre><code>class Solution {\npublic:\nNode* copyRandomList(Node* head) {\nNode *copy = new Node(-6969);\nNode *copyTraveller = copy;\nNode *traveller = head;\nunordered_map&lt;long long int, long long int&gt; map;\nwhile(traveller){\nlong long int thisNodeAddress = reinterpret_cast&lt;long long int&gt; (traveller);\nint thisNodeValue = traveller-&gt;val;\n// Create a node copy and store the address here for later mapping.\nNode *nextCpy = new Node(thisNodeValue);\ncopyTraveller-&gt;next = nextCpy;\ncopyTraveller = copyTraveller-&gt;next;\nlong long int copyNodeAddress = reinterpret_cast&lt;long long int&gt; (nextCpy);\nmap.insert({thisNodeAddress, copyNodeAddress});\ntraveller = traveller-&gt;next;\n}\nNode* traveller1 = copy-&gt;next;\nNode* traveller2 = head;\nwhile(traveller1 and traveller2){\ntraveller1-&gt;random = reinterpret_cast&lt;Node*&gt; (map[reinterpret_cast&lt;long long int&gt; (traveller2-&gt;random)]);\ntraveller1 = traveller1-&gt;next;\ntraveller2 = traveller2-&gt;next;\n}\nreturn copy-&gt;next;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#time-and-memory-complexity","title":"Time and Memory complexity","text":"<ul> <li>We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and</li> <li>we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#merge-k-sorted-lists","title":"Merge k Sorted Lists","text":"","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_11","title":"Problem Statement","text":"<p>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.</p> <p>Merge all the linked-lists into one sorted linked-list and return it.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#example_3","title":"Example","text":"<pre><code>Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\nInput: lists = []\nOutput: []\n\nInput: lists = [[]]\nOutput: []\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_10","title":"Approach","text":"<ul> <li>To merge \\(K\\) sorted list we'll use a subroutine merge \\(2\\) sorted list.</li> <li>Using that <code>merge2list</code> subroutine will merge like the merge sort algorithm, and the result will be a sorted list.</li> <li>To merge 2 sorted list you should watch the explaination here.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#code_1","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\nListNode* merge2list(ListNode* head1, ListNode* head2) {\nif (!head1) return head2;\nif (!head2) return head1;\nListNode* l1;\nListNode* l2;\nif (head1-&gt;val &lt;= head2-&gt;val) {\nl1 = head1;\nl2 = head2;\n}\nif (head1-&gt;val &gt; head2-&gt;val) {\nl1 = head2;\nl2 = head1;\n}\nListNode* dummy = new ListNode();\nListNode* temp = dummy;\nwhile (l1 and l2) {\nif (l1-&gt;val &lt; l2-&gt;val) {\ntemp-&gt;next = l1;\nl1 = l1-&gt;next;\n} else if (l1-&gt;val &gt;= l2-&gt;val) {\ntemp-&gt;next = l2;\nl2 = l2-&gt;next;\n}\ntemp = temp-&gt;next;\n}\nif (!l1) temp-&gt;next = l2;\nif (!l2) temp-&gt;next = l1;\nreturn dummy-&gt;next;\n}\npublic:\nListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n// call mergeSubRoutine on 2 lists\n// until mergeAll results to 1 list only\nif (lists.size() == 0) return nullptr;\nif (lists.size() == 1) return lists[0];\nwhile (lists.size() &gt; 1) {\nvector&lt;ListNode*&gt; temp;\nfor (int i=0; i&lt;lists.size(); i+=2) {\n// take up 2 lists to merge\nListNode* l1 = lists[i];\nListNode* l2;\nif (i+1 &gt; lists.size() - 1) {\nl2 = nullptr;\n} else {\nl2 = lists[i+1];\n}\ntemp.push_back(merge2list(l1, l2));\n}\n// now in temp we have all the 2 merged lists\n// we should update the lists as the temp\nlists = temp;\n}\n// at the end all are merged so we've only one list, so return it\nreturn lists[0];\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#reverse-nodes-in-k-group","title":"Reverse Nodes in k-Group","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#problem-statement_12","title":"Problem Statement","text":"<p>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.</p> <p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p> <p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#example_4","title":"Example","text":"<p> <pre><code>Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n</code></pre></p>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#approach_11","title":"Approach","text":"<ul> <li>We'll find the \\(k^{th}\\) node from the head of the list and then reverse it in-place, let's call it a group</li> <li>We'll then jump k places to reverse the next group, until we find the last group where there is remaining \\(\\geq 0 \\text{ and} \\leq k\\) elements. Then we stop there.</li> </ul>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/problems/#code_2","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\nListNode* kth(ListNode* head, int k) {\nwhile (head and k &gt; 0) {\nhead = head-&gt;next;\nk--;\n}\nreturn head;\n}\npublic:\nListNode* reverseKGroup(ListNode* head, int k) {\nauto dummy = new ListNode(0, head);\nauto prevEnd = dummy;\nwhile (true) {\nauto kthNode = kth(prevEnd, k);\nif (not kthNode) break;\nauto groupNext = kthNode-&gt;next;\n// we have the head and the kth node\n// so we should reverse it\nauto prev = groupNext;\nauto current = prevEnd-&gt;next;\nwhile (current!=groupNext) {\nauto temp = current-&gt;next;\ncurrent-&gt;next = prev;\nprev = current;\ncurrent = temp;\n}\nauto temp = prevEnd-&gt;next;\nprevEnd-&gt;next = kthNode;\nprevEnd = temp;\n}\nreturn dummy-&gt;next;\n}\n};\n</code></pre>","tags":["Linked List Problems","SDE 1 and SDE 2"]},{"location":"LinkedLists/stl-usage/","title":"Linked List STL operations","text":"<p>Instead of implementing linked list from scratch, better to use the standard template library. C++ <code>stl</code> has 2 linked lists,</p> <ul> <li><code>std::list&lt;typename&gt;</code> is a doubly-linked list data structure, and</li> <li><code>std::forward_list&lt;typename&gt;</code> is a singly-linked list data structure.</li> </ul>"},{"location":"LinkedLists/stl-usage/#table-of-contents","title":"Table of contents","text":"<ul> <li> Linked List STL operations</li> <li>Table of contents</li> <li><code>std::list&lt;typename&gt;</code><ul> <li>Operations</li> <li>Operation Modefiers</li> <li>Essential operations</li> </ul> </li> <li><code>std::forward_list&lt;typename&gt;</code></li> </ul>"},{"location":"LinkedLists/stl-usage/#stdlisttypename","title":"<code>std::list&lt;typename&gt;</code>","text":"<ul> <li>supports constant time insertion and removal of elements from anywhere in the container</li> <li>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</li> </ul>"},{"location":"LinkedLists/stl-usage/#operations","title":"Operations","text":"<ul> <li><code>front()</code> and <code>back()</code> returns front and back elements from the list in \\(O(1)\\) time.</li> </ul> <p><pre><code>#include &lt;list&gt;\n#include &lt;iostream&gt;\nint main() {\nstd::list&lt;char&gt; letters {'d', 'm', 'g', 'w', 't', 'f'};\nif (!letters.empty()) {\nstd::cout &lt;&lt; \"The first character is '\" &lt;&lt; letters.front() &lt;&lt; \"'.\\n\";\nstd::cout &lt;&lt; \"The last character is '\" &lt;&lt; letters.back() &lt;&lt; \"'.\\n\";        }\n}\n</code></pre> - <code>size()</code> returns size of the list in constant time since C++ 11.</p> <pre><code>#include &lt;list&gt;\n#include &lt;iostream&gt;\nint main() { std::list&lt;int&gt; nums {1, 3, 5, 7};\nstd::cout &lt;&lt; \"nums contains \" &lt;&lt; nums.size() &lt;&lt; \" elements.\\n\";\n}\n</code></pre>"},{"location":"LinkedLists/stl-usage/#operation-modefiers","title":"Operation Modefiers","text":"<p>Adding elements, all done in \\(O(1)\\) time. - <code>push_back()</code> - <code>pop_back()</code> - <code>pop_back()</code> - <code>pop_front()</code></p>"},{"location":"LinkedLists/stl-usage/#essential-operations","title":"Essential operations","text":"<p><code>merge()</code> function merges 2 sorted linked lists. <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n// For help in printing lists\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const std::list&lt;int&gt;&amp; list) {\nfor (const auto &amp;i : list) {\nostr &lt;&lt; ' ' &lt;&lt; i;\n}\nreturn ostr;\n}\nint main() {\nstd::list&lt;int&gt; list1 = { 5,9,1,3,3 };\nstd::list&lt;int&gt; list2 = { 8,7,2,3,4,4 };\nlist1.sort();\nlist2.sort();\nstd::cout &lt;&lt; \"list1:  \" &lt;&lt; list1 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"list2:  \" &lt;&lt; list2 &lt;&lt; '\\n';\nlist1.merge(list2);\nstd::cout &lt;&lt; \"merged: \" &lt;&lt; list1 &lt;&lt; '\\n';\nreturn 0;\n}\n</code></pre></p>"},{"location":"LinkedLists/stl-usage/#stdforward_listtypename","title":"<code>std::forward_list&lt;typename&gt;</code>","text":"<ul> <li><code>front()</code> and <code>end()</code> are available.</li> <li><code>end()</code> returns the iterator to the next element of the end of the list in constant time.</li> <li><code>front()</code> is also \\(O(1)\\) and is equivalent to <code>*list.begin()</code></li> <li>No <code>size()</code> available. But has <code>max_size()</code> method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations.</li> <li><code>numbers.empty()</code> method checks if the container has no elements, i.e. whether <code>begin() == end()</code>.</li> </ul>"},{"location":"arrays/array-problems/","title":"Problems on arrays","text":"<p>Questions discussed</p> <ul> <li>Single Number</li> <li>Dutch National Flag Partitioning</li> <li>String Compression Problem</li> <li>Best Time to Buy and Sell Stock</li> <li>Best Time to Buy and Sell Stock II</li> <li>Insert Interval</li> <li>Missing Number</li> <li>Majority Element</li> <li>Rotate Array</li> <li>How Many Numbers Are Smaller Than the Current Number</li> <li>Sort Array By Parity</li> <li>Replace Elements with Greatest Element on Right Side</li> <li>Sort colors</li> <li>Set matrix zeros</li> <li>Leaders in an array</li> <li>Count the number of inversions in an array</li> <li>Rotate Image</li> <li>Product of Array Except Self</li> <li>Two Sum II Input Array Is Sorted</li> <li>Container With Most Water</li> <li>Rain water trapping</li> <li>Two Sum IV</li> <li>Valid Sudoku</li> <li>Sort the Array</li> <li>Greatest Common Divisor of Strings</li> </ul>"},{"location":"arrays/array-problems/#single-number","title":"Single Number","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement","title":"Problem Statement","text":"<p>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.</p>"},{"location":"arrays/array-problems/#approach","title":"Approach","text":"<p>If the problem was given in a sorted array we can implement this binary search approach. But here the array is not sorted. We can use a dictionary but it'll take more space.</p> <p>Only other way of solving this problem is to use XOR operations. For each element in the array if we XOR them with each other we can find the odd one out.</p>"},{"location":"arrays/array-problems/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\nint singleNumber(vector&lt;int&gt;&amp; nums) {\nint start = nums.front();\nfor (int i=1; i&lt;nums.size(); i++) {\nstart ^= nums[i];\n}\nreturn start;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#dutch-national-flag-partitioning","title":"Dutch National Flag Partitioning","text":""},{"location":"arrays/array-problems/#problem-statement_1","title":"Problem Statement","text":"<p>Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color.</p>"},{"location":"arrays/array-problems/#solution-pattern","title":"Solution Pattern","text":"<ul> <li>Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target.</li> <li>For \\(O(N)\\) space solutions we can create three new arrays called <code>less, more, equal</code> and put values into it during the traversal.</li> <li>For \\(O(1)\\) space solutions we can do these steps:<ul> <li>Do - inplace grouping of all the less than target elements during the first pass,</li> <li>Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the <code>less</code> subarray\", so we can break out of the loop.</li> <li>Total time complexity is \\(O(N)\\) for the first pass and on an avarage \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\).</li> </ul> </li> </ul> <pre><code>def dutch_flag_partition(pivot_index: int, A: list[int]) -&gt; None:\npivot_value: int = A[pivot_index]\nsmall: int = 0\n# Group all the smaller elements together at the start\n# This is in-place grouping of elements smaller than some target\nfor i in range(len(A)):\nif A[i] &lt; pivot_value:\nA[small], A[i] = A[i], A[small]\nsmall += 1\n# Group all the larger elements together at the end\nlarger: int = len(A) - 1\nfor i in reversed(range(len(A))):\nif A[i] &lt; pivot_value:\nbreak\nelif A[i] &gt; pivot_value:\nA[i], A[larger] = A[larger], A[i]\nlarger -= 1\n</code></pre> <p>Test Cases</p> <ul> <li>Test PASSED (204/204) [   8 ms]</li> <li>Avarage running time:   65 us</li> <li>Median running time:    13 us</li> </ul> <p>Similar problems</p> <p>Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time.</p>"},{"location":"arrays/array-problems/#string-compression-problem","title":"String Compression Problem","text":""},{"location":"arrays/array-problems/#problem-statement_2","title":"Problem Statement","text":"<p>Implement a method to perform basic string compression, like \"aaaabbbcccaa\" \\(\\to\\) \"a4b3c3a2\"</p>"},{"location":"arrays/array-problems/#approach_1","title":"Approach","text":"<ul> <li>Make a one key dictionary. Add and count the subsequent characters, for C++ you'd make a <code>pair&lt;int, int&gt;</code> and destroy it once a new character is seen,</li> <li>Once you find a new element then drop the key, add the contents to the builder string and count again.</li> </ul>"},{"location":"arrays/array-problems/#code_1","title":"Code","text":"<pre><code>def string_compressing(string: str) -&gt; str:\nbuild_string: list[str] = []  # using character array instead of string for O(1) append\ndictionary: dict[str, int] = {}\nfor character in string:\nif character in dictionary:\ndictionary[character] += 1\nelif character not in dictionary:\nif dictionary != {}:\n# If the dictionary is not empty means we have a new element to consider.\n# Dump the contents to the build_string and make the dictionary = {}\nbuild_string.append(list(dictionary.keys())[0])\nbuild_string.append(str(dictionary[list(dictionary.keys())[0]]))\ndictionary = {}\n# Set the new character count to 1\ndictionary[character] = 1\nbuild_string.append(list(dictionary.keys())[0])\nbuild_string.append(str(dictionary[list(dictionary.keys())[0]]))\nbuild_string = \"\".join(build_string)  # This does not take O(N^2), takes only O(N) to concatenate a character array to a string.\nbuild_string = build_string.replace(\"1\", '')  # O(N)\nreturn build_string\n</code></pre> <pre><code>string_compressing(\"abbbcccaa\")  # -&gt; 'ab3c3a2'\n</code></pre>"},{"location":"arrays/array-problems/#time-complexity","title":"Time complexity","text":"<p>This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string.</p>"},{"location":"arrays/array-problems/#best-time-to-buy-and-sell-stock","title":"Best Time to Buy and Sell Stock","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_3","title":"Problem Statement","text":"<p>You are given an array prices where <code>prices[i]</code> is the price of a given stock on the \\(\\text{i}^{\\text{th}}\\) day.</p> <p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p> <p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return \\(0\\).</p>"},{"location":"arrays/array-problems/#examples","title":"Examples","text":""},{"location":"arrays/array-problems/#example-1","title":"Example 1","text":"<pre><code>Input: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</code></pre>"},{"location":"arrays/array-problems/#example-2","title":"Example 2","text":"<pre><code>Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n</code></pre>"},{"location":"arrays/array-problems/#approach_2","title":"Approach","text":"<ul> <li>We start with the lowest profit possible which is \\(0\\),</li> <li>We'll start the analysis from day \\(1\\) not from day \\(0\\),</li> <li>We indicate the dip is the day \\(0^{th}\\) price. If we buy at that price then we analyse further.</li> <li>Now we analyze from day \\(1 ... N\\)<ul> <li>For day \\(1\\) if we sell that stock the profit will be <code>profSLT = prices[1] - dip</code> at the lowest dip so far, we update the max profit by taking the <code>std::max</code> of previous maximum profit and todays profit.</li> <li>If todays price is lower than the last day's price, it is possible that we can get a better solution (profit) if not we already have stored the last best profit.</li> <li>We repeat this until we reach the last day.</li> </ul> </li> </ul>"},{"location":"arrays/array-problems/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nint maxProfit(vector&lt;int&gt;&amp; prices) {\nint mprof = 0; // maximum profit\nint dip = prices[0]; // should buy at lowest dip starting from day 1\nfor (int i=1; i&lt;prices.size(); i++) {\n// profit if sold today bought at the lowest dip so far;\nint profSLT = prices[i] - dip;\n// if this is the maxprofit then update\nmprof = std::max(mprof, profSLT);\nif (prices[i] &lt; dip) dip = prices[i];\n}\nreturn mprof;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#best-time-to-buy-and-sell-stock-ii","title":"Best Time to Buy and Sell Stock II","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_4","title":"Problem Statement","text":"<p>Similar to the previous problem, you are given an integer array prices where <code>prices[i]</code> is the price of a given stock on the ith day.</p> <p>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</p> <p>Find and return the maximum profit you can achieve.</p>"},{"location":"arrays/array-problems/#approach_3","title":"Approach","text":"<p>Similar to the previous problem we'll continue to implement the logic but, if we see a dip later in the future, we'll sell off and buy at tomorrows dip to avoid any potential loss.</p> <p>Note</p> <p>Here <code>profitInCurrentWindow</code> in the code denotes the profit in the current window. An window is reset when we sell off the stock because there will be a dip in the next day. We start the window by buying the stock in the next dip.</p>"},{"location":"arrays/array-problems/#code_3","title":"Code","text":"<pre><code>class Solution {\npublic:\nint maxProfit(vector&lt;int&gt;&amp; prices) {\nif (prices.size() == 1) return 0;\nint totalProfit = 0;\nint dip = prices[0];\nint profitInCurrentWindow = 0;\n// start from day 1 and local dip so far is day 0's price\nfor (int index = 1; index &lt; prices.size(); index++) {\n// today's price = prices[index]\nint price = prices[index];\n// see if selling today entails profit?\nint profit = price - dip;\n// what is the max profit possible in the current window\nprofitInCurrentWindow = std::max(profitInCurrentWindow, profit);\n// if it is profitable and tomorrow's price goes down don't hold, sell and exit\n// and reset the problem to next day and start again\nif (profit &gt; 0 and index &lt; prices.size() - 1) {\nif (prices[index + 1] &lt; prices[index]) {\ntotalProfit = totalProfit + profitInCurrentWindow;\n// also reset the dip to the index + 1\n// for a new profit calculation for tomorrow\ndip = prices[index + 1];\nindex++; // we reset the entire problem and recalculate everything from the next index\nprofitInCurrentWindow = 0; // reset the profit in the window\n}\n}\nif (price &lt; dip) dip = price;\n}\ntotalProfit += profitInCurrentWindow; // update the last profit window\nreturn totalProfit;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#insert-interval","title":"Insert Interval","text":"<p>Same Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_5","title":"Problem Statement","text":"<p>You are given an array of non-overlapping intervals intervals where \\(\\text{intervals}[i] = [\\text{start}_i, \\text{end}_i]\\) represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval \\(\\text{newInterval} = [\\text{start}, \\text{end}]\\) that represents the start and end of another interval.</p> <p>Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).</p> <p>Return intervals after the insertion.</p>"},{"location":"arrays/array-problems/#examples_1","title":"Examples","text":"<pre><code>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</code></pre>"},{"location":"arrays/array-problems/#missing-number","title":"Missing Number","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_6","title":"Problem statement","text":"<p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>"},{"location":"arrays/array-problems/#example","title":"Example","text":"<pre><code>Input: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. \n2 is the missing number in the range since it does not appear in nums.\n</code></pre>"},{"location":"arrays/array-problems/#approach_4","title":"Approach","text":"<ul> <li>There can be several approaches, one of which is sorting then find what's missing?</li> <li>There is also another approach where you sum up all the numbers (using \\(\\frac{n(n+1)}{2}\\)) then subtract from elements present in the array. This is a \\(O(N)\\) and constant space solution. But using this is risky because if \\(n\\) is anywhere large enough to \\(\\text{INT_MAX}\\) then there is a high probability that \\(\\frac{n(n+1)}{2}\\) overflows. So it is not recommended to use this approach instead use the following one:</li> <li>There is another approach where you use XOR operations to find the missing elements. I have written all the code for all the approaches below. Here is no chance of integer overflow or anything. For XOR apporach you first have to find the XOR of elements from \\(\\{1 \\to n\\}\\) then find the XOR of elements present in the array. Now XOR between these two is the missing element so return it.</li> </ul>"},{"location":"arrays/array-problems/#code_4","title":"Code","text":""},{"location":"arrays/array-problems/#using-sorting-method","title":"Using sorting method","text":"<pre><code>class Solution {\npublic:\nint missingNumber(vector&lt;int&gt;&amp; nums) {\nstd::sort(nums.begin(), nums.end());\nint index = 0;\nfor (auto i:nums) {\nif (i != index) return index;\nindex++;\n}\nreturn index;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#using-sum-and-substraction-method","title":"Using sum and substraction method","text":"<pre><code>class Solution {\npublic:\nint missingNumber(vector&lt;int&gt;&amp; nums) {\nint n = nums.size();\nint sum = n*(n+1) / 2;\nfor (int i:nums) sum -= i;\nreturn sum;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#using-xor-method","title":"Using XOR Method","text":"<pre><code>class Solution {\npublic:\nint missingNumber(vector&lt;int&gt;&amp; nums) {\nint l1 = 0; // contains xor of 1 to n\nint l2 = nums[0]; // contains xor of all the nums elements\nfor (int i=0; i &lt;= nums.size(); i++) {\nl1 ^= i;\n}\nfor (int j=1; j&lt;nums.size(); j++) {\nl2 ^= nums[j];\n}\nreturn l1^l2;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#majority-element","title":"Majority Element","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_7","title":"Problem Statement","text":"<p>Given an array nums of size n, return the majority element.</p> <p>The majority element is the element that appears more than \\(\\lfloor\\frac{n}{2}\\rfloor\\) times. You may assume that the majority element always exists in the array.</p>"},{"location":"arrays/array-problems/#approach_5","title":"Approach","text":"<ul> <li>One approach is to use a dictionary to implement a counter for each element. Then find what is \\(\\gt \\lfloor\\frac{n}{2}\\rfloor\\), but it'll take extra \\(O(n)\\) space. So we need to find a new approach.</li> <li>There is an algorithm called boyer moore majority voting algorithm, using that we can easily find the majority element in the array.</li> </ul>"},{"location":"arrays/array-problems/#boyer-moore-algorithm","title":"Boyer Moore Algorithm","text":"<p>Boyer\u2013Moore majority vote algorithm can find the majority of a sequence of elements using linear time and constant space if exists. The returned result may not be the majority element (if not exists), so we have to do an additional check if the indicated element indeed the majority element.</p> <p>The algorithm goes like this:</p> <ul> <li>Initialize an element majority and a counter <code>counter</code> with <code>counter = 0</code></li> <li>For each element x of the input sequence:<ul> <li>If <code>counter = 0</code>, then assign majority as x and <code>counter = 1</code></li> <li>If you encounter next the same element as the majority element you increment the counter.</li> <li>Otherwise decrease the counter and no change to the majority element.</li> </ul> </li> <li>at the end return the <code>majority</code> variable. It may be or may not be the majority element (if it doesn't exists) then we need check if that is the majority element with just a single pass.</li> </ul>"},{"location":"arrays/array-problems/#example_1","title":"Example","text":"<p>Let's run the algorithm on an example to see how this is working </p>"},{"location":"arrays/array-problems/#running-the-algorithm-on-the-example","title":"Running the algorithm on the example","text":""},{"location":"arrays/array-problems/#iteration-1-to-4","title":"Iteration 1 to 4","text":""},{"location":"arrays/array-problems/#iteration-5-to-8","title":"Iteration 5 to 8","text":""},{"location":"arrays/array-problems/#iteration-9-and-10","title":"Iteration 9 and 10","text":"<p>At the very end the majority variable may or may not contains the majority element. We need check if that is the majority element with  a single pass on the array to count up the number of occurrences of the element indicated in majority variable.</p>"},{"location":"arrays/array-problems/#code_5","title":"Code","text":"<pre><code>class Solution {\npublic:\nint majorityElement(vector&lt;int&gt;&amp; nums) {\nint counter = 0;\nint majority = 0;\nfor (int i:nums) {\nif (counter == 0) {\nmajority = i;\ncounter += 1;\n} else {\nif (i == majority) {\ncounter++;\n} else {\ncounter--;\n}\n}\n}\nreturn majority; // we assume that the majority element always exists in the array\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#rotate-array","title":"Rotate Array","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_8","title":"Problem Statement","text":"<p>Given an array, rotate the array to the right by k steps, where k is non-negative in constant space and linear time.</p>"},{"location":"arrays/array-problems/#examples_2","title":"Examples","text":"<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</code></pre> <pre><code>Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</code></pre>"},{"location":"arrays/array-problems/#several-approaches-with-c-code","title":"Several approaches with C++ code","text":"<p>Not so much of an optimized approach, will fetch you a TLE. But for understanding it is a great apporach. We convert the <code>k</code> rotation problem into a subproblem of <code>rotationOnce()</code> for k times. We implement the <code>rotationOnce()</code> subroutine like this:</p> <ul> <li>See the last element, store it in <code>last</code> variable.</li> <li>then for element of index starting from \\(\\text{last} - 2\\) down to \\(0\\) swap it with the next element, to shift it by one,</li> <li>at last swap the first element (\\(0^{th}\\) index element with the <code>last</code> variable).</li> <li>This is how you rotate by one element.</li> <li>Do this K times to solve the problem. Total time complexity is \\(O(kn)\\), so we'll get TLE in the compiler. This is a polynomial in \\(n\\) and \\(k\\). But \\(k\\) can be \\(2^n\\) so overall this is not efficient. We can reduce the number of subroutine calls down to \\(k \\text{mod} n\\) but if \\(n\\) is large enough and \\(k\\) is almost \\(n\\) then the problem of TLE again occurs.</li> </ul> <p>Here is a code using this approach <pre><code>class Solution {\nprivate:\nvoid rotateOnce(vector&lt;int&gt;&amp; nums) {\nint last = nums.back();\nint size = nums.size();\nfor (int i=size-2; i&gt;=0; i--) {\nnums[i+1] = nums[i];\n}\nnums[0] = last;\n}\npublic:\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\nint rotations = k % nums.size();\nwhile(rotations) {\nrotateOnce(nums);\nrotations--;\n}\n}\n};\n</code></pre></p> <p>The code here will not run in a reasonable amount of time for a sufficiently large input size. So we have to design some better algorithms.</p>"},{"location":"arrays/array-problems/#using-extra-space-a-faster-algorithm-in-linear-time","title":"Using Extra space (a faster algorithm in linear time)","text":"<p>Instead of using the rotate once subroutine we can store all the last k elements in some temporary array, then instead of shifting one element once to the right and putting the last element to the front we can</p> <ul> <li>push those elements k step ahead</li> <li>put last k elements to the front of the array.</li> </ul> <p>This way the time complexity becomes linear time in \\(O(n + k)\\). This does not give TLE. But this takes \\(O(k)\\) extra space.</p> <pre><code>class Solution {\npublic:\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\nk = k % nums.size();\nint size = nums.size();\nvector&lt;int&gt; temp(nums.end()-k, nums.end());\n// for all the elements starting from\n// size - k - 1 down to 0 write it k space ahead\nfor (int i=size-k-1; i&gt;=0; i--) {\nnums[i + k] = nums[i];\n}\nint start = 0;\nfor (auto t:temp) {\nnums[start] = t;\nstart++;\n}\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#without-extra-space-and-linear-time-complexity-in-n","title":"Without extra space and linear time complexity in \\(n\\)","text":"<p>There is a very ingenious solution to the problem. I'll explain this with diagrams and will give you an working C++ code.</p>"},{"location":"arrays/array-problems/#approach_6","title":"Approach","text":"<p>The approach to get the solution goes like this:</p> <ul> <li>inplace reverse the array from last to \\(k\\),</li> <li>then inplace reverse the array from start to <code>size - k</code></li> <li>now reverse the whole array.</li> </ul>"},{"location":"arrays/array-problems/#dry-run-on-some-example","title":"Dry run on some example","text":"<p>Example array Dry run on that example </p>"},{"location":"arrays/array-problems/#code_6","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvoid inplace_reverse(vector&lt;int&gt;&amp; nums, int start, int end) {\nwhile (start &lt; end) {\nint temp = nums[start];\nnums[start] = nums[end];\nnums[end] = temp;\nstart++;\nend--;\n}\n}\npublic:\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\nk = k % nums.size();\nint size = nums.size();\ninplace_reverse(nums, size-k, size-1);\ninplace_reverse(nums, 0, size-k-1);\ninplace_reverse(nums, 0, size-1);\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#how-many-numbers-are-smaller-than-the-current-number","title":"How Many Numbers Are Smaller Than the Current Number","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_9","title":"Problem Statement","text":"<p>Given the array nums, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j</code>'s such that <code>j != i</code> and <code>nums[j] &lt; nums[i]</code>.</p> <p>Return the answer in an array.</p>"},{"location":"arrays/array-problems/#approach_7","title":"Approach","text":"<p>The most straight forward approach is to implement this by sorting and binary searching the lower bound for each element in the array. First we sort the array. The amount of element that is lower than each element in the array is actually equal to the lowerbound on the sorted array.</p> <p>Using a non comparison based sorting algorithm we can reduce the time complexity even further down to \\(O(n)\\).</p>"},{"location":"arrays/array-problems/#code_7","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint lower_bound(vector&lt;int&gt; &amp;nums, int target) {\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt; end) {\nif (nums[middle] == target) end = middle;\nif (nums[middle] &lt; target) start = middle + 1;\nif (nums[middle] &gt; target) end = middle - 1;\nmiddle = start + (end - start) / 2;\n}\nreturn start;\n}\npublic:\nvector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {\nvector&lt;int&gt; v(nums.begin(), nums.end());\nvector&lt;int&gt; answers;\nsort(v.begin(), v.end());\nfor (int i:nums) {\nint lb = lower_bound(v, i);\nanswers.push_back(lb);\n}\nreturn answers;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#sort-array-by-parity","title":"Sort Array By Parity","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_10","title":"Problem Statement","text":"<p>Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.</p>"},{"location":"arrays/array-problems/#approach_8","title":"Approach","text":"<p>We'll use the in-place gathering algorithm to gather all the even numbers at the begining of the array. The in-place gathering algorithm is explained in the following video. It's a super useful gathering algorithm that gathers elements of an array based on some condition. In the video I have explained two different scenarios where this gathering algorithm can be used.</p>"},{"location":"arrays/array-problems/#code_8","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; nums) {\nint even = 0;\n// gathering all the even integers\nfor (int i=0; i&lt;nums.size(); i++) {\nif (nums[i] % 2 == 0) {\nint temp = nums[i];\nnums[i] = nums[even];\nnums[even] = temp;\neven++;\n}\n}\nreturn nums;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#replace-elements-with-greatest-element-on-right-side","title":"Replace Elements with Greatest Element on Right Side","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_11","title":"Problem Statement","text":"<p>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.</p> <p>After doing so, return the array.</p>"},{"location":"arrays/array-problems/#example_2","title":"Example","text":"<pre><code>Input: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]\nExplanation: \n- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).\n- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).\n- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).\n- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).\n- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).\n- index 5 --&gt; there are no elements to the right of index 5, so we put -1.\n</code></pre>"},{"location":"arrays/array-problems/#approach_9","title":"Approach","text":"<ul> <li>One approach is to for each element find the maximum element from that element to the last of the aray, obviously this will take \\(O(n^2)\\) time which is not optimal.     <pre><code>class Solution {\npublic:\nvector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\nvector&lt;int&gt; answer;\nint _max = -1;\nfor (int i=0; i&lt;arr.size();i++) {\nif (_max == arr[i])\n_max = -1;\n// find the max from it's right\nfor (int j=i + 1; j&lt;arr.size(); j++) {\n_max = std::max(_max, arr[j]);\n}\nanswer.push_back(_max);\n}\nreturn answer;  }\n};\n</code></pre></li> <li>Instead we'll use an ingenious way, we'll travel from the last to the begining of the array, first we'll make the maximum element to the right as \\(-1\\), then we'll record the maximum element so far and go left to the beginning of the array.</li> <li>This will return the reverse of the intended result. At the end we'll reverese the elements in the array in-place.</li> </ul>"},{"location":"arrays/array-problems/#code_9","title":"Code","text":"<p>Extra space solution <pre><code>class Solution {\npublic:\nvector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\nvector&lt;int&gt; answer;\nint _max = -1;\nanswer.push_back(_max);\n_max = arr.back();\nfor (int i=arr.size() - 2; i&gt;=0; i--) {\nanswer.push_back(_max);\n_max = std::max(_max, arr[i]);\n}\nstd::reverse(answer.begin(), answer.end());\nreturn answer;\n}\n};\n</code></pre> BUT the problem says we should use an inplace solution. So it is a but difficult to come up with an inplace solution but here we go, feel free to analyze this solution step by step to feel how it is working?</p> <pre><code>class Solution {\npublic:\nvector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\nint _max = -1;\nint back = arr.back();\nfor (int i=arr.size()-1; i&gt;0; i--) {\n// update with the max we've seen so far\narr[i] = _max;\n// check if the current element is max or not?\n_max = std::max(back, _max);\n// as we're updating `a[i]` we should hold the value\n// in `back` variable and go left to the array\nback = arr[i - 1];\n}\narr[0] = _max;\nreturn arr;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#sort-colors","title":"Sort colors","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_12","title":"Problem Statement","text":"<p>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p> <p>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</p> <p>You must solve this problem without using the library's sort function.</p>"},{"location":"arrays/array-problems/#approach_10","title":"Approach","text":"<p>This problem is the prime example where we should be using the in-place grouping algorithm. Using that we first group zeros with condition elements being less than \\(1\\) to the left of the array and then group 2's with condition elements being greater than \\(1\\) to the right of the array. All the ones would be sandwitched between 0s and 2s.</p> <p>This is how the array becomes sorted without the usage of sorting function.</p>"},{"location":"arrays/array-problems/#code_10","title":"Code","text":"<pre><code>class Solution {\npublic:\nvoid sortColors(vector&lt;int&gt;&amp; nums) {\nint hinge = 1; // make hinge at 1 to group all &lt; 1 and &gt; 1 elements.\nint small = 0;\n// inplace grouping of zeros\nfor (int i=0; i&lt;nums.size(); i++) {\nif (nums[i] &lt; hinge) {\nint temp = nums[i];\nnums[i] = nums[small];\nnums[small] = temp;\nsmall++;\n}\n}\n// inplace grouping of all 2s\nint larger = nums.size() - 1;\nfor (int j=nums.size()-1; j&gt;=0; j--) {\nif (nums[j] &gt; hinge) {\nint temp = nums[j];\nnums[j] = nums[larger];\nnums[larger] = temp;\nlarger--;\n}\n}\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#set-matrix-zeros","title":"Set matrix zeros","text":""},{"location":"arrays/array-problems/#problem-statement_13","title":"Problem Statement","text":"<p>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.</p>"},{"location":"arrays/array-problems/#example_3","title":"Example","text":"<pre><code>Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n</code></pre>"},{"location":"arrays/array-problems/#approach_11","title":"Approach","text":"<ul> <li>Do stuffs</li> </ul>"},{"location":"arrays/array-problems/#code_11","title":"Code","text":"<pre><code>class Solution {\npublic:\nvoid setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n// setting 2 indicators\n// one for rows to be updated\n// one for columns to be updated\nvector&lt;int&gt; r;\nvector&lt;int&gt; c;\nfor (int i=0; i&lt;matrix.size(); i++) {\nfor (int j=0; j&lt;matrix[0].size(); j++) {\nif(matrix[i][j] == 0) {\nr.push_back(i);\nc.push_back(j);\n}\n}\n}\n// set zeros\nfor (auto row:r) {\nfor (int c=0; c&lt;matrix[row].size(); c++)\nmatrix[row][c] = 0;\n}\nfor (auto col:c) {\nfor (int r=0; r&lt;matrix.size(); r++)\nmatrix[r][col] = 0;\n}\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#leaders-in-an-array","title":"Leaders in an array","text":"<p>Problem on Coding Ninjas \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_14","title":"Problem Statement","text":"<p>Given a sequence of numbers. Find all leaders in sequence. An element is a leader if it is strictly greater than all the elements on its right side.</p>"},{"location":"arrays/array-problems/#example_4","title":"Example","text":"<pre><code>The given sequence is [13, 14, 3, 8, 2]\n\n13 Not a leader because on the right side 14 is greater than 13.\n14 lt is a leader because no one greater element in the right side.\n3 Not a leader because on the right side 8 are greater than 3.\n8 It is a leader because no one greater element on the right side.\n2 It is a leader because it is the rightmost element in a sequence.\nHence there are 3 leaders in the above sequence which are 14, 8, 2.\n</code></pre>"},{"location":"arrays/array-problems/#approach_12","title":"Approach","text":"<ul> <li>We'll traverse the array from right to left, set the max as the last element</li> <li>push the last element on the answer, then go forward</li> <li>if we find any element that is greater than the <code>current_max</code> means it is a leader because it is greater than anything we've seen from its right,</li> <li>else just go backward without doing anything.</li> <li>At last in-place reverse the vector to get the result.</li> </ul>"},{"location":"arrays/array-problems/#code_12","title":"Code","text":"<pre><code>void reverse_vector(vector&lt;int&gt;&amp;v) {\nint start = 0;\nint end = v.size() - 1;\nwhile (start &lt; end) {\nint temp = v[start];\nv[start] = v[end];\nv[end] = temp;\nstart++;\nend--;\n}\n}\nvector&lt;int&gt; findLeaders(vector&lt;int&gt; &amp;elements, int n) {\n// Write your code here.\nvector&lt;int&gt; leaders;\nint current_max = elements.back();\nleaders.push_back(current_max);\nfor (int i=elements.size() - 2; i &gt;= 0; i--) {\nif (elements[i] &gt; current_max) {\ncurrent_max = elements[i];\nleaders.push_back(elements[i]);\n}\n}\nreverse_vector(leaders);\nreturn leaders;\n}\n</code></pre>"},{"location":"arrays/array-problems/#time-and-memory-complexity","title":"Time and memory complexity","text":"<p>It takes total \\(O(N)\\) time and no extra space to run.</p>"},{"location":"arrays/array-problems/#count-the-number-of-inversions-in-an-array","title":"Count the number of inversions in an array","text":"<p>Find the problem on GeeksForGeeks \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_15","title":"Problem Statement","text":"<p>Given an array of integers. Find the Inversion Count in the array. </p> <p>Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum.</p> <p>Formally, two elements <code>a[i]</code> and <code>a[j]</code> form an inversion if <code>a[i] &gt; a[j]</code> and <code>i &lt; j</code>.</p>"},{"location":"arrays/array-problems/#examples_3","title":"Examples","text":"<pre><code>Input: N = 5, arr[] = {2, 4, 1, 3, 5}\nOutput: 3\nExplanation: The sequence 2, 4, 1, 3, 5 \nhas three inversions (2, 1), (4, 1), (4, 3).\n\nInput: N = 5\narr[] = {2, 3, 4, 5, 6}\nOutput: 0\nExplanation: As the sequence is already \nsorted so there is no inversion count.\n\nInput: N = 3, arr[] = {10, 10, 10}\nOutput: 0\nExplanation: As all the elements of array \nare same, so there is no inversion count.\n</code></pre>"},{"location":"arrays/array-problems/#constraints","title":"Constraints","text":"<ul> <li>Expected Time Complexity: \\(O(n \\log n)\\).</li> <li>Expected Auxiliary Space: \\(O(n)\\)</li> </ul>"},{"location":"arrays/array-problems/#brute-force-approach","title":"Brute force Approach","text":"<ul> <li>First we'll traverse from the end of the array to the first,</li> <li>for each element from \\(\\text{last} \\to \\text{first}\\) we'll check what is the number of elements that are greater than this element, these are the inversions.</li> <li>This will obviously take \\(O(n^2)\\) time complexity which will result in some TLE for larger testcases.</li> </ul>"},{"location":"arrays/array-problems/#code-for-this-approach","title":"Code for this approach","text":"<pre><code>class Solution{\npublic:\n// arr[]: Input Array\n// N : Size of the Array arr[]\n// Function to count inversions in the array.\nlong long int inversionCount(long long arr[], long long N) {\n// Your Code Here\nlong long int inversions = 0;\nlong long int start = 0;\nlong long int end = N - 1;\nwhile (end &gt; start) {\nfor (int t=end - 1; t&gt;=0; t--) {\nif (arr[t] &gt; arr[end]) {\ninversions++;\n}\n}\nend--;\n}\nreturn inversions;\n}\n};\n</code></pre> <p>Using this code passes 100 / 117 testcases in the gfg platform. So we need to optimize this further.</p>"},{"location":"arrays/array-problems/#a-more-optimized-approach","title":"A More optimized approach","text":"<p>The following is a more optimized solution to find the number of inversions in the array, which takes a but lesser time so that we don't get any TLEs.</p> <p>The number of inversions is a measure of how unsorted the array really is. So using some sorting properties we must derive at the number of inversions. It is also should be noted that in a sorted array the number of inversions is \\(0\\).</p> <p>We'll use merge sort to do this. During the merge sort we'll run some subroutine that'll calculate the number of inversions. This will take \\(O(n \\log n)\\) time which is faster than \\(O(n^2)\\). So understanding the merge sort is a critical component solving this problem.</p>"},{"location":"arrays/array-problems/#rotate-image","title":"Rotate Image","text":"<p>Problem On Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_16","title":"Problem Statement","text":"<p>You are given an \\(N \\times N\\) 2D matrix representing an image, rotate the image by \\(90\u00b0\\) degrees (clockwise).</p> <p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>"},{"location":"arrays/array-problems/#approach_13","title":"Approach","text":"<ul> <li>This is essentially equivalent to an in-place transpose of the matrix</li> <li>then inplace reversal of each row of the matrix.</li> </ul>"},{"location":"arrays/array-problems/#code_13","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvoid transposeSubroutine(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\nint end = matrix.size();\nfor (int i=0; i&lt;end; i++) {\nfor (int j = i; j&lt;end; j++) {\nint temp = matrix[i][j];\nmatrix[i][j] = matrix[j][i];\nmatrix[j][i] = temp;\n}\n}\n}\nvoid in_place_reversal(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int row) {\nint start = 0;\nint end = matrix[row].size() - 1;\nwhile(start &lt; end) {\nint temp = matrix[row][start];\nmatrix[row][start] = matrix[row][end];\nmatrix[row][end] = temp;\nstart++;\nend--;\n}\n}\npublic:\nvoid rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n// rotating by 90* is essentially\n// computing the transpose of the matrix\n// then reversing all the arrays\ntransposeSubroutine(matrix);\n// for each row do a inplace reversal\nfor (int i=0; i&lt;matrix.size(); i++) {\nin_place_reversal(matrix, i);\n}\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#product-of-array-except-self","title":"Product of Array Except Self","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_17","title":"Problem Statement","text":"<p>Given an integer array nums, return an array answer such that <code>answer[i]</code> is equal to the product of all the elements of nums except <code>nums[i]</code>.</p>"},{"location":"arrays/array-problems/#example_5","title":"Example","text":"<pre><code>Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n</code></pre>"},{"location":"arrays/array-problems/#approach-using-division-operator","title":"Approach using division operator","text":"<p>We can easily come up with a \\(O(n)\\) solution with \\(O(1)\\) memory complexity by just multiplying all the numbers of the array and divide them by the element at the current index. We should create provisions to handle Divide By Zero cases which you can see in the code below.</p>"},{"location":"arrays/array-problems/#code-using-division-operation","title":"Code using division operation","text":"<pre><code>class Solution {\nprivate:\nint findProductExceptIndex(vector&lt;int&gt;&amp; nums, int index) {\nint product = 1;\nfor (int i=0; i&lt;nums.size(); i++) {\nif (i != index) {\nproduct *= nums[i];\n}\n}\nreturn product;\n}\npublic:\nvector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {\nvector&lt;int&gt; result;\nint prod = 1;\nint zero_count = 0;\nfor (int i=0; i&lt;nums.size(); i++) {\n// to check if all are zero\nif (nums[i] == 0) zero_count++;\n// find the product of all\nprod *= nums[i];\n}\nif (zero_count == nums.size()) {\n// if all are zero\n// directly return so no other computation is done\nvector&lt;int&gt; v(zero_count, 0);\nreturn v;\n}\nfor (int j=0; j&lt;nums.size(); j++) {\nif (prod == 0) {\nif (nums[j] == 0) {\n// if this element is zero\n// then find the product except self\n// brutally\nresult.push_back(findProductExceptIndex(nums, j));\n} else {\nresult.push_back(0);\n}\n} else {\nresult.push_back(prod / nums[j]);\n}\n}\nreturn result;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#code-for-without-the-division-approach","title":"Code for without the division approach","text":"<pre><code>class Solution {\nprivate:\nvoid reverse_vector(vector&lt;int&gt;&amp; nums) {\nint start = 0;\nint end = nums.size() - 1;\nwhile (start &lt; end) {\nint temp = nums[start];\nnums[start] = nums[end];\nnums[end] = temp;\nstart++;\nend--;\n}\n}\nvoid prefixProd(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp;prefix) {\nint prod = 1;\nprefix.push_back(1);\nfor (auto i:nums) {\nprefix.push_back(prod*i);\nprod = prefix.back();\n}\n}\nvoid postfixProd(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp;postfix) {\nint prod = 1;\nfor (int i=nums.size() - 1; i&gt;=0; i--) {\npostfix.push_back(prod*nums[i]);\nprod = postfix.back();\n}\n// reverse subroutine at the end to get the actual answer\nreverse_vector(postfix);\npostfix.push_back(1);\n}\npublic:\nvector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {\nvector&lt;int&gt; productExceptSelfOrder;\nvector&lt;int&gt; prefix;\nvector&lt;int&gt; postfix;\n// build prefix and postfix products\nprefixProd(nums, prefix);\npostfixProd(nums, postfix);\n// now that we have both the prefix products and postfix products\n// it'll be easy to find the productExceptSelfOrder\nfor (int i=0; i&lt;postfix.size() - 1; i++) {\nint preprod = prefix[i];\nint postprod = postfix[i+1];\nproductExceptSelfOrder.push_back(preprod * postprod);\n}\nreturn productExceptSelfOrder;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#a-better-in-place-solution-most-optimized","title":"A Better in-place solution (most optimized)","text":"<pre><code>class Solution {\npublic:\nvector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {\nvector&lt;int&gt; answer;\nint prod = 1;\nanswer.push_back(1);\nfor (int i=0; i&lt;nums.size(); i++) {\nanswer.push_back(prod * nums[i]);\nprod = answer.back();\n}\nanswer.pop_back();\n// our answer now holds all the prefix\n// now instead of creating a new postfix array\n// just do the postfix in place\nprod = 1;\nfor (int j=nums.size() - 1; j &gt;=1; j--) {\nprod*= nums[j];\nanswer[j - 1] *= prod;\n}\nreturn answer;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#two-sum-ii-input-array-is-sorted","title":"Two Sum II Input Array Is Sorted","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_18","title":"Problem Statement","text":"<p>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code> where \\(1 \\le\\) <code>index1</code> &lt; <code>index2</code> \\(\\leq\\) <code>numbers.length</code>.</p> <p>Return the indices of the two numbers, <code>index1</code> and <code>index2</code>, added by one as an integer array <code>[index1, index2]</code> of length 2.</p> <p>The tests are generated such that there is exactly one solution. You may not use the same element twice.</p> <p>The solution must use only constant extra space.</p>"},{"location":"arrays/array-problems/#approach_14","title":"Approach","text":"<ul> <li>Our approach will use a two pointer solution. We'll put a pointer <code>start</code> at 0 and <code>end</code> at the end of the array.</li> <li>Next we'll see if <code>sum &lt; target</code>, we must try to add some element greater than the <code>array[start]</code> so that our sum reaches target. As the array is already sorted in non-decreasing order we'll move start by 1 to increment the sum upto target,</li> <li>If <code>sum &gt; target</code> means we overshoot the sum, so to reduce the sum down to target we'll decrement <code>end</code> by 1.</li> </ul>"},{"location":"arrays/array-problems/#code_14","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {\nint start = 0;\nint end = numbers.size() - 1;\nint sum = numbers[start] + numbers[end];\nif (sum == target) {\nvector&lt;int&gt; v = {start + 1, end + 1};\nreturn v;\n}\nwhile (sum != target and start &lt; end) {\nif (sum == target) break;\nif (sum &lt; target) {\nstart++;\n}\nif (sum &gt; target) {\nend--;\n}\nsum = numbers[start] + numbers[end];\n}\nvector&lt;int&gt; v = {start+1, end+1};\nreturn v;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#container-with-most-water","title":"Container With Most Water","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_19","title":"Problem Statement","text":"<p>You are given an integer array height of length \\(n\\). There are n vertical lines drawn such that the two endpoints of the ith line are <code>(i, 0)</code> and (<code>i</code>, <code>height[i]</code>).</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return the maximum amount of water a container can store.</p> <p>Notice that you may not slant the container.</p>"},{"location":"arrays/array-problems/#example_6","title":"Example","text":"<p> <pre><code>Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].\nIn this case, the max area of water (blue section) the container can contain is 49.\n</code></pre></p>"},{"location":"arrays/array-problems/#approach_15","title":"Approach","text":"<ul> <li>[will be added soon]</li> </ul>"},{"location":"arrays/array-problems/#code_15","title":"Code","text":"<pre><code>class Solution {\npublic:\nint maxArea(vector&lt;int&gt;&amp; height) {\nint start = 0;\nint end = height.size() - 1;\nint water = 0;\nwhile (start &lt; end) {\nint h = std::min(height[start], height[end]);\nwater = std::max(h * (end - start), water);\nwhile(start &lt; end and height[start] &lt;= h) start++;\nwhile(start &lt; end and height[end] &lt;= h) end--;\n}\nreturn water;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#rain-water-trapping","title":"Rain water trapping","text":"<p>Same Problem on Leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_20","title":"Problem Statement","text":"<p>Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\), compute how much water it can trap after raining.</p>"},{"location":"arrays/array-problems/#example_7","title":"Example","text":"<pre><code>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</code></pre>"},{"location":"arrays/array-problems/#explainer","title":"Explainer","text":"Rain Water Trapping Explainer"},{"location":"arrays/array-problems/#approach_16","title":"Approach","text":"<ul> <li>For each building figure out how much water can be trapped on top of its roof.</li> <li>For all buildings add the water trapped on top of its roof.</li> <li>Return the total.</li> <li>To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building.</li> </ul> Rain Water Trapping Approach Explainer"},{"location":"arrays/array-problems/#solution","title":"Solution","text":"<ul> <li>For each building find the maximum height on both left and right sides,</li> <li>then take the minimum of those heights \\(\\to\\) that should be the water height at that location.</li> <li>Subtract the height of the building from it to get how much water is stored on top of the building.</li> <li>For each building add up all the water stored on top of the roof.</li> <li>Return the sum as the total water stored in the system.</li> </ul>"},{"location":"arrays/array-problems/#code_16","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvoid _reverse(vector&lt;int&gt; &amp;v) {\nint start = 0;\nint end = v.size() - 1;\nwhile (start &lt; end) {\nint temp = v[start];\nv[start] = v[end];\nv[end] = temp;\nstart++;\nend--;\n}\n}\npublic:\nint trap(vector&lt;int&gt;&amp; height) {\n// for each index find the maximum boundary to the left\nvector&lt;int&gt; left;\nint currentMaxToLeft = 0;\nfor (auto i:height) {\nif (i &gt; currentMaxToLeft) {\nleft.push_back(currentMaxToLeft);\ncurrentMaxToLeft = i;\n} else {\nleft.push_back(currentMaxToLeft);\n}\n}\n// for each index find the maximum boundary to the right\nvector&lt;int&gt; right;\nint currentMaxToRight = 0;\nfor (int i=height.size() - 1; i&gt;=0; i--) {\nif (height[i] &gt; currentMaxToRight) {\nright.push_back(currentMaxToRight);\ncurrentMaxToRight = height[i];\n} else {\nright.push_back(currentMaxToRight);\n}\n}\n_reverse(right); // reverse to sortout the order\n// based on the left max and right max we find the minimum among this two\n// (lower bound), then find the water on top of the building.\nint water = 0;\nfor (int i=0; i&lt;height.size() - 1; i++) {\n// limiting height = min of left max and right max\nint limiter = std::min(left[i], right[i]);\nint waterOnTheBuilding = limiter - height[i];\nif (waterOnTheBuilding &gt; 0) water += waterOnTheBuilding;\n}\nreturn water;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#two-sum-iv","title":"Two Sum IV","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_21","title":"Problem Statement","text":"<p>Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>"},{"location":"arrays/array-problems/#example_8","title":"Example","text":"<pre><code>Input: root = [5,3,6,2,4,null,7], k = 9\nOutput: true\n</code></pre>"},{"location":"arrays/array-problems/#approach_17","title":"Approach","text":"<ul> <li>We've previously solved the problem Two sum II where the input is sorted.</li> <li>Using 2 pointer approach we easily solved the problem, similar to that here if we do an inorder traversal we'll also get a sorted array,</li> <li>So the approach works like that, we first traverse in-order then use a 2 pointer approach to solve the 2 sum problem.</li> </ul>"},{"location":"arrays/array-problems/#code_17","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nvector&lt;int&gt; inOrder;\nvoid build(TreeNode* root) {\nif (root) {\nbuild(root-&gt;left);\ninOrder.push_back(root-&gt;val);\nbuild(root-&gt;right);\n}\n}\npublic:\nbool findTarget(TreeNode* root, int k) {\nbuild(root);\n// now 2 Sum II on the sorted list inOrder\nint start = 0;\nint end = inOrder.size() - 1;\nint sum = inOrder[start] + inOrder[end];\nwhile (start &lt; end) {\nif (sum &lt; k) {\nstart++;\n} else if (sum &gt; k) {\nend--;\n} else if (sum == k) {\nreturn true;\n}\nsum = inOrder[start] + inOrder[end];\n}\nreturn false;\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#valid-sudoku","title":"Valid Sudoku","text":""},{"location":"arrays/array-problems/#problem-statement_22","title":"Problem Statement","text":"<p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p> <ul> <li>Each row must contain the digits 1-9 without repetition.</li> <li>Each column must contain the digits 1-9 without repetition.</li> <li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li> </ul> <p>Note A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</p>"},{"location":"arrays/array-problems/#approach_18","title":"Approach","text":"<ul> <li>We'll have three subroutine first will find whether all the rows are filled with different digits,</li> <li>second will find whether all the columns are filled with different digits,</li> <li>Third will find out for each of the \\(3*3\\) grid if all the elements are unique.<ul> <li>First 2 cases are trivially solvable by traversing the board horizontally and vertically.</li> <li>The main challenge comes when we need to check for individual \\(3*3\\) grids. To do that I find what is the mid point for each of the \\(3*3\\) grids. These are \\(\\{(1,1), (1,4), (1,7), \\dots\\}\\) with 0 based indexing. Sitting at the mid point I do a little detour via the <code>detour</code> function to cover the whole \\(3*3\\) grid and check for the uniqueness of the values.</li> </ul> </li> <li>At the end our solution to the problem becomes true if it is <code>columnCorrect</code> and <code>rowCorrect</code> and <code>gridCorrect</code>. Hence the following code:</li> </ul>"},{"location":"arrays/array-problems/#code_18","title":"Code","text":"<pre><code>class Solution {\nprivate:\nunordered_map&lt;char, bool&gt; getTraveller() {\nunordered_map&lt;char, bool&gt; traveller;\nfor (int i=1; i&lt;=9; i++) {\nchar c = i + '0';\ntraveller[c] = false;\n}\nreturn traveller;\n}\nbool columnCorrect(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\nfor (int i=0; i&lt;9; i++) {\nunordered_map&lt;char, bool&gt; traveller = getTraveller();\nfor (int j=0; j&lt;9; j++) {\nif (board[j][i] != '.') {\nif (traveller[board[j][i]]) {\nreturn false;\n} else {\ntraveller[board[j][i]] = true;\n}\n}\n}\n}\nreturn true;\n}\nbool rowCorrect(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n// for each of the row create a traveller\n// mark if some thing is not visited from 1-9\n// else if already visited return false\nfor (int i=0; i&lt;9; i++) {\nunordered_map&lt;char, bool&gt; traveller = getTraveller();\nfor (int j=0; j&lt;9; j++) {\nif (board[i][j] != '.') {\nif (not traveller[board[i][j]]) {\ntraveller[board[i][j]] = true;\n} else {\nreturn false;\n}\n}\n}\n}\nreturn true;\n}\npair&lt;int, int&gt; getMidFromGridIndex(int gridIndex) {\n// all the grids are indexed 0-8. For a given grid number\n// this returns the mid point of the grid\nint row = (gridIndex/3)* 3 + 1;\nint col = (gridIndex % 3) * 3 + 1;\nreturn {row, col};\n}\nvoid detour(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, int limit, unordered_map&lt;char, bool&gt; &amp;traveller, bool &amp;possible) {\n/* Recursive detour and check for the 3*3 grid as this [row-col] begin middle*/\nif (limit &gt; 1) return;\nchar valueHere = board[row][col];\nif (traveller[valueHere] and valueHere != '.') {\npossible = false;\nreturn;\n}\ntraveller[valueHere] = true;\ndetour(board, row+1, col, limit+1, traveller, possible);\ndetour(board, row, col-1, limit+1, traveller, possible);\ndetour(board, row, col+1, limit+1, traveller, possible);\ndetour(board, row-1, col, limit+1, traveller, possible);\ndetour(board, row+1, col+1, limit+1, traveller, possible);\ndetour(board, row+1, col-1, limit+1, traveller, possible);\ndetour(board, row-1, col-1, limit+1, traveller, possible);\ndetour(board, row-1, col+1, limit+1, traveller, possible);\n}\nbool gridCorrect(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n// there is total of 9 grids, we need to check all of the grids\nfor (int gridID=0; gridID&lt;9; gridID++) {\npair&lt;int, int&gt; midPoint = getMidFromGridIndex(gridID);\n// create a new traveller\nunordered_map&lt;char, bool&gt; traveller = getTraveller();\nbool possible = true;\ndetour(board, midPoint.first, midPoint.second, 0, traveller, possible);\n// if not possible then return false other wise go to the next grid\nif (not possible) return false;\n}\nreturn true;\n}\npublic:\nbool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\nreturn columnCorrect(board) and rowCorrect(board) and gridCorrect(board);\n}\n};\n</code></pre>"},{"location":"arrays/array-problems/#sort-the-array","title":"Sort the Array","text":"<p>Find the problem on Codeforces \\(\\to\\)</p>"},{"location":"arrays/array-problems/#problem-statement_23","title":"Problem Statement","text":"<p>Being a programmer, you like arrays a lot. For your birthday, your friends have given you an array a consisting of \\(n\\) distinct integers.</p> <p>Unfortunately, the size of a is too small. You want a bigger array! Your friends agree to give you a bigger array, but only if you are able to answer the following question correctly: is it possible to sort the array \\(a\\) (in increasing order) by reversing exactly one segment of \\(a\\)? See definitions of segment and reversing in the notes.</p> <p>Input The first line of the input contains an integer \\(n (1\u2009\\leq\u2009n\u2009\\leq\u200910^5)\\) \u2014 the size of array \\(a\\).</p> <p>The second line contains n distinct space-separated integers: \\(a[1],\u2009a[2],\u2009...,\u2009a[n] (1\u2009\\leq\u2009a[i]\u2009\\leq\u200910^9)\\).</p> <p>Output Print \"yes\" or \"no\" (without quotes), depending on the answer.</p> <p>If your answer is \"yes\", then also print two space-separated integers denoting start and end (start must not be greater than end) indices of the segment to be reversed. If there are multiple ways of selecting these indices, print any of them.</p>"},{"location":"arrays/array-problems/#examples_4","title":"Examples","text":"<pre><code>Input:\n3\n3 2 1\n\nOutput:\nyes\n1 3\n\nExplain: You can reverse the entire array to get [1,\u20092,\u20093], which is sorted.\n</code></pre>"},{"location":"arrays/array-problems/#approach_19","title":"Approach","text":"<ul> <li>Find one decreasing-increasing segment. Then check if first element of decreasing segment is less than first element of the increasing segment. Then it is possible to reverse the decreasing segment and get the sorted order.</li> <li>If there is more than one increasing and decreasing segment, then it is not possible.</li> <li>Otherwise it is possible to reverse the decreasing segment and get the sorted order.</li> </ul>"},{"location":"arrays/array-problems/#code_19","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint findFirstDecrementPoint(vector&lt;int&gt; &amp;numbers) {\nfor (int i = 0; i &lt; numbers.size() - 1; i++) {\nif (numbers[i] &gt; numbers[i + 1]) {\nreturn i;\n}\n}\nreturn -1;\n}\nbool moreThanOneIncrementDecrementSegment(int firstIncrementPoint, vector&lt;int&gt; &amp;numbers) {\nfor (int i = firstIncrementPoint + 1; i &lt; numbers.size() - 1; i++) {\nif (numbers[i] &gt; numbers[i + 1]) {\nreturn true;\n}\n}\nreturn false;\n}\npair&lt;pair&lt;int, int&gt;, string&gt; findIfSortingPossible(vector&lt;int&gt; &amp;numbers) {\nint firstDecrementPoint = findFirstDecrementPoint(numbers);\nif (firstDecrementPoint == -1) {\nreturn {{1, 1}, \"yes\"};\n}\n// from this firstDecrement point find what is the first increment point\nint firstIncrementPoint = -1;\nfor (int i = firstDecrementPoint; i &lt; numbers.size() - 1; i++) {\nif (numbers[i] &lt; numbers[i + 1]) {\n// this is the first increment point\nfirstIncrementPoint = i;\nbreak;\n}\n}\nif (firstIncrementPoint == -1) {\n// all are decreasing, there is no increment point later\n// so check if last number is &gt; the number at decrement point;\nif (firstDecrementPoint == 0) {\n// this means the entire array is reversing\nreturn {{1, numbers.size()}, \"yes\"};\n} else if (numbers.back() &gt; numbers[firstDecrementPoint - 1]) {\n// this means here reversing decrement segment is possible\nreturn {{firstDecrementPoint + 1, numbers.size()}, \"yes\"};\n}\n} else {\nif (moreThanOneIncrementDecrementSegment(firstIncrementPoint, numbers)) {\nreturn {{0, 0}, \"no\"};\n}\nif (numbers[firstIncrementPoint + 1] &gt; numbers[firstDecrementPoint]) {\nreturn {{firstDecrementPoint + 1, firstIncrementPoint + 1}, \"yes\"};\n}\n}\nreturn {{0, 0}, \"no\"};\n}\nint main() {\nint size;\ncin &gt;&gt; size;\nvector&lt;int&gt; numbers(size);\nfor (int i = 0; i &lt; size; i++) {\ncin &gt;&gt; numbers[i];\n}\npair&lt;pair&lt;int, int&gt;, string&gt; answer = findIfSortingPossible(numbers);\ncout &lt;&lt; answer.second &lt;&lt; endl;\nif (answer.first.first)\ncout &lt;&lt; answer.first.first &lt;&lt; \" \" &lt;&lt; answer.first.second &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"arrays/array-problems/#greatest-common-divisor-of-strings","title":"Greatest Common Divisor of Strings","text":"<p>Find the problem on Leetcode \\(\\to\\)</p> <p>For two strings <code>s</code> and <code>t</code>, we say \"<code>t</code> divides s<code>\" if and only if</code>s = t + ... + t<code>(i.e.,</code>t` is concatenated with itself one or more times).</p> <p>Given two strings <code>str1</code> and <code>str2</code>, return the largest string <code>x</code> such that <code>x</code> divides both <code>str1</code> and <code>str2</code>.</p>"},{"location":"arrays/array-problems/#example_9","title":"Example","text":"<pre><code>Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"\n\nInput: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"\n\nInput: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"\n</code></pre>"},{"location":"arrays/array-problems/#approach_20","title":"Approach","text":"<ul> <li>Find all the prefix of the shorter string,</li> <li>Then for each of the prefixes find if that is both a valid divisor of <code>str1</code> and <code>str2</code>. Find the greatest common divisor using loops.</li> </ul>"},{"location":"arrays/array-problems/#code_20","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;string&gt; findPrefixes(string str) {\nstring pref = \"\";\nint size = str.size();\nvector&lt;string&gt; prefixes;\nfor (int i = 0; i &lt; size; i++) {\npref += str[i];\nprefixes.push_back(pref);\n}\nreturn prefixes;\n}\nbool validDivisor(string str, string prefix) {\nbool valid = true;\nint size = prefix.size();\nint index = 0;\nfor (char c:str) {\nif (c == prefix[index]) {\nindex++;\nindex %= size;\n} else {\nvalid = false;\nbreak;\n}\n}\nif (index &gt; 0) valid = false;\nreturn valid;\n}\nstring gcdOfStrings(string str1, string str2) {\nint size1 = str1.size();\nint size2 = str2.size();\nstring currentCommonDivisor = \"\";\nif (size1 &lt; size2) {\nvector&lt;string&gt; prefixList = findPrefixes(str1);\nfor (auto prefix:prefixList) {\nbool validForString2 = validDivisor(str2, prefix);\nbool validForString1 = validDivisor(str1, prefix);\nif (validForString1 and validForString2) {\ncurrentCommonDivisor = prefix;\n}\n}\n} else {\nvector&lt;string&gt; prefixList = findPrefixes(str1);\nfor (auto prefix:prefixList) {\nbool validForString2 = validDivisor(str2, prefix);\nbool validForString1 = validDivisor(str1, prefix);\nif (validForString1 and validForString2) {\ncurrentCommonDivisor = prefix;\n}\n}\n}\nreturn currentCommonDivisor;\n}\n};\n</code></pre>"},{"location":"arrays/arrays/","title":"Arrays","text":"<p>Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some <code>[x:y:z]</code> slice of the array.</p>","tags":["introduction","Python"]},{"location":"arrays/arrays/#example-problem","title":"Example problem","text":"","tags":["introduction","Python"]},{"location":"arrays/arrays/#problem-statement","title":"Problem Statement","text":"<p>Problems</p> <p>Your input is an array of integers, and you have to reorder its entries so that the even entries appear first.</p>","tags":["introduction","Python"]},{"location":"arrays/arrays/#solution","title":"Solution","text":"<p>We can solve the problem with \\(O(N)\\) space trivially. But to solve the problem with constant space we have to reuse space inside the given array.</p> <p></p>","tags":["introduction","Python"]},{"location":"arrays/arrays/#algorithm","title":"Algorithm","text":"<ul> <li>Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from \\(0 \\to (N-1)\\) to \\(0 \\to (N-2)\\)</li> <li>If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from \\(0 \\to(N-1)\\) to \\(1 \\to (N-1)\\)</li> <li>Repeat until pointers pointing start of the array crosses pointers pointing end of the array.</li> </ul>","tags":["introduction","Python"]},{"location":"arrays/arrays/#python-code-python-39-and-above","title":"Python Code [Python 3.9 and above]","text":"<pre><code>def even_odd_separation(array: list[int]):\nstart: int, end: int = 0, len(array) - 1\n# Don't stop until start crosses end\nwhile start &lt; end:\nif array[start] % 2 == 0:\n# The number at the start is even, so reduce the space to 1 ... n - 1\nstart += 1\nelse:\n# Number infront of the array is odd\narray[start], array[end] = array[end], array[start]\nend -= 1\n</code></pre>","tags":["introduction","Python"]},{"location":"arrays/arrays/#time-and-space-complexity","title":"Time and space complexity","text":"<p>The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\).</p> <p>Note</p> <ul> <li>Test PASSED (1001/1001): (7 ms)</li> <li>Avarage running time: (22 us)</li> <li>Median running time: (7 us)</li> </ul>","tags":["introduction","Python"]},{"location":"arrays/arrays/#things-to-remember-before-solving-array-questions","title":"Things to remember before solving Array Questions","text":"<p>GENERIC RECOMMENDATIONS</p> <ul> <li>Array problems often have simple brute force solutions that use \\(O(n)\\) space, but there are subtler solutions that use the array itself to reduce space complexity to \\(O(1)\\),</li> <li>Filling an array from the front is slow, so see if it's possible to write values from the back, with <code>append()</code> in python and <code>push_back()</code> in C++ method,</li> <li>Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case \\(O(N)\\), beacuse all the elements to the right have to swapped one step left,</li> </ul> <p>PYTHON SPECIFIC RECOMMENDATIONS</p> <ul> <li><code>A.reverse()</code> is inplace reversal of array,</li> <li><code>reversed(A)</code> returns an iterator,</li> <li><code>del A[i]</code> removes the i th element,</li> <li><code>A[::-1]</code> reverses the array,</li> <li>Try using more of the list comprehension methods.</li> </ul>","tags":["introduction","Python"]},{"location":"arrays/arrays/#one-toy-problem","title":"One toy problem","text":"<p>Note</p> <p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>","tags":["introduction","Python"]},{"location":"arrays/arrays/#examples","title":"Examples","text":"<pre><code>Input: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n</code></pre>","tags":["introduction","Python"]},{"location":"arrays/arrays/#solution_1","title":"Solution","text":"","tags":["introduction","Python"]},{"location":"arrays/arrays/#approach","title":"Approach","text":"<p>Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element.</p>","tags":["introduction","Python"]},{"location":"arrays/arrays/#code","title":"Code","text":"<pre><code>def missingNumber(self, nums: List[int]) -&gt; int:\nmax_number: int = len(nums)\npossible_sum: int = (max_number * (max_number + 1)) / 2\nactual_sum: int = 0\nindex: int = 0\nwhile index != len(nums):\nactual_sum += nums[index]\nindex += 1\nreturn int(possible_sum - actual_sum)\n</code></pre>","tags":["introduction","Python"]},{"location":"arrays/sliding-window/","title":"Sliding Windows Problem Introduction","text":"<ul> <li>Linked list or arrays find something among all contigious sub array of some given size.</li> </ul>"},{"location":"arrays/sliding-window/#inverted-sliding-window-microsoft-oa","title":"Inverted Sliding Window [Microsoft OA]","text":""},{"location":"arrays/sliding-window/#problem-statement","title":"Problem Statement","text":"<p>Suppose \\(A[n]\\) is an array of integers. Identify a \\(r\\) length window such that \\(A[i] \\mid \\forall \\: i \\in [n] \\text{ except for } \\left[k, k+r \\right)\\) for some \\(k \\in [n - r]\\) has most number of unique elements.</p>"},{"location":"arrays/sliding-window/#approach","title":"Approach","text":"<ul> <li>In first step we calculate the unique elements outside the first window (from \\(0 \\to r - 1\\)),</li> <li>Next we slide the window to \\((1 \\to r)\\). In this case the unique element map will add the \\(0^{\\text{th}}\\) element and remove the \\(r^{\\text{th}}\\) element (think of it as the inverted sliding window). We are sliding a window but we are interested outside the window.</li> <li>Following is an illustration as to how this window works. Notice the elements outside the bucket rather than the inside. Which is incoming and which is outgoing.</li> </ul>"},{"location":"arrays/sliding-window/#code","title":"Code","text":"<pre><code>#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint main() {\nint testcase;\ncin &gt;&gt; testcase;\nwhile (testcase--) {\nint n, r;\ncin &gt;&gt; n &gt;&gt; r;\nif (n == r) {\ncout &lt;&lt; \"0\" &lt;&lt; endl;\nbreak;\n}\nint a[n];\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; a[i];\n}\nunordered_map&lt;int, int&gt; freq;\nint maximumUniqueWindow = INT_MIN;\n// outside first window\nint index = 0;\nwhile (index &lt; n) {\nif (not(index &lt; r and index &gt;= 0)) {\nfreq[a[index]]++;\n}\nindex++;\n}\nmaximumUniqueWindow = std::max(maximumUniqueWindow, (int)freq.size());\n// for rest of the outside windows\nint window_start = 1;\nint window_end = r;\nint maxWindowStart = 0;\nint maxWindowEnd = r - 1;\nwhile (window_end &lt; n) {\n// outgoing + incoming from the outside window\nint outgoing = a[window_end];\nint incoming = a[window_start - 1];\nfreq[outgoing]--;\nif (not freq[outgoing]) {\nfreq.erase(outgoing);\n}\nfreq[incoming]++;\nint currentsize = freq.size();\nif (currentsize &gt;= maximumUniqueWindow) {\nmaximumUniqueWindow = currentsize;\nmaxWindowStart = window_start;\nmaxWindowEnd = window_end;\n}\nwindow_start++;\nwindow_end++;\n}\ncout &lt;&lt; maximumUniqueWindow &lt;&lt; endl;\n}\n}\n</code></pre>"},{"location":"arrays/sliding-window/#other-problems","title":"Other problems","text":"<p><code>Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it.</code></p> <p>For a given array:\u00a0\\([1,\u00a03,\u00a02,\u00a06,\u00a0-1,\u00a04,\u00a01,\u00a08,\u00a02]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array.</p> <ol> <li>For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\)</li> <li>The average of next 5 numbers (subarray from index 1-5) is:\u00a0\\((3+2+6-1+4)/5 = 2.8\\)</li> <li>For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on.</li> </ol> <p>Here is the final output containing the averages of all contiguous subarrays of size 5: <code>Output:\u00a0[2.2,\u00a02.8,\u00a02.4,\u00a03.6,\u00a02.8]</code></p>"},{"location":"arrays/sliding-window/#brute-force-apprach","title":"Brute force apprach","text":"<p>A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average.</p> <pre><code>def brute_force(array: list[int], K:int) -&gt; list[int]:\n# Keep track of the avgs\navgs: list[int] = []\n# Start from 0 and go to the next 5 elements and find the average\nfor i in range(0, len(array)- K+1):\nsum: int = 0\nfor j in range(i, i+K):\nsum += array[j]\navg: float = sum / K\navgs.append(avg)\nreturn avgs\n</code></pre> <p><pre><code>mainarray: list[int] = [1, 3, 2, 6, -1, 4, 1, 8, 2]\nK: int = 5  # find max of this size for given array\na: list[int] = brute_force(mainarray, K)\nfrom rich.console import Console  # For printing purposes\nconsole = Console()\nconsole.print(a)\n</code></pre> Output <pre><code>[2.2, 2.8, 2.4, 3.6, 2.8]\n</code></pre></p>"},{"location":"arrays/sliding-window/#problems-with-this-apporach","title":"Problems with this apporach","text":"<ul> <li>Time complexity is huge \\(O(N * K)\\).</li> <li>We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements.</li> </ul> <p>This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program.</p> <pre><code>def optimized(array: list[int], K: int) -&gt; list[int]:\nif K &gt; len(array):\nraise IndexError(\"Error Bro\")\n# Keep track of all the averages\navgs: list[int] = []\n# Start from 0 and go to the next K elements and find the average\nsumtillK: int = 0\nfor i in range(0, K):\nsumtillK += array[i]\navgs.append(sumtillK / K)\n# If the size of the array is the size of the window then just return\nif K == len(array):\nreturn avgs\n# From K+1 to Last element for each sliding window add the last\n# element and subtract the first element\n# Leave the first element and then start from 2nd elemenet\n# and slide smoothly\nfor i in range(1, len(array) - K + 1):\nsumtillK = sumtillK - array[i - 1] + array[i + K - 1]\navgs.append(sumtillK / K)\nreturn avgs\n</code></pre>"},{"location":"arrays/sliding-window/#optimized-approach-with-while-loop","title":"Optimized approach with while loop","text":"<pre><code>def optimized_while(array: list[int], K: int) -&gt; list[int]:\navgs: list[int] = []\nif K &gt; len(array):\nraise IndexError(\"Error Bro\")\nsumtillk: int = 0\nfor i in range(0, K):\nsumtillk += array[i]\navgs.append(sumtillk / K)\n# Leave the first element and then start from 2nd elemenet\n# and slide smoothly\nindex: int = 1\nwhile index != (len(array) - K + 1):\nsumtillk = sumtillk - array[index - 1] + array[index + K - 1]\navgs.append(sumtillk / K)\nindex += 1\nreturn avgs\n</code></pre> <pre><code>b: list[int] = optimized(mainarray, K)\nc: list[int] = optimized_while(mainarray, K)\nconsole.print(b)\nconsole.print(c)\n</code></pre> <p>Output</p> <pre><code>[2.2, 2.8, 2.4, 3.6, 2.8]\n[2.2, 2.8, 2.4, 3.6, 2.8]\n</code></pre>"},{"location":"arrays/sliding-window/#maximum-sum-subarray-of-size-k","title":"Maximum Sum subarray of size K","text":""},{"location":"arrays/sliding-window/#problem-statement_1","title":"Problem Statement","text":"<p>Given an array of positive numbers and a positive number \u2018k\u2019, find the\u00a0maximum sum of any contiguous subarray of size \u2018k\u2019.</p>"},{"location":"arrays/sliding-window/#examples","title":"Examples","text":"<pre><code>Input: [2, 1, 5, 1, 3, 2], k=3 \nOutput: 9\nExplanation: Subarray with maximum sum is [5, 1, 3].\n\n---\n\nInput: [2, 3, 4, 1, 5], k=2 \nOutput: 7\nExplanation: Subarray with maximum sum is [3, 4].\n</code></pre>"},{"location":"arrays/sliding-window/#approach-naive-on-back-of-the-envelope-approach","title":"Approach [Naive on back of the envelope approach]","text":"<pre><code>def mss(array: list[int], k:int) -&gt; int:\nmaximum: int = 0\nsumtillK: int = 0\nfor i in range(0, k):\nsumtillK += array[i]\nmaximum = sumtillK\nidx: int = 1\nwhile idx != len(array) - k:\nsumtillK = sumtillK - array[idx-1] + array[idx + k -1]\nmaximum = max(maximum, sumtillK)\nidx += 1\nreturn maximum\n</code></pre> <pre><code>mainarray: list[int] = [2, 1, 5, 1, 3, 2]\nK: int = 3  # find max of this size for given array\na2: list[int] = [2, 3, 4, 1, 5]\nk2 = 2\n</code></pre> <pre><code>a: int = mss(mainarray, K)\nprint(a) # -&gt; 9\n</code></pre> <pre><code>b: int = mss(a2, k2)\nprint(b) # -&gt; 7\n</code></pre>"},{"location":"arrays/sliding-window/#time-complexity","title":"Time complexity","text":"<p>Only one pass of the array so the time complexity is \\(O(N)\\)</p>"},{"location":"arrays/sliding-window/#smallest-subarray-with-a-given-sum","title":"Smallest subarray with a given sum","text":""},{"location":"arrays/sliding-window/#problem-statement_2","title":"Problem statement","text":"<p>Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the\u00a0smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists.</p>"},{"location":"arrays/sliding-window/#examples_1","title":"Examples","text":"<pre><code>Input: [2, 1, 5, 2, 3, 2], S=7 \nOutput: 2\nExplanation: The smallest subarray with a sum great than or equal to '7' is [5, 2].\n\n---\n\nInput: [2, 1, 5, 2, 8], S=7 \nOutput: 1\nExplanation: The smallest subarray with a sum greater than or equal to '7' is [8].\n\n---\nInput: [3, 4, 1, 1, 6], S=8 \nOutput: 3\nExplanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6].\n</code></pre>"},{"location":"arrays/sliding-window/#brute-force-approach","title":"Brute force approach","text":"<p>Key takeway approach</p> <p>\ud83d\udca1 For each size of window find out if the sum is greater or equal to the target?</p> <p></p> <pre><code>testcase1: list[int] = [2, 1, 5, 2, 3, 2]\ntestcase1s: int = 7\ntestcase2: list[int] = [3, 4, 1, 1, 6]\ntestcase2s: int = 8\ntestcase3: list[int] = [2, 1, 5, 2, 8]\ntestcase3s: int = 7\n</code></pre> <pre><code># Brute force approach\ndef ssgs(array: list[int], s: int) -&gt; int:\ndef subroutine(array: list[int], ws: int, target: int):\nif ws == 1:\nfor entires in array:\nif entires &gt;= target:\nreturn 1\nsummation: int = 0\nfor i in range(0, ws):\nsummation += array[i]\nif summation &gt;= target:\nreturn ws\nindex = 1\nwhile index &lt; len(array) - ws:\nsummation = summation - array[index - 1] + array[index + ws - 1]\nif summation &gt;= target:\nreturn ws\nindex += 1\nreturn -1\nwindow_size: int = 1\nsubroutine_return: int = -1\nwhile window_size &lt; len(array) and subroutine_return == -1:\nsubroutine_return = subroutine(array, window_size, s)\nwindow_size += 1\nreturn subroutine_return\n</code></pre> <pre><code>from rich.console import Console\nconsole = Console()\n</code></pre> <p><pre><code>console.print(ssgs(testcase1, testcase1s), \nssgs(testcase2, testcase2s), \nssgs(testcase3, testcase3s), \nssgs([1, 2, 10, 3, 4, 5, 6, 7, 8], 17))\n</code></pre> Output <pre><code>2 3 1 3\n</code></pre></p>"},{"location":"arrays/sliding-window/#time-complexity_1","title":"Time complexity","text":"<p>\\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\)</p>"},{"location":"arrays/sliding-window/#better-optimized-approach","title":"Better Optimized approach","text":"<ul> <li>First we add up the elements of the array from start until we get the sum at least the target</li> <li>This is the first window size from the array that at least sums upto the target, so we remember the length</li> <li>We will remember the length of the window if we find a smaller window than this that sums at least the target.</li> </ul> <p>Coming soon</p> <p>Room for more understanding</p> <p>...</p>"},{"location":"arrays/sliding-window/#longest-substring-with-k-distinct-characters","title":"Longest Substring with K Distinct Characters","text":""},{"location":"arrays/sliding-window/#problem-statement_3","title":"Problem statement","text":"<p>Given a string, find the length of the longest substring in it with no more than K distinct characters.</p> <pre><code>Input: String=\"araaci\", K=2\nOutput: 4\nExplanation: The longest substring with no more than '2' distinct characters is \"araa\".\n</code></pre>"},{"location":"arrays/subarray/","title":"Breaking Arrays into subarrays meeting some condition","text":"<ul> <li>Codeforces Contest 882 Div 2, Problem A</li> </ul> <p>Few example problems</p> <ul> <li>Codeforces Contest 882 Div 2, Problem A</li> <li>Codeforces Contest 882 Div 2, Problem B</li> </ul>"},{"location":"arrays/subarray/#codeforces-contest-882-div-2-problem-a","title":"Codeforces Contest 882 Div 2, Problem A","text":""},{"location":"arrays/subarray/#problem-statement","title":"Problem Statement","text":"<p>In Codeforces Contest 882 Div 2, Problem A they are asking to break the array into continuous parts such that sum of power for all segment is minimised. Suppose \\(A\\) is the array then find a sequence \\((a_i) \\mid \\forall i \\in [n], a_i = A[i]\\) such that \\(\\sum_{i \\in (a_i)} f(a_{i-1}, a_i)\\) is minimised. Here \\((a_{i-1}, a_i)\\) is subsequence of the array \\(A\\).</p>"},{"location":"arrays/subarray/#approach","title":"Approach","text":"<ul> <li>Power of a sub sequence of villagers from \\(a[l \\dots r]\\) is defined as \\(abs(a[l] - a[l + 1]) + abs(a[l+1] - a[l + 2]) + ... + abs(a[r-1] - a[r])\\)</li> <li>Our task is to break the villagers into exactly \\(k\\) contiguous subgroups so that the sum of their power for each of the group is minimized and single member groups are worth \\(0\\) power.</li> <li>Simple Observation is that if we break the continiousness of a group at some location \\(i\\) then the sum of all the powers reduces by \\(abs(a[i - 1] - a[i])\\). Hence we must find the biggest such drop and break the members there.</li> <li>At the end return the total sum.</li> </ul>"},{"location":"arrays/subarray/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint main() {\n// ith guy has a[i] sus on Kars.\n// a sub sequence of villagers from a[l ... r] is defined as\n// abs(a[l] - a[l + 1]) + abs(a[l+1] - a[l + 2]) + ... + abs(a[r-1] - a[r]) is the power of a group\n// task break the villagers into exactly k\n// contiguous subgroups so that the sum of their power for each of the group is minimized.\n// single member groups are worth 0 power.\nint testcases;\ncin &gt;&gt; testcases;\nwhile (testcases--) {\nint n, k;\ncin &gt;&gt; n &gt;&gt; k;\nint a[n];\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; a[i];\n}\n// solution for each of the testcases\n// first consider the entire array as a group\nint maxcost = 0;\npair&lt;int, int&gt; diff[n]; // difference array stores all n-1 a[i-1] - a[i] computations\ndiff[0] = {0, 0};\nfor (int i = 1; i &lt; n; i++) {\nint cost = abs(a[i] - a[i - 1]);\nmaxcost += cost;\ndiff[i] = {cost, i - 1};\n}\n// now sort the diff array based on decreasing differences\nstd::sort(diff, diff + n, [](const auto &amp;a, const auto &amp;b) {\nreturn a.first &gt; b.first;\n});\nfor (int i = 0; i &lt; k-1; i++) {\nmaxcost -= diff[i].first;\n}\ncout &lt;&lt; maxcost &lt;&lt; endl;\n}\nreturn 0;\n}\n</code></pre>"},{"location":"binary-search/intro/","title":"Binary Search Introductions","text":"<p>Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\)</p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#toy-problem-to-start-find-ceil","title":"Toy problem to start: Find Ceil","text":"","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#problem-statement","title":"Problem Statement","text":"<p>Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only.</p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#example","title":"Example","text":"<pre><code>Given Array: [2, 3, 4, 5, 6, 7, 8, 10]\nTarget: 7.9\nReturn: 8\n\nTarget: 8.2\nReturn 10\n</code></pre>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#approach","title":"Approach","text":"<ul> <li>This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number.</li> <li>If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at <code>end &lt; start</code>. So the start pointer will be pointing to the next biggest number.</li> </ul> <pre><code>int ceil (vector&lt;int&gt; &amp;v, int target) {\nint start = 0;\nint end = v.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (v[middle] &lt; target) {\nstart = middle + 1;\n} else if (v[middle] &gt; target) {\nend = middle - 1;\n} else {\nreturn v[middle];\n}\n}\n// If the element is not found, then the while loop's start and end pointer crosses\n// each other and the start pointer points to the smallest element larger than the\n// target element.\nreturn v[start];\n}\n</code></pre> <pre><code>def ceil(array: list[int], target: int) -&gt; int:\n# Run the actual binary search algorithm and return the element if found\nstart: int = 0\nend: int = len(array) - 1\nwhile start &lt;= end:\nmiddle: int = int((start + end) / 2)\nif array[middle] &lt; target:\nstart = middle+1\nelif array[middle] &gt; target:\nend = middle-1\nelse:\nreturn array[middle]\n# If the element is not found, then the while loop's start and end pointer crosses\n# each other and the start pointer points to the smallest element larger than the\n# target element.\nreturn array[start]\n</code></pre> <p>Test Cases</p> <ol> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 9\\)</li> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 6.25\\)</li> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 6.7\\)</li> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 6.1\\)</li> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 3.27\\)</li> <li>\\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\), \\(\\text{target} = 3\\)</li> </ol> <p><pre><code>print(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=9), \"Actual should be 10\")\nprint(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.25), \"Actual should be 6.6\")\nprint(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.7), \"Actual should be 6.7\")\nprint(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.1), \"Actual should be 6.6\")\nprint(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3.27), \"Actual should be 5\")\nprint(\"Answer is:\",ceil([2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3), \"Actual should be 3\")\n</code></pre> <pre><code>Answer is: 10 Actual should be 10\nAnswer is: 6.6 Actual should be 6.6\nAnswer is: 6.7 Actual should be 6.7\nAnswer is: 6.6 Actual should be 6.6\nAnswer is: 5 Actual should be 5\nAnswer is: 3 Actual should be 3\n</code></pre></p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#find-out-the-nth-root-of-a-given-element","title":"Find out the Nth Root of a given element.","text":"","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#problem-statement_1","title":"Problem Statement","text":"<p>For a given N and a number K, find \\(\\sqrt[N]{K}\\).</p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#approach_1","title":"Approach","text":"<ul> <li>It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\).</li> <li>Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\).</li> <li>Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\)</li> </ul> <pre><code>from typing import Union\nTHRESHOLD = 1e-6\ndef get_N_power(value: int, root: int):\nanswer: int = 1\nwhile root &gt; 0:\nanswer *= value\nroot -= 1\nreturn answer\ndef find_n_th_root(number: int, root: int) -&gt; Union[int, float]:\n# The nth root lies between the 1, and the number\nstart: int = 1\nend: int = number\nwhile (end - start) &gt; THRESHOLD:\nmiddle: float = (start + end) / 2.0\nif get_N_power(middle, root) &gt; number:\nend = middle\nelif get_N_power(middle, root) &lt; number:\nstart = middle\nelse:\nreturn middle\nreturn start, end\n</code></pre> <pre><code>find_n_th_root(1024, 2)    # -&gt;  (31.999999971129, 32.000000923871994)\n</code></pre> <pre><code>import math\nmath.sqrt(1024) # Successfully verified -&gt; 32.0\n</code></pre> <p><pre><code># Some more test cases\nprint(\"Our Function call returns in range:\", find_n_th_root(1024, 2), \"Original Values\", math.sqrt(1024))\nprint(\"Our Function call returns in range:\", find_n_th_root(256, 4), \"Original Values\", math.sqrt(math.sqrt(256)))\nprint(\"Our Function call returns in range:\", find_n_th_root(128, 2), \"Original Values\", math.sqrt(128))\nprint(\"Our Function call returns in range:\", find_n_th_root(3, 2), \"Original Values\", math.sqrt(3))\nprint(\"Our Function call returns in range:\", find_n_th_root(81, 3))\n</code></pre> <pre><code>Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0\nOur Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0\nOur Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761\nOur Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772\nOur Function call returns in range: (4.326748609542847, 4.326749205589294)\n</code></pre></p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#median-of-row-wise-sorted-matrix","title":"Median of Row Wise Sorted Matrix","text":"","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#problem-statement_2","title":"Problem Statement","text":"<p>We are given a row-wise sorted matrix of size \\(r*c\\), we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd.</p>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#example_1","title":"Example","text":"<pre><code>Input : 1 3 5\n        2 6 9\n        3 6 9\nOutput : Median is 5\nIf we put all the values in a sorted \narray A[] = 1 2 3 3 5 6 6 9 9)\n\nInput: 1 3 4\n       2 5 6\n       7 8 9\nOutput: Median is 5\n</code></pre>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#constraints","title":"Constraints","text":"<ul> <li>Each entry in the array is from \\(1 \\to 10^9\\)</li> <li>R and C are always odd.</li> </ul>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#apporach","title":"Apporach","text":"","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#naive-approach","title":"Naive Approach","text":"<ul> <li>Iterate over all the elements, and then sort them,</li> <li>then return the middle element.</li> </ul>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#time-complexity-for-this-naive-apporach","title":"Time Complexity for this naive apporach","text":"<ul> <li>\\(O(NM)\\) for the traversal,</li> <li>\\(O(NM \\log MN)\\) for Sorting and,</li> <li>Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\).</li> </ul>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(NM)\\) Extra space is required.</li> </ul>","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/intro/#more-optimized-apporach","title":"More optimized apporach","text":"","tags":["Medium","Binary Search","One day to complete"]},{"location":"binary-search/problems-codeforces/","title":"Binary Search Codeforces Problems","text":"<p>This section includes problems from Codeforces (Mostly Div. 2). All the problems are selected from Striver's CP Sheet.</p> <p>Problems</p> <ul> <li>Hamburgers</li> <li>Magic Powder 1 \\&amp; 2</li> <li>Poisoned Dagger</li> <li>Pipeline</li> </ul>"},{"location":"binary-search/problems-codeforces/#hamburgers","title":"Hamburgers","text":""},{"location":"binary-search/problems-codeforces/#problem-statement-revised","title":"Problem Statement (Revised)","text":"<p>Find the original problem statement in the codeforces website.</p> <ul> <li>To make hamburgers we need a bread, sausage and cheese. We write down the recipe of \"Le Hamburger de Polycarpus\" as a string of letters 'B' (bread), 'S' (sausage) and 'C' (cheese).</li> <li>The ingredients in the recipe go from bottom to top, for example, recipe \"\u0412SCBS\" represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.</li> <li>We have \\(n_b, n_s, n_c\\) many bread-sausage-cheese in the kitchen.</li> <li>We also have access to bread-sausage-cheese in a nearby shop with price tag \\(p_b, p_s, p_c\\).</li> <li>We have total of \u20b9\\(r\\). With \\(n_b, n_s, n_c\\) many bread-sausage-cheese and \u20b9\\(r\\) how many Hamburger we can make using a given recipe.</li> </ul>"},{"location":"binary-search/problems-codeforces/#approach","title":"Approach","text":"<ul> <li>We do a binary search on the <code>numberOfBurgers</code>. We stop when we find the highest <code>numberOfBurgers</code> feasable to build. This pattern is called binary search on answer.</li> </ul>"},{"location":"binary-search/problems-codeforces/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool isFeasableWithNumberOfBurgers(long long int numberOfBurgers,\nlong long int recipeRatio[],\nlong long int kitchen[],\nlong long int price[],\nlong long int rupees) {\n// bread cost is either the extra Bread Needed or 0 if enough in the kitchen\nlong long int breadCost = price[0] * max(numberOfBurgers * recipeRatio[0] - kitchen[0], (long long int)0);\nlong long int sausageCost = price[1] * max(numberOfBurgers * recipeRatio[1] - kitchen[1], (long long int)0);\nlong long int cheeseCost = price[2] * max(numberOfBurgers * recipeRatio[2] - kitchen[2], (long long int)0);\nlong long int totalcost = breadCost + sausageCost + cheeseCost;\nif (rupees &lt; totalcost) {\nreturn false;\n}\nreturn true;\n}\nint main() {\nstring recipe;\ncin &gt;&gt; recipe;\nlong long int recipeRatio[3] = {0, 0, 0};\nfor (char ingredient : recipe) {\nif (ingredient == 'B') recipeRatio[0]++;\nif (ingredient == 'S') recipeRatio[1]++;\nif (ingredient == 'C') recipeRatio[2]++;\n}\nlong long int kitchen[3];\ncin &gt;&gt; kitchen[0] &gt;&gt; kitchen[1] &gt;&gt; kitchen[2];\nlong long int price[3];\ncin &gt;&gt; price[0] &gt;&gt; price[1] &gt;&gt; price[2];\nlong long int rupees;\ncin &gt;&gt; rupees;\n// binary search on answer\nlong long int maxBurgerPossible = rupees + 1000;\nlong long int start = 0;\nlong long int end = maxBurgerPossible;\nwhile (start &lt;= end) {\nlong long int mid = start + (end - start) / 2;\nbool possible = isFeasableWithNumberOfBurgers(mid, recipeRatio, kitchen, price, rupees);\nif (possible) {\nstart = mid + 1;\n} else {\nend = mid - 1;\n}\n}\ncout &lt;&lt; end &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"binary-search/problems-codeforces/#magic-powder-1-2","title":"Magic Powder 1 &amp; 2","text":"<p>Find the problem on codeforces</p>"},{"location":"binary-search/problems-codeforces/#problem-statement","title":"Problem Statement","text":"<p>Solving problem 670/problem/D2 also solves 670/problem/D1 as D1 is with smaller constraints.</p> <ul> <li>We have \\(n\\) ingredients that are needed in the following ratio \\(a[i] \\: \\forall i \\in [n]\\). \\(a[i]\\) grams of \\(i^{\\text{th}}\\) ingredient is needed to make the cookie.</li> <li>Our kitchen has \\(b[i] \\: \\forall i \\in [n]\\) grams of the \\(i^{\\text{th}}\\) element.</li> <li>We also have access to \\(k\\) grams of magic powder that can be used for any element that we are short of.</li> <li>Find the maximum cookie can be made.</li> </ul>"},{"location":"binary-search/problems-codeforces/#approach_1","title":"Approach","text":"<p>Similar to the last problem we find what is the highest amount of cookie that can be made via a binary search on the number of cookies via this <code>checkIfPossibleToMakeNumberOfCookies()</code> function.</p>"},{"location":"binary-search/problems-codeforces/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool checkIfPossibleToMakeNumberOfCookies(unsigned long long int numberOfCookies,\nunsigned long long int numberOfIngredients,\nunsigned long long int demand[],\nunsigned long long int kitchen[],\nunsigned long long int magicPowder) {\nunsigned long long int totalDeficiency = 0;\nfor (unsigned long long int i = 0; i &lt; numberOfIngredients; i++) {\nif (numberOfCookies * demand[i] &gt; kitchen[i]) {\ntotalDeficiency += numberOfCookies * demand[i] - kitchen[i];\n}\n}\nif (totalDeficiency &gt; magicPowder) return false;\nreturn true;\n}\nint main() {\nunsigned long long int ingredients, magicPowder;\ncin &gt;&gt; ingredients &gt;&gt; magicPowder;\nunsigned long long int demand[ingredients];  // demand\nunsigned long long int kitchen[ingredients]; // kitchen\nfor (unsigned long long int i = 0; i &lt; ingredients; i++) {\ncin &gt;&gt; demand[i];\n}\nfor (unsigned long long int i = 0; i &lt; ingredients; i++) {\ncin &gt;&gt; kitchen[i];\n}\nunsigned long long int start = 1;\nunsigned long long int end = 1e12;\nwhile (start &lt;= end) {\nunsigned long long int mid = start + (end - start) / 2;\nbool possible = checkIfPossibleToMakeNumberOfCookies(\nmid, ingredients,\ndemand, kitchen, magicPowder\n);\nif (possible) {\nstart = mid + 1;\n} else {\nend = mid - 1;\n}\n}\ncout &lt;&lt; end &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"binary-search/problems-codeforces/#poisoned-dagger","title":"Poisoned Dagger","text":""},{"location":"binary-search/problems-codeforces/#problem-statement_1","title":"Problem Statement","text":"<ul> <li>In a game there is a monster. Game is for \\(100^{500}\\) second long. In this game, his character has to kill a dragon. </li> <li>Player attacks the dragon with a poisoned dagger. The \\(i^{\\text{th}}\\) attack is performed at the beginning of the \\(a[i]\\) second from the battle start.</li> <li>The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals \\(1\\) damage during each of the next \\(k\\) seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).</li> </ul> <p>For example, suppose \\(k = 4\\), and Monocarp stabs the dragon during the seconds \\(2, 4\\) and \\(10\\). Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the \\(2^{\\text{nd}}\\) and \\(3^{\\text{rd}}\\) seconds; then, at the beginning of the \\(4^{\\text{th}}\\) second, the poison effect is reapplied, so it deals exactly \\(1\\) damage during the seconds \\(4, 5, 6\\) and \\(7\\); then, during the \\(10^{\\text{th}}\\) second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.</p> <p>Find the minimum possible value of \\(k\\) (the number of seconds the poison effect lasts) that is enough to deal at least \\(h\\) damage to the dragon.</p>"},{"location":"binary-search/problems-codeforces/#approach_2","title":"Approach","text":"<ul> <li>Standard Binary Search on Answer.</li> <li>To check feasability we write <code>findFeasability</code> method. In there we do a merge interval subroutine for the attack window, then count the total damage done during the entire time. </li> </ul>"},{"location":"binary-search/problems-codeforces/#code_2","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool findFeasability(unsigned long long int k,\nunsigned long long int n,\nunsigned long long int intervals[],\nunsigned long long int h) {\n// merge intervals\nvector&lt;vector&lt;unsigned long long int&gt;&gt; startEndIntervals(n);\nfor (int i = 0; i &lt; n; i++) {\nstartEndIntervals[i] = {intervals[i], intervals[i] + k - 1};\n}\nvector&lt;vector&lt;unsigned long long int&gt;&gt; mergedIntervals;\nint i = 0;\nunsigned long long int last = startEndIntervals.size() - 1;\nwhile (i &lt; last) {\nif (startEndIntervals[i][1] &gt;= startEndIntervals[i + 1][0]) {\n// means there is an overlap\nstartEndIntervals[i + 1][0] = startEndIntervals[i][0];                                        // minimum starting time\nstartEndIntervals[i + 1][1] = std::max(startEndIntervals[i][1], startEndIntervals[i + 1][1]); // maximum\n} else {\nmergedIntervals.push_back(startEndIntervals[i]);\n}\ni++;\n}\nmergedIntervals.push_back(startEndIntervals[i]); // add the last interval\n// count total damage from the mergedIntervals list\nunsigned long long int totalDamage = 0;\nfor (auto intervalPair : mergedIntervals) {\ntotalDamage += intervalPair[1] - intervalPair[0] + 1;\n}\nreturn totalDamage &gt;= h;\n}\nint main() {\nint testcases;\ncin &gt;&gt; testcases;\nwhile (testcases--) {\nunsigned long long int n, h;\ncin &gt;&gt; n &gt;&gt; h;\nunsigned long long int a[n];\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; a[i];\n}\nunsigned long long int start = 1;\nunsigned long long int end = 1e19;\nwhile (start &lt;= end) {\nunsigned long long int mid = start + (end - start) / 2;\nbool feasable = findFeasability(mid, n, a, h);\nif (feasable) {\nend = mid - 1;\n} else {\nstart = mid + 1;\n}\n}\ncout &lt;&lt; start &lt;&lt; endl;\n}\nreturn 0;\n}\n</code></pre>"},{"location":"binary-search/problems-codeforces/#pipeline","title":"Pipeline","text":""},{"location":"binary-search/problems-codeforces/#problem-statement_2","title":"Problem Statement","text":"<ul> <li>We have \\(n\\) houses.</li> <li>We have \\(2 \\dots k\\) many \\(1 \\to i\\) way splitters.</li> <li>We need to find minimum \\(j \\in \\{2 \\dots k\\}\\) such that we have \\(\\geq n\\) many pipeline output.</li> </ul>"},{"location":"binary-search/problems-codeforces/#approach_3","title":"Approach","text":"<ul> <li>We need to do a binary search on answer.</li> <li>For feasability condition we do the following<ul> <li>Use \\(k-1 \\to j\\) many splitters for \\(j\\) many spitters.</li> <li>Total output of such usage of splitters is \\(\\binom{k}{2} - \\binom{j}{2}\\).</li> <li>Find if \\(\\binom{k}{2} - \\binom{j}{2} \\geq n\\).</li> </ul> </li> </ul>"},{"location":"binary-search/problems-codeforces/#code_3","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main () {\nunsigned long long int n, k;\ncin &gt;&gt; n &gt;&gt; k;\nif (n == 1) {\ncout &lt;&lt; 0 &lt;&lt; endl;\nreturn 0;\n}\nif (n &lt;= k) {\ncout &lt;&lt; 1 &lt;&lt; endl;\nreturn 0;\n}\nunsigned long long int start = 2;\nunsigned long long int end = k + 2;\nunsigned long long int maximumSplittedPipes = k*(k + 1) / 2 - k;\nlong long int minimumSplitters = -1;\nwhile (start &lt;= end) {\nunsigned long long int mid = start + (end - start) / 2;\n// use from mid -&gt; k many splitters\nunsigned long long int currentTotalSplit = maximumSplittedPipes - ((mid * (mid - 1) / 2) - mid);\nif (currentTotalSplit &gt;= n) {\nminimumSplitters = k - mid + 1;\nstart = mid + 1;\n} else {\nend = mid - 1;\n}\n}\ncout &lt;&lt; minimumSplitters &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"binary-search/problems/","title":"Binary Search problems","text":"<p>Binary search problems are really useful because they run in sublinear time. We'll be solving the following problems in order to master this</p> <p>Questions discussed</p> <ol> <li>Binary Search implementation in C++</li> <li>Binary Search on Reverse Sorted Array</li> <li>Order agnostic search</li> <li>First and Last occurrence of an Element</li> <li>Count of an Element in a Sorted Array</li> <li>Number of Times a Sorted array is Rotated</li> <li>Find an Element in a Rotated Sorted Array</li> <li>Search Insert Position</li> <li>Single Element in a Sorted Array</li> <li>Minimum Difference Element in a Sorted Array</li> <li>Search in a sorted 2D matrix</li> <li>Search in a sorted matrix but not <code>inter-row-wise</code> sorted</li> <li>Search for Range</li> <li>Koko Eating Bananas</li> <li>Time Based Key-Value Store</li> <li>Next alphabetical element</li> <li>Find position of an element in an Infinite Sorted Array</li> <li>Index of First 1 in a Binary Sorted Infinite Array</li> <li>Binary Search on Answer Concept</li> <li>Peak Element</li> <li>Find maximum element in Bitonic Array</li> <li>Search An Element in Bitonic Array</li> <li>Allocate minimum number of pages</li> </ol>"},{"location":"binary-search/problems/#binary-search-implementation-in-c","title":"Binary Search implementation in C++","text":"<p>Binary search is really easy to implement. Main goal is to divide the search space into 2 partitions (<code>bi</code>) and then based on the criteria search only in one partition.</p>"},{"location":"binary-search/problems/#expected-time-complexity","title":"Expected time complexity","text":"<p>Expected time complexity is \\(O(\\log N)\\) where N is the number of elements in the array.</p>"},{"location":"binary-search/problems/#code-implementation","title":"Code implementation","text":"<pre><code>// Return the index of the element in the array\n// using binary search\nint binary_search(std::vector&lt;int&gt; &amp;v, int target) {\nint start = 0;\nint end = v.size() - 1;\nint middle = (end + start) / 2;\nint index = -1; // return -1 if not found\nwhile (start &lt;= end) {\nif (v[middle] &lt; target) {\nstart = middle + 1;\n} else if (v[middle] &gt; target) {\nend = middle - 1;\n} else {\nreturn middle;\n}\nmiddle = (end + start) / 2;\n}\nreturn index;\n}\n</code></pre>"},{"location":"binary-search/problems/#binary-search-on-reverse-sorted-array","title":"Binary Search on Reverse Sorted Array","text":"<p>We've seen the binary search algorithm for a sorted array, but if the array is reverse sorted then we can easily modify the binary search algorithm here <code>else if (v[middle] &gt; target) { start = middle + 1; }</code> because the target element is lower and the array is reverse sorted so the required element should be at the end partition of the array.</p> <p>So a little modification of the binary search algorithm is sufficient to solve the problem.</p>"},{"location":"binary-search/problems/#order-agnostic-search","title":"Order agnostic search","text":"<p>If the array is sorted but we don't know the order of the elements whether it is ascending or descending? Then what we can do is the following</p>"},{"location":"binary-search/problems/#approach","title":"Approach","text":"<ul> <li>See if the array size is 1 or not then we return.</li> <li>If the array size is more than 1, then find if \\(\\text{A[0]} &gt; \\text{A[1]}\\) or not? If it is then the array is reverse sorted. If that is not the case then the array is sorted in ascending order.</li> <li>We run the previous or previous to previous algorithm accordingly.</li> </ul>"},{"location":"binary-search/problems/#first-and-last-occurrence-of-an-element","title":"First and Last occurrence of an Element","text":"<p>In a sorted array if we have more than one element we may want to know what is the first occurrence of some element (assuming they exists).</p>"},{"location":"binary-search/problems/#approach_1","title":"Approach","text":"<ul> <li>We can use linear search but there is no fun in that. Instead we use a binary search, but how we'll do this?</li> <li>Let's employ a binary search subroutine, now this will find any occurrence of the target element,</li> <li>Now if this is not the first occurrence of the target element we will need to search the left subsection of the array, and in case we didn't find any we record this occurence as the first occurrence of the target element so far,</li> <li>Now we search for the target element again in the left subsection of the array by modifying <code>end = middle - 1</code></li> </ul>"},{"location":"binary-search/problems/#code","title":"Code","text":"<pre><code>int firstOccurence(vector&lt;int&gt; &amp;v, int target){\nint start = 0;\nint end = v.size() - 1;\nint middle = start + (end - start) / 2;\nint first = -1;\nwhile (start &lt;= end) {\nif (v[middle] == target) {\n// modification to the general binary search\nfirst = middle;\nend = middle - 1;\n} else if (v[middle] &lt; target) {\nstart = middle + 1;\n} else {\nend = middle - 1;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn first;\n}\n</code></pre> <p>For finding the last occurence</p> <p>Similarly we can find the last occurence of an element in the sorted array by modifying the previous problem slightly, by first finding the element with binary search, then instead of finding the element in the left side [for first occurence] we search the right sub array for the last occurence of the element.</p> <pre><code>int lastOccurence(vector&lt;int&gt; &amp;v, int target){\nint start = 0;\nint end = v.size() - 1;\nint middle = start + (end - start) / 2;\nint last = -1;\nwhile (start &lt;= end) {\nif (v[middle] == target) {\n// modification to the general binary search\nlast = middle;\nstart = middle + 1; // look in the right subarray for the last occurrence\n} else if (v[middle] &lt; target) {\nstart = middle + 1;\n} else {\nend = middle - 1;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn last;\n}\n</code></pre>"},{"location":"binary-search/problems/#count-of-an-element-in-a-sorted-array","title":"Count of an Element in a Sorted Array","text":"<p>Similar problem on Leetcode \\(\\to\\)</p> <p>This is a very simple problem, we can find the first occurrence of an element [index] and last occurence of an element and subtract. This will return the number of times the element was found in the array.</p>"},{"location":"binary-search/problems/#expected-time-complexity_1","title":"Expected Time complexity","text":"<p>\\(O(\\text{lg} N)\\) for finding the first occurrence and \\(O(\\text{lg} N)\\) for finding the last occurrence. Total of \\(O(\\text{lg} N)\\).</p>"},{"location":"binary-search/problems/#number-of-times-a-sorted-array-is-rotated","title":"Number of Times a Sorted array is Rotated","text":""},{"location":"binary-search/problems/#problem-statement","title":"Problem Statement","text":"<p>An asending sorted array \\(A[0 \\to N]\\) once rotated becomes \\(A[1 \\to N] + A[0]\\). When it twice rotated becomes \\(A[2 \\to N] + A[0 \\to 1]\\).</p> <p>When the array is rotated \\(k\\) times, the array becomes \\(A[K \\to N] + A[0 \\to K - 1]\\)</p> <p></p>"},{"location":"binary-search/problems/#brute-force-approach","title":"Brute Force Approach","text":"<p>Using a linear search if we find for some \\(i\\) \\(A[i] &gt; A[i+1]\\), that \\(i\\) is the index of the rotation starting point. Subtract \\(i\\) from length of the array to find how much rotation took place. </p> <p>One more thing we can observe is that the \\((\\text{size - index of the minimum element})\\) is the # of rotations done on the sorted array. Both of these solution is \\(O(N)\\) so not efficient enough.</p>"},{"location":"binary-search/problems/#more-optimized-approach","title":"More optimized approach","text":"<p>We cannot afford to search for the minimum element in the entire array, this will cost \\(O(N)\\) time. However if we reduce the size of the search space we can reduce the time complexity of the algorithm.</p> <p>This apporach works like this:</p> <ol> <li>First check the middle \\(i\\), if the value is smaller than both the element to its side \\(i - 1\\) and \\(i + 1\\), then it is the point of the minimum element means this is the point of rotation.</li> <li>If this is not true then based on some idea we should reduce the size of the search space, otherwise its gonna be \\(O(N)\\)<ol> <li>We do this very ingenious way, first we check if the middle element is smaller than the first element or not? If this is the case then the minimum element is present in the left side of the middle element.</li> <li>Else the element should be present in the right side of the middle element.</li> </ol> </li> </ol>"},{"location":"binary-search/problems/#code_1","title":"Code","text":"<pre><code>class Solution {\npublic:\nint findMin(vector&lt;int&gt;&amp; nums) {\nint start = 0;\nint end = nums.size() - 1;\nint size = nums.size();\nint middle = start + (end - start) / 2;\nwhile (start &lt; end){\nif (nums[middle] &gt; nums[end]) {\nstart = middle + 1;\n} else {\nend = middle;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn size - start + 1;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#find-an-element-in-a-rotated-sorted-array","title":"Find an Element in a Rotated Sorted Array","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#approach_2","title":"Approach","text":"<ul> <li>If we look at the previous problem, we'll see that the (rotation point): let's call that the pivot, the subarray before pivot is sorted and subarray after pivot is sorted as well.</li> <li>If we run 2 binary search on each of the subarrays we'll find the target element in \\(O(\\text{lg} N)\\) time.</li> </ul>"},{"location":"binary-search/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint findRotationPoint(vector&lt;int&gt; &amp;nums) {\nint start = 0;\nint end = nums.size() - 1;\n// base cases:\nif (nums.size() &lt;= 1) return 0; // zero or one element array do not have rotations\nif (nums[start] &lt; nums[end]) return 0;  // no rotation at all\nint middle = start + (end - start) / 2;\nwhile (start &lt; end) {\nif (nums[middle] &gt; nums[end]) {\n// means rotation point is right of mid\nstart = middle + 1;\n} else {\nend = middle;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn start;\n}\nint binary_search(vector&lt;int&gt; &amp;nums, int start, int end, int target) {\nint mid = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (nums[mid] == target) return mid;\nif (nums[mid] &lt; target) start = mid + 1;\nif (nums[mid] &gt; target) end = mid - 1;\nmid = start + (end - start) / 2;\n}\nreturn -1;\n}\npublic:\nint search(vector&lt;int&gt;&amp; nums, int target) {\nif (nums.size() == 1) {\nif (nums[0] == target) return 0;\nelse return -1;\n}\nint rotationPoint = findRotationPoint(nums);\n// the array is sorted from 0 -&gt; rotationPoint - 1\n// and rotationPoint -&gt; nums.size() - 1\nint left = binary_search(nums, 0, rotationPoint - 1, target);\nint right = binary_search(nums, rotationPoint, nums.size() - 1, target);\nreturn std::max(left, right);\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#time-complexity","title":"Time Complexity","text":"<p>To find the rotation point we make \\(O(\\lg N)\\) comparisons and to do binary searchs on both the left and right takes \\(O(\\lg N)\\) time. So total time complexity is \\(O(\\lg N)\\).</p>"},{"location":"binary-search/problems/#search-insert-position","title":"Search Insert Position","text":"<p>Problem on Leetcode \\(\\to\\)</p> <p>Warning</p> <p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p> <p>The algorithm must run with \\(O(\\lg n)\\) complexity.</p>"},{"location":"binary-search/problems/#finding-floor-and-ceil-of-an-element-in-a-sorted-array","title":"Finding Floor and Ceil of an element in a Sorted Array","text":"<p>This is a very important idea we need to understand before you attempt this question. We need to run the binary search algorithm and see where the start and end stops after the execution. Do it yourself, and put it in the comments below. Do a dry run on the binary search algorithm and see what are the start and end points to after the execution finishes. I'll add a video for this later.</p>"},{"location":"binary-search/problems/#approach_3","title":"Approach","text":"<p>We can employ the normal binary search algorithm, and instead of returning -1 if we don't find the target number, we'll carefully look what all the pointers are pointing towards at the end of the binary search algorithm.</p> <p>If we look carefully we'll find that at the end of the binary search if there is no element present in the array, the pointer \\(\\text{start}\\) and \\(\\text{end} - 1\\) points to the insertion point for that element.</p>"},{"location":"binary-search/problems/#careful-dry-run-with-an-example","title":"Careful Dry run with an example","text":""},{"location":"binary-search/problems/#code_3","title":"Code","text":"<pre><code>class Solution {\npublic:\nint searchInsert(vector&lt;int&gt;&amp; nums, int target) {\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (nums[middle] == target) return middle;\nif (nums[middle] &gt; target) {\nend = middle - 1;\n} else if (nums[middle] &lt; target) {\nstart = middle + 1;\n}\nmiddle = start + (end - start) / 2;\n}\n// send back start or end - 1 instead of -1.\nreturn start;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#single-element-in-a-sorted-array","title":"Single Element in a Sorted Array","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#problem-statement_1","title":"Problem Statement","text":"<p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once.</p> <p>Your solution must run in \\(O(\\lg n)\\) time and \\(O(1)\\) space.</p>"},{"location":"binary-search/problems/#approach_4","title":"Approach","text":"<ul> <li>As the solution is required to be run in \\(O(1)\\) space and \\(O(\\lg n)\\) time it means we have to use binary search.</li> <li>Now we run the default binary search algorithm with some modification. We go to the middle element, now question arises based on what should we divide the array and only solve on one of those two part?</li> <li>If you look closely at the array, you will notice that for each pair in the left side of the odd one out <code>&lt;int, int&gt;</code> the index is like this <code>&lt;even, odd&gt;</code> and for each pairs in the right side of the odd one out the index is like this <code>&lt;odd, even&gt;</code>.</li> <li>We identify how the indexes are aranged and we jump to solve a smaller subproblem.</li> </ul>"},{"location":"binary-search/problems/#code_4","title":"Code","text":"<pre><code>class Solution {\npublic:\nint singleNonDuplicate(vector&lt;int&gt;&amp; nums) {\n// if the size is 1 then it is the odd one out\nif (nums.size() == 1) return nums[0];\n// boundary cases:\nif (nums[0] != nums[1]) return nums[0];\nif (nums[nums.size() - 1] != nums[nums.size() - 2]) return nums[nums.size() - 1];\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nint atMid = nums[middle];\nif (atMid != nums[middle - 1] and atMid != nums[middle + 1]) {\n// case where the middle element is the odd one out\nreturn atMid;\n}\n// check if the odd one out is the left or right sub part\n// case 1:\n// [1, 1, ..., 2, 2, ...]\n//             | middle\nif (nums[middle] == nums[middle + 1]) {\n// now check if middle is even and middle + 1 is odd?\n// if this is true then odd one out is in the right subarray\nif (middle % 2 == 0) {\nstart = middle + 1;\n} else {\nend = middle - 1;\n}\n}\n// case 2:\n// [1, 1, ..., 2, 2, ...]\n//                | middle\nif(nums[middle] == nums[middle - 1]) {\n// now check if middle is odd and middle - 1 is even?\nif (middle % 2 != 0) {\nstart = middle + 1;\n} else {\nend = middle - 1;\n}\n}\nmiddle = start + (end - start) / 2;\n}\nreturn -1;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#minimum-difference-element-in-a-sorted-array","title":"Minimum Difference Element in a Sorted Array","text":""},{"location":"binary-search/problems/#problem-statement_2","title":"Problem Statement","text":"<p>Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given \u2018key\u2019.</p>"},{"location":"binary-search/problems/#examples","title":"Examples","text":"<p><pre><code>Input: [4, 6, 10], key = 7\nOutput: 6\nExplanation: The difference between the key '7' and '6' is minimum than any other number in the array.\n</code></pre> <pre><code>Input: [4, 6, 10], key = 4\nOutput: 4\n</code></pre> <pre><code>Input: [1, 3, 8, 10, 15], key = 12\nOutput: 10\n</code></pre> <pre><code>Input: [4, 6, 10], key = 17\nOutput: 10\n</code></pre></p>"},{"location":"binary-search/problems/#approach_5","title":"Approach","text":"<ul> <li>If the element is present in the array, we should return it.</li> <li>If not present, then<ul> <li>We should check the ceil and floor of the element from the array.</li> <li>Floor is the end pointer when the binary search is finished and ceil would be <code>end + 1</code> pointer because the array is sorted.</li> <li>Next we should check what is lower difference between floor and target or ceil or target, which ever is lower that is closer to target.</li> </ul> </li> </ul>"},{"location":"binary-search/problems/#c-code-solution","title":"C++ Code Solution","text":"<pre><code>int minDiffElement(vector&lt;int&gt; &amp;v, int target) {\nint start = 0;\nint end = v.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (v[middle] == target) return target;\nif (v[middle] &lt; target) start = middle + 1;\nif (v[middle] &gt; target) end = middle - 1;\nmiddle = start + (end - start) / 2;\n}\n// lowerbound = at index end\nint diFFWithLowerBound = std::abs(target - v[end]);\nint diFFWithUpperBound = std::abs(v[end+1] - target);\nif (diFFWithLowerBound &gt; diFFWithUpperBound) return v[end + 1];\nif (diFFWithLowerBound &lt; diFFWithUpperBound) return v[end];\nreturn -1; // both are same distant\n}\n</code></pre>"},{"location":"binary-search/problems/#time-and-space-complexity","title":"Time and space complexity","text":"<p>No extra space is required, so \\(O(1)\\) space and total of \\(O(\\lg n)\\) time is required for binary search.</p>"},{"location":"binary-search/problems/#search-in-a-sorted-2d-matrix","title":"Search in a sorted 2D matrix","text":"<p>Similar Problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#problem-statement_3","title":"Problem Statement","text":"<p>Write an efficient algorithm that searches for a value target in an \\(M \\times N\\) integer matrix <code>matrix</code>. This matrix has the following properties:</p> <ol> <li>Integers in each row are sorted from left to right.</li> <li>The first integer of each row is greater than the last integer of the previous row. Also can be termed as inter-row-wise sorted.</li> </ol>"},{"location":"binary-search/problems/#example","title":"Example","text":"<p>Matrix:  \\(M_A = \\begin{bmatrix} 1 &amp; 3 &amp; 5 &amp; 7 \\\\ 10 &amp; 11 &amp; 16 &amp; 20 \\\\ 23 &amp; 30 &amp; 34 &amp; 60  \\end{bmatrix}\\)</p> <pre><code>Input = MA and target = 3\nOutput: true\n</code></pre>"},{"location":"binary-search/problems/#approach_6","title":"Approach","text":"<p>First you start a probe for the row in which the data may be present, then search column wise. Total time taken in this approach is \\(O(\\log_2 \\text{Rows}) + O(\\log_2 \\text{Columns})\\).</p> <p>Check out the following code to see how the edge cases are handled.</p>"},{"location":"binary-search/problems/#code_5","title":"Code","text":"<pre><code>class Solution {\npublic:\nbool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n// base cases\nint rows = matrix.size();\nint cols = matrix[0].size();\n// only one element in the matrix\nif (rows == 1 and cols == 1) return matrix[0][0] == target;\n// matrix data out of bounds\nif (target &lt; matrix[0][0] or target &gt; matrix[rows-1][cols-1]) return false;\n// start a row probe to find in which row the data may be there?\nint start = 0;\nint end = matrix.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (matrix[middle][0] == target) return true;\nif (matrix[middle][0] &gt; target) end = middle - 1;\nif (matrix[middle][0] &lt; target) start = middle + 1;\nmiddle = start + (end - start) / 2;\n}\n// start is the lower bound on the row ID\nint rowID = end;\ncout &lt;&lt; rowID &lt;&lt; endl;\n// now we should start a column probe\nstart = 0;\nend = matrix[0].size() - 1;\nmiddle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (matrix[rowID][middle] == target) return true;\nif (matrix[rowID][middle] &gt; target) end = middle - 1;\nif (matrix[rowID][middle] &lt; target) start = middle + 1;\nmiddle = start + (end - start) / 2;\n}\nreturn false;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#search-in-a-sorted-matrix-but-not-inter-row-wise-sorted","title":"Search in a sorted matrix but not <code>inter-row-wise</code> sorted","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#problem-statement_4","title":"Problem Statement","text":"<p>The problem statement is almost identical similar but the rule first integer of each row is greater than the last integer of the previous row does NOT apply here.</p>"},{"location":"binary-search/problems/#example_1","title":"Example","text":"<p>Matrix:  \\(M_B = \\begin{bmatrix} 1 &amp; 3 &amp; 5 &amp; 7 \\\\ 2 &amp; 4 &amp; 64 &amp; 20 \\\\ 3 &amp; 5 &amp; 134 &amp; 60  \\end{bmatrix}\\)</p> <pre><code>Input = MB and target = 3\nOutput: true\n</code></pre>"},{"location":"binary-search/problems/#approaches","title":"Approaches","text":"<ol> <li>We can do a row wise binary search to find the element, that'll take \\(O(\\text{|rows|} \\lg \\text{|cols|})\\) time to complete.</li> <li>Otherwise we can also implement a linear time algorithm to find the element. This will be much faster than the log approach.<ul> <li>Here we'll do the followings, first we'll start from the first row and last column of the matrix</li> <li>then if we find the element is \\(\\geq\\) than the target means it'll be available only at a lower row than the current row. </li> <li>Here target is 16 and 15 is at the first row and last column of the matrix. So we should go down by one row.</li> <li>At the second row we see 19 that is greater than the target \\(16\\) so we should go left by one column because \\(16\\) can not be present below \\(19\\) in the last column.</li> <li>This is how we find the element.</li> </ul> </li> </ol>"},{"location":"binary-search/problems/#code_6","title":"Code","text":""},{"location":"binary-search/problems/#code-with-binary-search","title":"CODE WITH BINARY SEARCH","text":"<pre><code>class Solution {\nprivate:\nbool rowWiseSearch(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int row, int target) {\nint start = 0;\nint end = matrix[row].size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif(matrix[row][middle] == target) return true;\nif (matrix[row][middle] &gt; target) end = middle - 1;\nif (matrix[row][middle] &lt; target) start = middle + 1;\nmiddle = start + (end - start) / 2;\n}\nreturn false;\n}\npublic:\nbool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\nint rows = matrix.size();\nfor (int i=0; i&lt;rows; i++) {\nbool found = rowWiseSearch(matrix, i, target);\nif (found == true) return true;\n}\nreturn false;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#code-with-matrix-linear-search","title":"CODE WITH MATRIX-LINEAR SEARCH","text":"<pre><code>class Solution {\npublic:\nbool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n// base case: 1x1 matrix\nif (matrix.size() == 1) {\nif (matrix[0].size() == 1) return matrix[0][0] == target;\n}\n// base case: numbers out of bounds\nif (target &lt; matrix[0][0] or target &gt; matrix[matrix.size() - 1][matrix[0].size() - 1]) {\nreturn false;\n}\nint rows = matrix.size();\nint cols = matrix[0].size();\nint i = rows - 1;\nint j = 0;\nwhile(i&gt;=0 and j&lt;cols) {\nif (matrix[i][j] == target) return true;\nif (matrix[i][j] &lt; target) {\nj++;\n} else {\ni--;\n}\n}\nreturn false;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#time-complexity_1","title":"Time Complexity","text":"<p>The matrix linear search takes \\(O(\\text{|rows|} + \\text{|cols|})\\) time because at worst case we'll reach to last row and first column of the matrix.</p>"},{"location":"binary-search/problems/#search-for-range","title":"Search for Range","text":"<p>Problem on Leetcode \\(\\to\\)</p> <p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return \\([-1, -1]\\).</p> <p>We must write an algorithm with \\(O(\\log_2 n)\\) runtime complexity.</p>"},{"location":"binary-search/problems/#example_2","title":"Example","text":"<pre><code>Input: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n</code></pre>"},{"location":"binary-search/problems/#approach_7","title":"Approach","text":"<p>Two things we need to find here, these are the first occurrence of some repeating elements and last occurrence of some repeating elements. Before we do anything we should first search in \\(O(\\lg n)\\) whether the array contains the element or not, if not return \\([-1,-1]\\). Otherwise the program could become complicated while searching for first occurrence and last occurrence also search if it's there or not. Better to separate the logic.</p> <p>So we should write 3 subroutines: <code>firstOccurrence()</code> and <code>lastOccurrence()</code> and a routine for <code>binary_search()</code>. We'll return \\([-1, -1]\\) if <code>binary_search()</code> returns false.</p> <p>To calculate the <code>firstOccurrence()</code> we modify the binary search subroutine itself. When we find the middle element greater than or equal to the target then instead of setting \\(\\text{end} = \\text{middle} - 1\\) we'll include the end as middle (set \\(\\text{end} = \\text{middle}\\)).</p> <p>To calculate the <code>lastOccurence()</code> we'll write the exact same code as <code>firstOccurence()</code> (using symmetry). However there is a problem with the code. The program for <code>lastOccurence()</code> will not halt and loop forever in the following scenario:</p> <pre><code>while (start &lt; end) {\n...\n} else {\nstart = middle;\n}\n...\n}\n</code></pre> <p>the code will fall into infinite loop when the arrangement becomes this</p> <p></p> <p>We'll manually update the lastOccurrence in this case.</p>"},{"location":"binary-search/problems/#code_7","title":"Code","text":"<pre><code>class Solution {\npublic:\nint firstOccurrence(vector&lt;int&gt; &amp;nums, int target) {\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\n// [1,2,3,4,4,4,7]; target = 4;\n//  |     |     |\n// start. mid.  end.\n// next step: [1,2,3,4]\n//               |   |\n//               mid end\n// next step: [3,4]\n//             | |\n//           s,m end\n// next step: [4]\n//             | start, end, middle\nwhile (start &lt; end) {\nif (nums[middle] &lt; target) {\nstart = middle + 1;\n} else {\nend = middle;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn start;\n}\nint lastOccurrence(vector&lt;int&gt; &amp;nums, int target) {\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt; end) {\n// there is a condition when it loops forever\n// end = start + 1;\n// [k , j]\n//  |   |\n// m,s  end\n// check for this\nif (start == end - 1) {\n// check for a case where [2,2] and target is 2\nif (nums[start] == nums[end]) {\nreturn end;\n}\n// manually escape this situation\n// there can be case [5, 7] and t=5 where it loops forever because start = middle\nif (nums[start] == target) {\nreturn start;\n} else if (nums[end] == target){\n// case for [2,3] and t=3\nreturn end;\n}\n}\nif (nums[middle] &gt; target) {\nend = middle - 1;\n} else {\nstart = middle;\n}\nmiddle = start + (end - start) / 2;\n}\nreturn start;\n}\nbool binary_search(vector&lt;int&gt; &amp;nums, int target) {\nint start = 0;\nint end = nums.size() - 1;\nint middle = start + (end - start) / 2;\nwhile (start &lt;= end) {\nif (nums[middle] == target) {\nreturn true;\n}\nif (nums[middle] &lt; target) start = middle + 1;\nif (nums[middle] &gt; target) end = middle - 1;\nmiddle = start + (end - start) / 2;\n}\nreturn false;\n}\nvector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\nif (not binary_search(nums, target)) {\nvector&lt;int&gt; answer = {-1,-1};\nreturn answer;\n}\nvector&lt;int&gt; answer;\nint firstocc = firstOccurrence(nums, target);\nint lastocc = lastOccurrence(nums, target);\nanswer.push_back(firstocc);\nanswer.push_back(lastocc);\nreturn answer;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#koko-eating-bananas","title":"Koko Eating Bananas","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#problem-statement_5","title":"Problem Statement","text":"<p>Koko loves to eat bananas. There are n piles of bananas, the ith pile has <code>piles[i]</code> bananas. The guards have gone and will come back in <code>h</code> hours.</p> <p>Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</p> <p>Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.</p> <p>Return the minimum integer k such that she can eat all the bananas within h hours.</p>"},{"location":"binary-search/problems/#examples_1","title":"Examples","text":"<pre><code>Input: piles = [3,6,7,11], h = 8\nOutput: 4\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n</code></pre>"},{"location":"binary-search/problems/#code_8","title":"Code","text":"<pre><code>class Solution {\nprivate:\npair&lt;bool, int&gt; finishableCheck(vector&lt;int&gt; &amp;piles, int k, int h) {\n// check finishability with k bananas per hour\n// and given h hours to play time\n// retruns finishable or not and finish time\nint eatableTime = 0;\nfor (auto l:piles) {\neatableTime += l/k + (l % k == 0 ? 0 : 1);\n}\npair&lt;bool, int&gt; p;\np.second = eatableTime;\nif (eatableTime &gt; h) {\np.first = false;\nreturn p;\n}\np.first = true;\nreturn p;\n}\npublic:\nint minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) {\nif (piles.size() == 1) {\nreturn ceil((double) piles[0] / (double)h);\n}\n// [piles of banana]\n// [213 45 5 6 7 7 8]\n// total available time is h hours\n// banana eating speed = k\n// lowest possible value for k is 1\n// eat at least min(piles[i]) banana per hour.\nint lo = 1;\n// and highest possible banana per hour\n// should be = piles[i] for i piles[i] is maximum\nint hi = piles[0];\nfor (int i:piles) {\nif (i &gt; hi) hi = i;\n}\nint middle = lo + (hi - lo) / 2;\nwhile (lo &lt; hi) {\n// now check for middle if this satisfies the\n// eating banana pile every hour\n// and finishing before guards comes back\ncout &lt;&lt; \"From \" &lt;&lt; lo &lt;&lt; \" to \" &lt;&lt; hi &lt;&lt; \": \";\npair&lt;bool, int&gt; p = finishableCheck(piles, middle, h);\nif (p.first == true) hi = middle;\nif (p.first == false and p.second &gt; h) {\nlo = middle + 1;\n}\ncout &lt;&lt; \" middle: \" &lt;&lt; middle &lt;&lt; \" p.first = \" &lt;&lt; p.first &lt;&lt; \" p.second = \" &lt;&lt; p.second &lt;&lt; endl;\nmiddle = lo + (hi - lo) / 2;\n}\nreturn hi;\n}\n};\n</code></pre>"},{"location":"binary-search/problems/#time-based-key-value-store","title":"Time Based Key-Value Store","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"binary-search/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.</p> <p>Task is to implement the TimeMap class,</p> <ol> <li><code>TimeMap()</code> Initializes the object of the data structure.</li> <li><code>void set(String key, String value, int timestamp)</code> Stores the key key with the value value at the given time timestamp.</li> <li><code>String get(String key, int timestamp)</code> Returns a value such that set was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>\"\"</code>.</li> </ol>"},{"location":"binary-search/problems/#example_3","title":"Example","text":"<p><pre><code>Input\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\nOutput\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n</code></pre> Explaination <pre><code>Explanation\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n</code></pre></p>"},{"location":"binary-search/problems/#approach-1","title":"Approach #1","text":"<ul> <li>We'll use a time-based map implementation. For each timestamp we'll record all the {key, value} pairs coming in.</li> <li>And return when asked. If the timestamp is not found then we'll see what is the last timestamp for which this key was recorded, we'll return that.</li> <li>To find the last timestamp for which this key was recorded we need to do a linear decrement of the timestamp and check if the key is present or not for every time stamps.</li> <li>Else we can change the design of the map and get a better upper bound on the time complexity. As the times are always in sorted order (time is always increasing), we maybe able to use binary search.</li> <li>For this particular design following is the code.</li> </ul> <p>Hashtable design</p> timestamp unordered_map&lt;Key, Value&gt; 1 &lt;\"outlaw\", \"1673\"&gt; 4 &lt;\"outlaw\", 33&gt;"},{"location":"binary-search/problems/#code-for-approach-1","title":"Code for Approach #1","text":"<pre><code>class TimeMap {\nprivate:\nunordered_map&lt;int, unordered_map&lt;string, string&gt;&gt; mp;\npublic:\nTimeMap() {}\nvoid set(string key, string value, int timestamp) {\nmp[timestamp][key] = value;\n}\nstring get(string key, int timestamp) {\n// if there is no timestamp for key \"key\"\nif (mp.find(timestamp) == mp.end()) {\nwhile (timestamp){\n// go in reverse order of timestamp to find the key if exists before or not?\n// return the last\nif (mp[timestamp].find(key) != mp[timestamp].end()) {\nreturn mp[timestamp][key];\n}\ntimestamp--;\n}\n}\nreturn mp[timestamp][key];\n}\n};\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap* obj = new TimeMap();\n * obj-&gt;set(key,value,timestamp);\n * string param_2 = obj-&gt;get(key,timestamp);\n */\n</code></pre>"},{"location":"binary-search/problems/#approach-2","title":"Approach #2","text":"<p>The previous design was a bit easier to understand but had a flaw that if we don't find element in the map for some timestamp then we'd have to linearly decrease the timestamps and check for the key, else we'll use a better design.</p> <p>For each key we'll, maintain a <code>vector&lt;pair&lt;string, int&gt;&gt;</code> value &amp; time pair. Then if there exists any key and don't exists the asked timestamp we can give back the binary search lower bound from the array.</p> <p>Hashtable new design</p> Key pair&lt;Value, TimeStamp&gt; outlaw &lt;\"1673\", 1&gt;, &lt;\"33\", 4&gt; -- -- <p>Now with this design of the system we can do a simple binary search on the lower bound of the timestamp in \\(O(\\lg N)\\) time.</p>"},{"location":"binary-search/problems/#code-for-approach-2","title":"Code for Approach #2","text":"<pre><code>class TimeMap {\nprivate:\n// hashtable design\n// unordered_map&lt;key, vector&lt;pair&lt;value, timestamp&gt;&gt;&gt;\nunordered_map&lt;string, vector&lt;pair&lt;string, int&gt;&gt;&gt; map;\npublic:\nTimeMap() {}\nvoid set(string key, string value, int timestamp) {\nif (map.find(key) == map.end()) {\n// there doesn't exists a key, first time the key has come up\n// so add this\nvector&lt;pair&lt;string, int&gt;&gt; v= {{value, timestamp}};\nmap.insert({key,v});\n} else {\n// means key is inserted at a before timestamp than now\n// this becomes naturally sorted with the timestamps\nmap[key].push_back({value, timestamp});\n}        }\nstring get(string key, int timestamp) {        // we assume key is already present before making a query\n// we also have a time stamp\n// so we'll do a binary search on the timestamp to get the result at the given time stamp\n// else we'll return the lower bound on the timestamp\nint start = 0;\nint end = map[key].size() - 1;\n// basecase\n// query is at the timestamp far before first key to be registered\nint middle = start + (end - start) / 2;\n// O(lg n) compare\nwhile (start &lt;= end) {\nif (map[key][middle].second == timestamp) return map[key][middle].first;\nif (map[key][middle].second &gt; timestamp) end = middle - 1;\nif (map[key][middle].second &lt; timestamp) start = middle + 1;\nmiddle = start + (end - start) / 2;\n}\nif (end == - 1) return \"\";\nreturn map[key][end].first;\n}\n};\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap* obj = new TimeMap();\n * obj-&gt;set(key,value,timestamp);\n * string param_2 = obj-&gt;get(key,timestamp);\n */\n</code></pre>"},{"location":"binary-search/problems/#next-alphabetical-element","title":"Next alphabetical element","text":""},{"location":"binary-search/problems/#find-position-of-an-element-in-an-infinite-sorted-array","title":"Find position of an element in an Infinite Sorted Array","text":""},{"location":"binary-search/problems/#index-of-first-1-in-a-binary-sorted-infinite-array","title":"Index of First 1 in a Binary Sorted Infinite Array","text":""},{"location":"binary-search/problems/#binary-search-on-answer-concept","title":"Binary Search on Answer Concept","text":""},{"location":"binary-search/problems/#peak-element","title":"Peak Element","text":""},{"location":"binary-search/problems/#find-maximum-element-in-bitonic-array","title":"Find maximum element in Bitonic Array","text":""},{"location":"binary-search/problems/#search-an-element-in-bitonic-array","title":"Search An Element in Bitonic Array","text":""},{"location":"binary-search/problems/#allocate-minimum-number-of-pages","title":"Allocate minimum number of pages","text":""},{"location":"dp/dp-on-strings/","title":"DP on strings","text":"<p>We'll discuss few DP on strings problem here, starting with the Longest Common \ud83d\uddff pattern. Then we'll move on to Edit distance and other similar basic and advanced DP on string problems.</p> <p>Problems discussed</p> <ol> <li>Longest Common Subsequence</li> <li>Printing the Longest Common Subsequence</li> <li>Longest common substring</li> <li>Longest palindromic sequence</li> <li>Minimum number of deletion in a string to make it a palindrome</li> <li>Shortest Common Supersequence (Print)</li> <li>Longest Repeating Subsequence</li> <li>Wildcard Matching</li> <li>Minimum Insertion Steps to Make a String Palindrome</li> </ol>"},{"location":"dp/dp-on-strings/#longest-common-subsequence","title":"Longest Common Subsequence","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/dp-on-strings/#problem-statement","title":"Problem Statement","text":"<p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence. If there is no common subsequence, return <code>0</code>.</p> <p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p> <ul> <li>For example, \"ace\" is a subsequence of \"abcde\".</li> </ul> <p>A common subsequence of two strings is a subsequence that is common to both strings.</p>"},{"location":"dp/dp-on-strings/#examples","title":"Examples","text":"<pre><code>Input: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n---\n\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n---\n\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n</code></pre>"},{"location":"dp/dp-on-strings/#approach","title":"Approach","text":"<ul> <li>We formalize an approach to the solution for a DP problem into the following three steps<ul> <li>Find the base case (smallest viable input),</li> <li>write the choice diagram, write the recursion for that choice diagram</li> <li>memoize this recursion,</li> <li>write bottom up approach solving the recursion.</li> </ul> </li> <li>Here the base case is for a string with size \\(=0\\). Hence we add the first condition for the recursion solution \\(= 0\\) if \\(S_1 \\text{.length or } S_2 \\text{.length} = 0\\). For this case the output is 0.</li> <li>Now following is the choice diagram</li> </ul> <p>For this choice diagram we write the recursion and memoize it (see in code below).</p>"},{"location":"dp/dp-on-strings/#code","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; dp;\nint subroutine(int n1, int n2, string &amp;text1, string &amp;text2) {\nif (n1 &lt;= -1 or n2 &lt;= -1) {\nreturn 0;\n}\n// base case\nif (dp[n1][n2] != -1) return dp[n1][n2];\nif (text1[n1] == text2[n2]) {\nreturn dp[n1][n2] = 1 + subroutine(n1-1, n2-1, text1, text2);\n}\nreturn dp[n1][n2] = std::max(\nsubroutine(n1 - 1, n2, text1, text2),\nsubroutine(n1, n2 - 1, text1, text2)\n);\n}\npublic:\nint longestCommonSubsequence(string text1, string text2) {\ndp = vector&lt;vector&lt;int&gt;&gt;(text1.size(), vector&lt;int&gt;(text2.size(), -1));\nreturn subroutine(text1.size() - 1, text2.size() - 1, text1, text2);\n}\n};\n</code></pre> <p>Converting the code into a iterative DP approach</p> <pre><code>class Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; dp;\nint longestCommonSubsequence(string text1, string text2) {\ndp = vector&lt;vector&lt;int&gt;&gt;(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1, 0));\nint n1 = text1.size();\nint n2 = text2.size();\nfor (int i = 1; i &lt;= n1; i++) {\nfor (int j = 1; j &lt;= n2; j++) {\nif (text1[i - 1] == text2[j - 1]) {\ndp[i][j] = 1 + dp[i - 1][j - 1];\n} else {\ndp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n}\n}\n}\nreturn dp[n1][n2];\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#printing-the-longest-common-subsequence","title":"Printing the Longest Common Subsequence","text":"<p>Find the problem on Coding Ninjas \\(\\to\\)</p>"},{"location":"dp/dp-on-strings/#problem-statement_1","title":"Problem Statement","text":"<p>Same as above, but instead of the length we need the actual subsequence \\((\\textsf{LCS})\\) as the output.</p>"},{"location":"dp/dp-on-strings/#approach_1","title":"Approach","text":"<ul> <li>We know that output of \\(\\textsf{LCS}\\) is stored at \\(dp[n][m]\\) if \\(n, m = \\textsf{size}(S_1), \\textsf{size}(S_2)\\).</li> <li>We reach to \\(dp[n][m]\\) by two ways<ul> <li>If \\(S_1[n] = S_2[m]\\) then from \\(dp[n - 1][m- 1]\\), that is \\(dp[n][m] = 1 + dp[n - 1][m- 1]\\).</li> <li>Otherwise we come from \\(max(dp[n -1][m], dp[n][m-1])\\).</li> </ul> </li> <li>We'll do a backtracking from \\(dp[n][m]\\) to \\(dp[1][1]\\) and add the characters whenever we encounter same characters in \\(S_1, S_2\\).</li> <li>This is the way we build the <code>reverse</code> of \\(\\textsf{LCS}\\) string.</li> <li>We reverse the string and return.</li> </ul>"},{"location":"dp/dp-on-strings/#code_1","title":"Code","text":"<pre><code>#include &lt;string.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstring findLCS(int n, int m,string &amp;s1, string &amp;s2){\nn = s1.size();\nm = s2.size();\nint dp[n + 1][m + 1];\nmemset(dp, 0, sizeof(dp));\n// build the dp table\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 1; j &lt;= m; j++) {\nif (s1[i - 1] == s2[j - 1]) {\ndp[i][j] = 1 + dp[i - 1][j - 1];\n} else {\ndp[i][j] = std::max(dp[i-1][j], dp[i][j-1]);\n}\n}\n}\n// now do backtrack\nstring LCS = \"\";\nint i = n;\nint j = m;\nwhile (i &gt; 0 and j &gt; 0) {\nif (s1[i - 1] == s2[j - 1]) {\nLCS += s1[i - 1];\ni--; j--;\n} else {\nif (dp[i - 1][j] &gt; dp[i][j - 1]) {\ni--;\n} else {\nj--;\n}\n}\n}\nstd::reverse(LCS.begin(), LCS.end());\nreturn LCS;\n}\n</code></pre>"},{"location":"dp/dp-on-strings/#longest-common-substring","title":"Longest common substring","text":"<p>Find the problem on GeeksForGeeks \\(\\to\\)</p>"},{"location":"dp/dp-on-strings/#problem-statement_2","title":"Problem Statement","text":"<p>Given two strings. The task is to find the length of the longest common substring. </p> <p>Examples <pre><code>Input: S1 = \"ABCDGH\", S2 = \"ACDGHR\", n = 6, m = 6\nOutput: 4\nExplanation: The longest common substring\nis \"CDGH\" which has length 4.\n---\n\nInput: S1 = \"ABC\", S2 \"ACB\", n = 3, m = 3\nOutput: 1\nExplanation: The longest common substrings\nare \"A\", \"B\", \"C\" all having length 1.\n</code></pre></p>"},{"location":"dp/dp-on-strings/#approach_2","title":"Approach","text":"<ul> <li>The main difference from the last problem is that here we need to consider a continuous substring.</li> <li>We define \\(dp[i][j]\\) as same of length of \\(S_1[1 \\dots i], S_2[1 \\dots j]\\). If \\(S_1[1 \\dots i] \\neq S_2[1 \\dots j]\\) then the common substring size we set to \\(0\\). </li> <li>We record every step if we find the biggest substring so far.</li> </ul>"},{"location":"dp/dp-on-strings/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nint longestCommonSubstr (string S1, string S2, int n, int m) {\nint dp[n + 1][m + 1];\nmemset(dp, 0, sizeof(dp));\nint maxLength = 0;\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 1; j &lt;= m; j++) {\nif (S1[i - 1] == S2[j - 1]) {\ndp[i][j] = dp[i - 1][j - 1] + 1;\nmaxLength = std::max(maxLength, dp[i][j]);\n}\n/* else { dp[i][j] = 0; }\n                 * if we don't see same element we reset the dp[i][j] = 0;\n                 * but it is already 0 via memset.\n                 */\n}\n}\nreturn maxLength;\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#longest-palindromic-sequence","title":"Longest palindromic sequence","text":""},{"location":"dp/dp-on-strings/#problem-statement_3","title":"Problem Statement","text":"<p>Given a string s, find the longest palindromic subsequence's length in s.</p> <p>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>"},{"location":"dp/dp-on-strings/#approach_3","title":"Approach","text":"<p>Longest palindromic subsequence has the following characteristics 1. It is pallindrome. Hence it reads same as front to back and back to front. 1. It is longest.</p> <p>As it reads same as front to back and back to front, if we reverse the original string the longest palindromic subsequence should remain the same.</p> <p>Hence if we find the longest common subsequence between the string and its reverse we find the longest palindromic subsequence for the string. Hence the following code.</p>"},{"location":"dp/dp-on-strings/#code_3","title":"Code","text":"<pre><code>class Solution {\npublic:\nint LCS(string s1, string s2) {\nint n;\nn = s1.size();\nint dp[n + 1][n + 1];\nmemset(dp, 0, sizeof(dp));\nfor (int i = 0; i &lt;= n; i++) {\nfor (int j = 0; j &lt;= n; j++) {\nif (not i or not j) {\ndp[i][j] = 0;\n} else {\nif (s1[i - 1] == s2[j - 1]) {\ndp[i][j] = 1 + dp[i - 1][j - 1];\n} else {\ndp[i][j] = std::max(\ndp[i - 1][j],\ndp[i][j - 1]\n);\n}\n}\n}\n}\nreturn dp[n][n];\n}\nint longestPalindromeSubseq(string s) {\nstring s2 = s;\nreverse(s2.begin(), s2.end());\nreturn LCS(s, s2);\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#minimum-number-of-deletion-in-a-string-to-make-it-a-palindrome","title":"Minimum number of deletion in a string to make it a palindrome","text":""},{"location":"dp/dp-on-strings/#problem-statement_4","title":"Problem Statement","text":"<p>Given a string <code>s</code>, find the minimum deletion from the string required to go to a palindrome.</p>"},{"location":"dp/dp-on-strings/#approach_4","title":"Approach","text":"<ul> <li>The operation we need is simple deletion.</li> <li>Hence if we do minimal deletion we can reach the largest palindromic subsequence.</li> <li>Hence total of \\(\\text{length} - \\text{size of longest palindromic subsequence}\\) is the amount of deletion needed to a palindromic string.</li> </ul>"},{"location":"dp/dp-on-strings/#code_4","title":"Code","text":"<pre><code>class Solution {\npublic:\nint minimumDeletionToMakePalindrome(string s) {\nstring s2 = s;\nreverse(s2.begin(), s2.end());\nreturn s.size() - LCS(s, s2);\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#shortest-common-supersequence-print","title":"Shortest Common Supersequence (Print)","text":"<p>Find the problem on leetcode here</p>"},{"location":"dp/dp-on-strings/#problem-statement_5","title":"Problem Statement","text":"<p>Given two strings <code>str1</code> and <code>str2</code>, return the shortest string that has both <code>str1</code> and <code>str2</code> as subsequences. If there are multiple valid strings, return any of them.</p> <p>A string <code>s</code> is a subsequence of string <code>t</code> if deleting some number of characters from <code>t</code> (possibly 0) results in the string <code>s</code>.</p>"},{"location":"dp/dp-on-strings/#approach_5","title":"Approach","text":"<ul> <li>First of all the size of the SCS is \\(n + m - \\textsf{LCS}(\\text{str1, str2})\\), that is we add two strings to get the super-sequence and then remove one time \\(\\textsf{LCS}\\) because this has been added twice.</li> <li>Similar to printing LCS we will use the DP table for LCS to backtrack and find the actual solution.</li> <li>Here in this case two code-changes are needed. First one is if we are matching two characters we add them in the solution, but when we don't get a match we move either \\(i - 1\\) or \\(j - 1\\) and we need to add those to the shortest super-sequence because it is not appearing on \\(\\textsf{LCS}\\).</li> <li>Next is once the while loop stops, it is either because \\(i\\) ran out or \\(j\\) ranout. In case of LCS common sub-sequence of a null string with some random string is null string, but here \\(\\textsf{SCS}(\\phi, S) = S\\).</li> <li>These are the two code changes needed to print \\(\\textsf{SCS}\\).</li> </ul>"},{"location":"dp/dp-on-strings/#code_5","title":"Code","text":"<pre><code>class Solution {\npublic:\nvoid buildDPTableForLCS(vector&lt;vector&lt;int&gt;&gt; &amp;dp, string str1, string str2) {\nint n = str1.size();\nint m = str2.size();\nfor (int i = 0; i &lt;= n; i++) {\nfor (int j = 0; j &lt;= m; j++) {\nif (not i or not j) {\ndp[i][j] = 0;\n} else {\nif (str1[i - 1] == str2[j - 1]) {\ndp[i][j] = 1 + dp[i-1][j-1];\n} else {\ndp[i][j] = std::max(\ndp[i - 1][j],\ndp[i][j - 1]\n);\n}\n}\n}\n}\n}\nstring shortestCommonSupersequence(string str1, string str2) {\nint n = str1.size();\nint m = str2.size();\nvector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));\nbuildDPTableForLCS(dp, str1, str2);\nstring s = \"\";\nint i = n, j = m;\nwhile (i &gt; 0 and j &gt; 0) {\nif (str1[i - 1] == str2[j - 1]) {\ns += str1[i - 1];\ni--; j--;\n} else {\nif (dp[i - 1][j] &gt; dp[i][j - 1]) {\ns += str1[i-1]; i--;\n} else {\ns += str2[j - 1];\nj--;\n}\n}\n}\nwhile (i &gt; 0) {\ns += str1[i-1]; i--;\n}\nwhile (j &gt; 0) {\ns += str2[j - 1];\nj--;\n}\nstd::reverse(s.begin(), s.end());\nreturn s;\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#longest-repeating-subsequence","title":"Longest Repeating Subsequence","text":"<p>Find the problem on GeeksForGeeks.</p>"},{"location":"dp/dp-on-strings/#problem-statement_6","title":"Problem Statement","text":"<p>Given string <code>str</code>, find the length of the longest repeating subsequence such that it can be found twice in the given string.</p> <p>The two identified subsequences \\(A\\) and \\(B\\) can use the same \\(i^{\\text{th}}\\) character from string <code>str</code> if and only if that ith character has different indices in \\(A\\) and \\(B\\). For example, \\(A = xax\\) and \\(B = xax\\) then the index of first \\(x\\) must be different in the original string for \\(A\\) and \\(B\\).</p>"},{"location":"dp/dp-on-strings/#approach_6","title":"Approach","text":"<ul> <li>Longest repeating subsequence is same as \\(\\textsf{LCS}(S, S)\\) except we don't match if two characters are at the same location. For example<ul> <li>If \\(S = \\textsf{AKASH}\\) then \\(A\\) is the longest repeating subsequence, we don't consider \\(K, S, H\\) as they are not repeating.</li> </ul> </li> <li>Notice the only code changes in the \\(11^{\\text{th}}\\) line.</li> </ul>"},{"location":"dp/dp-on-strings/#code_6","title":"Code","text":"LongestRepeatingSubsequence.cpp<pre><code>class Solution {\npublic:\nint LCS(string s1, string s2) {\nint n = s1.size();\nint m = s2.size();\nvector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 1; j &lt;= m; j++) {\nif (i!=j and s1[i - 1] == s2[j - 1]) {\ndp[i][j] = 1 + dp[i - 1][j - 1];\n} else {\ndp[i][j] = std::max(\ndp[i - 1][j],\ndp[i][j - 1]\n);\n}\n}\n}\nreturn dp[n][m];\n}\nint LongestRepeatingSubsequence(string str){\nreturn LCS(str, str);\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#wildcard-matching","title":"Wildcard Matching","text":"<p>Find the problem on Leetcode \\(\\to\\)</p> <p>Given an input string \\(s\\) and a pattern \\(p\\), implement wildcard pattern matching with support for \\(?\\) and \\(*\\) where:</p> <ol> <li>\\(?\\) Matches any single character.</li> <li>\\(*\\) Matches any sequence of characters (including the empty sequence).</li> <li>The matching should cover the entire input string (not partial).</li> </ol>"},{"location":"dp/dp-on-strings/#examples_1","title":"Examples","text":"<pre><code>Input: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n---\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n---\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n</code></pre>"},{"location":"dp/dp-on-strings/#approach_7","title":"Approach","text":"<p>Similar approach to the \\(\\textsf{LCS}\\) problem. A very detailed read-up about the solution is available here.</p>"},{"location":"dp/dp-on-strings/#code_7","title":"Code","text":"<pre><code>class Solution {\npublic:\nbool isMatch(string s, string p) {\n// base cases\nif (p == \"*\") return true;\nif (p == \"?\" and s.size() == 1) {\nreturn true;\n} else if (p == \"?\" and (s.size() &gt; 1 or s.size() == 0)) {\nreturn false;\n}\nvector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector(p.size() + 1, false));\ndp[0][0] = true;\nfor (int j = 0; j &lt; p.size() &amp;&amp; p[j] == '*'; j++) {\ndp[0][j + 1] = true;\n}\nfor (int i = 1; i &lt;= s.size(); ++i) {\nfor (int j = 1; j &lt;= p.size(); ++j) {\nif (s[i - 1] == p[j - 1] || p[j - 1] == '?') {\ndp[i][j] = dp[i - 1][j - 1];\n} else if (p[j - 1] == '*') {\ndp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n}\n}\n}\nreturn dp[s.size()][p.size()];\n}\n};\n</code></pre>"},{"location":"dp/dp-on-strings/#minimum-insertion-steps-to-make-a-string-palindrome","title":"Minimum Insertion Steps to Make a String Palindrome","text":"<p>Find the problem on Leetcode.</p>"},{"location":"dp/dp-on-strings/#problem-statement_7","title":"Problem Statement","text":"<p>Given a string <code>s</code>. In one step you can insert any character at any index of the string.</p> <p>Return the minimum number of steps to make s palindrome.</p> <p>A Palindrome String is one that reads the same backward as well as forward.</p>"},{"location":"dp/dp-on-strings/#examples_2","title":"Examples","text":"<pre><code>Input: s = \"zzazz\"\nOutput: 0\nExplanation: The string \"zzazz\" is already palindrome we do not need any insertions.\n---\n\nInput: s = \"mbadm\"\nOutput: 2\nExplanation: String can be \"mbdadbm\" or \"mdbabdm\".\n---\n\nInput: s = \"leetcode\"\nOutput: 5\nExplanation: Inserting 5 characters the string becomes \"leetcodocteel\".\n</code></pre>"},{"location":"dp/dp-on-strings/#approach_8","title":"Approach","text":"<ul> <li>This is same as the solution to the number of deletions required to make it a palindrome.</li> <li>The reason for that is, that number is the differential between a random string to a palindrome. Now for each of that character in the differential we add its pair to make it a palindrome will be the minimum insertion required.</li> </ul> <p>For example in the case of \\(\\text{mbadm}\\) the \\(\\textsf{LPS} = \\text{mam}\\). Hence the differential is \\(bd\\). For the first \\(b\\) we add \\(b\\) after \\(d\\) and vice verse. That makes the palindrome as \\(\\textsf{mdbadbm}\\).</p>"},{"location":"dp/dp-on-strings/#code_8","title":"Code","text":"<pre><code>class Solution {\npublic:\nint LCS(string s1, string s2) {\nint n;\nn = s1.size();\nint dp[n + 1][n + 1];\nmemset(dp, 0, sizeof(dp));\nfor (int i = 0; i &lt;= n; i++) {\nfor (int j = 0; j &lt;= n; j++) {\nif (not i or not j) {\ndp[i][j] = 0;\n} else {\nif (s1[i - 1] == s2[j - 1]) {\ndp[i][j] = 1 + dp[i - 1][j - 1];\n} else {\ndp[i][j] = std::max(\ndp[i - 1][j],\ndp[i][j - 1]\n);\n}\n}\n}\n}\nreturn dp[n][n];\n}\nint minInsertions(string s) {\nstring s2 = s;\nreverse(s2.begin(), s2.end());\nreturn s.size() - LCS(s, s2);\n}\n};\n</code></pre>"},{"location":"dp/knapsack/","title":"Knapsack (0/1) Pattern","text":"<p>These problems discussed below conform to one knapsack pattern. Using solutions to the knapsack problem and a minor modification, you can solve almost all of the following problems. We'll discuss this as we explain the code and the approach to these problems.</p> <p>Problems discussed</p> <ol> <li>Vanilla 0/1 Knapsack Problem</li> <li>Subset Sum</li> <li>Partition Equal Subset Sum</li> <li>Count of Subset sum</li> <li>Minimum subset sum difference</li> <li>Number of subsets with given difference</li> <li>Target Sum</li> </ol>"},{"location":"dp/knapsack/#vanilla-01-knapsack-problem","title":"Vanilla 0/1 Knapsack Problem","text":""},{"location":"dp/knapsack/#problem-statement","title":"Problem statement","text":"<p>Find the problem in GFG.</p> <p>It is a standard \\(0/1\\) Knapsack Problem. Given a knapsack with \\(W\\) bound on the weight, \\(p[n]\\) profits for each item, \\(w[n]\\) weights of each item, find \\(X \\in \\{0,1\\}^n\\) such that \\(p^TX\\) is maximized and \\(w^T X \\leq W\\). \\(X\\) is a solution to the \\(0/1\\) knapsack problem.</p>"},{"location":"dp/knapsack/#approach","title":"Approach","text":""},{"location":"dp/knapsack/#recursive-approach","title":"Recursive approach","text":"<p>Suppose \\(w= [1,3,4,5]\\) and \\(p = [1,4,5,7]\\). Now we have \\(4\\) items, and we create a choice diagram. For each \\(i \\in [n]\\) we have a choice whether to include that element \\(i\\) into the knapsack.</p> <p>Following is the choice diagram for every element in the item list.</p> <p></p> <p>Recursive design should follow the syntax described below <pre><code>int knapsack(auto params) {\n/* BASE CONDITION */\n/* Call knapsack(params) on Choice Diagram */\n}\n</code></pre></p> <p>Transforming the choice diagram into code</p>"},{"location":"dp/knapsack/#code","title":"Code","text":"<p>This is a simple recursive solution (not memoized).</p> <pre><code>class Solution {\npublic:\n//Function to return max value that can be put in knapsack of capacity W.\nint knapSack(int W, int wt[], int val[], int n) {\n/* BASE CONDITION [smallest value input] */\nif (n &lt;= 0 or W &lt;= 0) {\nreturn 0;\n}\n/* Choice Diagram */\nif (wt[n - 1] &lt;= W) {\nreturn std::max(\nval[n - 1] + knapSack(W - wt[n-1], wt, val, n - 1),\nknapSack(W, wt, val, n - 1)\n);\n}\n// not include as capacity is lower\nreturn knapSack(W, wt, val, n - 1);\n}\n};\n</code></pre> <p>We now memoize the solution to use the dynamic programming paradigm.</p> <p>General approach to memoize a recursive solution</p> <ul> <li>First, we need to identify what are the values that are changing,</li> <li>Make a <code>vector&lt;nested vector&lt;int&gt;&gt;</code> 1D, 2D. 3D depending upon the number of elements changing.</li> </ul> <pre><code>class Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; dp;\nbool tableInitialized = false;\n//Function to return max value that can be put in knapsack of capacity W.\nint knapSack(int W, int wt[], int val[], int n) {\n// base condition [smallest value input]\nif (not tableInitialized) {\ndp = vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(W + 1, -1));\ntableInitialized = true;\n}\nif (dp[n][W] != -1) {\nreturn dp[n][W];\n}\nif (n &lt;= 0 or W &lt;= 0) {\nreturn 0;\n}\nif (wt[n - 1] &lt;= W) {\ndp[n][W] = std::max(\nval[n - 1] + knapSack(W - wt[n-1], wt, val, n - 1),\nknapSack(W, wt, val, n - 1)\n);\nreturn dp[n][W];\n}\n// not include as capacity is lower\ndp[n][W] = knapSack(W, wt, val, n - 1);\nreturn dp[n][W];\n}\n};\n</code></pre> <p>The following is a top-down approach for \\(0/1\\) knapsack <pre><code>class Solution {\npublic:\n//Function to return max value that can be put in knapsack of capacity W.\nint knapSack(int W, int wt[], int val[], int n) {\nint dp[n + 1][W + 1];\nmemset(dp, -1, sizeof(dp));\nfor (int i = 0; i &lt; W + 1; i++) {\ndp[0][i] = 0;\n}\nfor (int i = 0; i &lt; n + 1; i++) {\ndp[i][0] = 0;\n}\nfor (int i = 1; i &lt; n + 1; i++) {\nfor (int j = 1; j &lt; W + 1; j++) {\nif (j &gt;= wt[i - 1]) {\ndp[i][j] = std::max(\ndp[i-1][j],  // not considering the i th element\ndp[i-1][j - wt[i-1]] + val[i-1] // considering the i th element\n);\n} else {\ndp[i][j] = dp[i-1][j]; // not considering the i th element\n}\n}\n}\nreturn dp[n][W];\n}\n};\n</code></pre></p>"},{"location":"dp/knapsack/#approach-identification","title":"Approach Identification","text":"<p>To identify a problem having a solution similar to knapsack is to find out if there are two of the following thing</p> <ul> <li>an upper bound of some integer \\(W\\),</li> <li>An array where we can choose to include or not include certain elements</li> </ul>"},{"location":"dp/knapsack/#subset-sum","title":"Subset Sum","text":""},{"location":"dp/knapsack/#problem-statement_1","title":"Problem Statement","text":"<p>Given an array of non-negative integers and a value sum, determine if there is a subset of the given set with a sum equal to the given sum</p>"},{"location":"dp/knapsack/#example","title":"Example","text":"<pre><code>Input: N = 6, arr[] = {3, 34, 4, 12, 5, 2}, sum = 9\nOutput: 1\n\nExplanation: Here there exists a subset with sum = 9, 4+3+2 = 9.\n</code></pre>"},{"location":"dp/knapsack/#recursive-solution","title":"Recursive solution","text":"<pre><code>class Solution{   public:\nbool subSetPossible = false;\nvector&lt;vector&lt;int&gt;&gt; dp;\n// Main function\nbool isSubsetSum(vector&lt;int&gt; arr, int sum) {\nint size = arr.size();\ndp = vector&lt;vector&lt;int&gt;&gt;(sum + 1, vector&lt;int&gt;(size + 1, -1)); // sum and index is changing\nrecursiveSubroutine(arr, sum, 0, size);\nreturn subSetPossible;\n}\nvoid recursiveSubroutine(vector&lt;int&gt;&amp; arr, int sum, int i, int size) {\nif (i == size) return;\nif (sum == 0) {\nsubSetPossible = true;\nreturn;\n}\nif (arr[i] &gt; sum) {\n// do not take the element and move on\nrecursiveSubroutine(arr, sum, i + 1, size);\nreturn;\n} else {\nrecursiveSubroutine(arr, sum - arr[i], i+1, size);  // take\nrecursiveSubroutine(arr, sum, i+1, size);           // no take\n}\n}\n};\n</code></pre> <p>Now all left is to memoize the solution</p> <p>My approach for memoization of the code up-above.</p> <ul> <li>We find that <code>sum</code>, and <code>i</code> are two variable that is changing.</li> <li>Goal for memoization is not to compute any precomputed function calls.</li> <li>So we'll create a vector <code>dp</code> to store existing call results on a particular <code>sum, i</code>.</li> <li>We need to change the function signature by returning a <code>bool</code> if <code>dp[</code>sum][i]` is true. This will solve sub-problems, and using that, we can compute the subset sum optimally using overlapping subproblems.</li> </ul> <pre><code>class Solution{   public:\nbool subSetPossible = false;\nvector&lt;vector&lt;int&gt;&gt; dp;\nbool isSubsetSum(vector&lt;int&gt; arr, int sum) {\nint size = arr.size();\ndp = vector&lt;vector&lt;int&gt;&gt;(sum + 1, vector&lt;int&gt;(size + 1, -1)); // sum and index is changing\nreturn recursiveSubroutine(arr, sum, 0, size);\n}\nbool recursiveSubroutine(vector&lt;int&gt;&amp; arr, int sum, int i, int size) {\nif (i &gt;= size and sum) return false;\nif (sum == 0) {\nreturn true;\n}\nif (dp[sum][i] != -1) return dp[sum][i];\nif (arr[i] &gt; sum) {\n// do not take the element and move on\nreturn dp[sum][i] = recursiveSubroutine(arr, sum, i + 1, size);\n}\nreturn dp[sum][i] = (recursiveSubroutine(arr, sum - arr[i], i+1, size) or recursiveSubroutine(arr, sum, i+1, size));\n}\n};\n</code></pre>"},{"location":"dp/knapsack/#iterative-dp-approach","title":"Iterative DP approach","text":"<pre><code>class Solution{   public:\nvector&lt;vector&lt;bool&gt;&gt; dp;\nbool isSubsetSum(vector&lt;int&gt;arr, int sum) {\nint size = arr.size();\ndp = vector&lt;vector&lt;bool&gt;&gt;(sum + 1, vector&lt;bool&gt;(size + 1, -1));\n// if sum = 0; then always possible\nfor (int i = 0; i &lt;= size; i++) {\ndp[0][i] = true;\n}\n// &gt; 0 sum and no element is not possible\nfor (int i = 1; i &lt;= sum; i++) {\ndp[i][0] = false;\n}\nfor (int i = 1; i &lt;= sum; i++) {\nfor (int j = 1; j &lt;= size; j++) {\n// dp[i][j] till jth element is it possible to \n// get a subset with sum = i;\nif (arr[j - 1] &gt; i) {\n// not possible\ndp[i][j] = dp[i][j - 1];\n} else {\ndp[i][j] = dp[i][j - 1] or dp[i - arr[j - 1]][j - 1];\n}\n}\n}\nreturn dp[sum][size];\n}\n};\n</code></pre>"},{"location":"dp/knapsack/#partition-equal-subset-sum","title":"Partition Equal Subset Sum","text":"<p>Find the problem on Leetcode</p>"},{"location":"dp/knapsack/#problem-statement_2","title":"Problem Statement","text":"<p>Given an integer array <code>nums</code>, return <code>true</code> if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or <code>false</code> otherwise.</p>"},{"location":"dp/knapsack/#examples","title":"Examples","text":"<pre><code>Input: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n---\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n---\n</code></pre>"},{"location":"dp/knapsack/#approach_1","title":"Approach","text":"<ul> <li>We have to divide the array into two parts to equal the total sum.</li> <li>If the total sum is odd, then no way we can separate the two arrays.</li> <li>Otherwise, we need to find if there exists a subset with target \\(= \\frac{\\text{sum}}{2}\\).</li> </ul>"},{"location":"dp/knapsack/#code_1","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; dp;\nbool recursiveSubroutine(vector&lt;int&gt; &amp;nums, int sum, int i) {\nint size = nums.size();\nif (i &gt;= size and sum) return false;\nif (sum == 0) return true;\nif (dp[sum][i] != -1) return dp[sum][i];\nif (nums[i] &gt; sum) {\nreturn dp[sum][i] = recursiveSubroutine(nums, sum, i + 1);\n}\nreturn dp[sum][i] = recursiveSubroutine(nums, sum, i + 1)\nor recursiveSubroutine(nums, sum - nums[i], i + 1);\n}\npublic:\nbool canPartition(vector&lt;int&gt;&amp; nums) {\nint target = 0;\nfor (auto i : nums) target += i;\nif (target % 2 != 0) return false;\nelse target /= 2;\nint size = nums.size();\ndp = vector&lt;vector&lt;int&gt;&gt;(target + 1, vector&lt;int&gt;(size + 1, -1));\nreturn recursiveSubroutine(nums, target, 0);\n}\n};\n</code></pre>"},{"location":"dp/knapsack/#count-of-subset-sum","title":"Count of Subset sum","text":"<p>Find the problem on GFG</p>"},{"location":"dp/knapsack/#problem-statement_3","title":"Problem Statement","text":"<p>Given an array arr[] of non-negative integers and an integer sum, the task is to count all subsets of the given array with a sum equal to a given sum.</p>"},{"location":"dp/knapsack/#example_1","title":"Example","text":"<pre><code>Input: N = 6, arr[] = {2, 3, 5, 6, 8, 10}\n       sum = 10\nOutput: 3\nExplanation: {2, 3, 5}, {2, 8}, {10}\n</code></pre>"},{"location":"dp/knapsack/#approach_2","title":"Approach","text":"<p>In the last problem we indicated if there exists a sub problem with <code>isSubsetSum = true</code>. Now for this problem we simply add true boolean outputs from subproblems. This way we can count how many times true is returned.</p>"},{"location":"dp/knapsack/#code_2","title":"Code","text":"<pre><code>class Solution{\npublic:\nint MOD = 1e9 + 7;\nvector&lt;vector&lt;int&gt;&gt; dp;\nint perfectSum(int arr[], int n, int sum) {\ndp = vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(sum + 1, 0));\nfor (int i = 0; i &lt;= n; i++) {\ndp[i][0] = 1;\n}\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 0; j &lt;= sum; j++) { // TODO: if we set j = 1..sum there is a problem\nif (j - arr[i-1] &gt;= 0) {\ndp[i][j] = (dp[i - 1][j] + dp[i - 1][j - arr[i-1]]) % MOD;\n} else {\ndp[i][j] = dp[i - 1][j]; // dont consider the element\n}\n}\n}\nreturn dp[n][sum];\n}\n};\n</code></pre>"},{"location":"dp/knapsack/#minimum-subset-sum-difference","title":"Minimum subset sum difference","text":""},{"location":"dp/knapsack/#problem-statement_4","title":"Problem Statement","text":"<p>You are given an array <code>arr</code> containing <code>n</code> non-negative integers. Your task is to partition this array into two subsets such that the absolute difference between subset sums is minimum. You just need to find the minimum absolute difference considering any valid division of the array elements.</p>"},{"location":"dp/knapsack/#approach_3","title":"Approach","text":"<ul> <li>We need to divide the array into two parts \\(s_1, s_2\\) such that \\(abs(\\sum_{i} s_1[i] - \\sum_{i} s_2[i])\\) is minimized.</li> <li>For each subset \\(s_i\\), the sum \\(\\sum_{j} s_i[j] \\in \\left[0, \\sum_{i} A[i]\\right]\\). Where \\(A\\) is the main array.</li> <li>Hence the difference \\(s_1 - s_2\\) becomes \\(abs(\\sum_{i} A[i] - 2s_1)\\).</li> <li>Now instead of finding \\(\\displaystyle\\min_{\\forall s_1, s_2 \\in 2^n} abs(s_1, s_2)\\) we need to find \\(\\displaystyle\\min_{\\forall s_1 \\in 2^n} abs(2s_1 - \\sum_i A[i])\\).</li> <li>Now for each of the possible sum \\(\\sum_i s_1[i]\\) we find this breaking creates least value of \\(abs(2s_1 - \\sum_i A[i])\\).</li> <li>We return the least value.</li> </ul>"},{"location":"dp/knapsack/#code_3","title":"Code","text":"<pre><code>typedef struct Loc {\nint i, j;\n} Loc;\nint minSubsetSumDifference(vector&lt;int&gt; &amp;arr, int n) {\nint minSum = 0;\nint maxSum = accumulate(arr.begin(), arr.end(), 0);\nint minimumSubsetSumDifference = INT_MAX;\nint size = arr.size();\nint sum = maxSum;\nvector&lt;vector&lt;bool&gt;&gt; dp(size + 1, vector&lt;bool&gt;(sum + 1, false));\nfor (int i = 0; i &lt;= size; i++) {\ndp[i][0] = true;\n}\nvector&lt;Loc&gt; locations; // store locations in the last array where\n// there is a subset s_1 possible\nfor (int i = 1; i &lt;= size; i++) {\nfor (int j = 1; j &lt;= sum; j++) {\nif (j - arr[i - 1] &gt;= 0) {\ndp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]];\n} else {\ndp[i][j] = dp[i - 1][j];\n}\nif (i == size and dp[i][j] == 1) {\nLoc loc;\nloc.i = i, loc.j = j;\nlocations.push_back(loc);\n}\n}\n}\n// for each of the s_i find out the difference.\nfor (auto loc : locations) {\nint i = loc.i, j = loc.j;\nminimumSubsetSumDifference = std::min(minimumSubsetSumDifference, abs(2 * j - maxSum));\n}\nreturn minimumSubsetSumDifference;\n}\n</code></pre>"},{"location":"dp/knapsack/#number-of-subsets-with-given-difference","title":"Number of subsets with given difference","text":""},{"location":"dp/knapsack/#problem-statement_5","title":"Problem Statement","text":"<p>Given an array \\(A\\) and a difference <code>diff</code> = \\(d\\), find the number of subsets that array can be divided into so that each the difference between the two subset is the given \\(d\\).</p>"},{"location":"dp/knapsack/#approach_4","title":"Approach","text":"<ul> <li>We'll re-use the previous concepts in order to solve this problem at hand,</li> <li>We need to break the array into two parts \\(S_1, S_2\\) such a way that \\(\\sum_i S_1[i] - \\sum_i S_2[i] = d\\) where \\(d\\) is the given difference. We need to find out the number of such pairs \\(S_1, S_2\\).</li> <li>Observation: it is also known that \\(\\sum_i S_1[i] + \\sum_i S_2[i] = \\sum_i A[i]\\).</li> <li>If we add the two equation from up above we get the following \\(2* \\sum_i S_1[i] = d + \\sum_i A[i]\\). Hence \\(\\sum_i S_1[i] = \\frac{d + \\sum_i A[i]}{2}\\)</li> <li>Hence the question now becomes from How many \\(S_1, S_2\\) pairs possible for the difference = \\(d\\) to How many subsets possible with \\(S_1 = j\\) for some number \\(j = \\frac{d + \\sum_i A[i]}{2}\\).</li> </ul>"},{"location":"dp/knapsack/#code_4","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nclass Solution {\npublic:\nint MOD = 1e9 + 7;\nint sumOfArray = 0;\nvector&lt;vector&lt;int&gt;&gt; dp;\nint countPartitions(int n, int d, vector&lt;int&gt;&amp; arr) {\nsumOfArray = 0;\nfor (int i : arr) sumOfArray+=i;\nint j = (d + sumOfArray) / 2;\nbuildDPTable(n, arr, j);\nreturn dp[n][j];\n}\n// build the dp table\nvoid buildDPTable(int n, vector&lt;int&gt;&amp; arr, int sum) {\ndp = vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(sum + 1, -1));\nfor (int i = 1; i &lt;= sum ; i++) {\ndp[0][i] = 0; // no solution for +ve sum and 0 element\n}\nfor (int i = 0; i &lt;= n; i++) {\ndp[i][0] = 1; // empty subset for sum = 0\n}\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 1; j &lt;= sum ; j++) {\ndp[i][j] = dp[i - 1][j];\nif (j - arr[i - 1] &gt;= 0) {\ndp[i][j] += dp[i - 1][j - arr[i - 1]];\n}\n}\n} }\n};\nint main() {\nSolution s;\nint n, d;\ncin &gt;&gt; n &gt;&gt; d;\nvector&lt;int&gt; a(n, 0);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];\ncout &lt;&lt; s.countPartitions(n, d, a);\n}\n</code></pre>"},{"location":"dp/knapsack/#target-sum","title":"Target Sum","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/knapsack/#problem-statement_6","title":"Problem Statement","text":"<p>You are given an integer array \\(\\textsf{nums}\\) and an integer \\(\\textsf{target}\\).</p> <p>You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.</p> <p>For example, if \\(\\textsf{nums} = [2, 1]\\), you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \\(+2-1\\).</p> <p>Return the number of different expressions that you can build, which evaluates to target.</p>"},{"location":"dp/knapsack/#approach_5","title":"Approach","text":""},{"location":"dp/knapsack/#code_5","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint countSubsetSumDifference(vector&lt;int&gt;&amp; nums, int difference) {\nint sum = accumulate(nums.begin(), nums.end(), 0);\nint target = (sum + difference) / 2;\nif ((sum + difference) % 2 or sum &lt; difference) return 0;\nif (target &lt; 0) return 0;\nreturn findNumberOfSubsetWithTarget(nums, target);\n}\nint findNumberOfSubsetWithTarget(vector&lt;int&gt;&amp; nums, int sum) {\nint n = nums.size();\nvector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(sum + 1, 0));\n// if sum = 0 then empty set is good\nfor (int i = 0; i &lt;= n; i++) {\ndp[i][0] = 1;\n}\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 0; j &lt;= sum; j++) {  // starting from j = 0 because there can be element\n// 0 that can be added into the subsets to achieve 0 sum.\nif (j - nums[i - 1] &gt;= 0) {\ndp[i][j]=dp[i-1][j] + dp[i-1][j-nums[i-1]];\n} else {\ndp[i][j] = dp[i - 1][j];\n}\n}\n}\nreturn dp[n][sum];\n}\npublic:\nint findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\nif (nums.size() == 1) {\n// base case\nif (abs(nums[0]) == abs(target)) return 1;\nelse return 0;\n}\nreturn countSubsetSumDifference(nums, target);\n}\n};\n</code></pre>"},{"location":"dp/problems/","title":"Dynamic programming","text":"<p>There is a famous quote saying that \"those who don't remember the past are condemned to repeat it\". This quote very much synchronizes with the meaning of dynamic programming. What in dynamic programming you do is you calculate and remember the calculation, if and when the same calculation is encountered again, instead of recomputing it you fetch the data this reducing computing time.</p> <p>There are several problems where you are required to calculate something multiple times and if you cache the data then you can avoid computation multiple times. Let's see some of the problems where you need to cache some result to avoid multiple computations.</p> <p>Table of Contents</p> <ol> <li>Climbing Stairs</li> <li>Frog Jump</li> <li>House Robber</li> <li>House Robber II</li> <li>Maximum Number of Jumps to Reach the Last Index</li> <li>Longest Palindromic Substring</li> <li>Palindromic Substrings</li> <li>Minimizing Coins</li> <li>Coin Combinations I</li> <li>Coin Combinations II</li> <li>Removing Digits</li> <li>Grid Paths</li> <li>Minimum Path Sum</li> <li>Longest increasing subsequence</li> <li>Edit distance</li> <li>Maximize the Profit as the Salesman</li> <li>Maximum Profit in Job Scheduling</li> </ol>"},{"location":"dp/problems/#climbing-stairs","title":"Climbing Stairs","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement","title":"Problem Statement","text":"<p>You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>"},{"location":"dp/problems/#example","title":"Example","text":"<pre><code>Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</code></pre>"},{"location":"dp/problems/#approach","title":"Approach","text":"<p>We are told that we can only reach to the top with once step or 2 step in the staircase. The number ways we can reach to the top is exactly the number of ways we can reach to the \\(n -1^{th}\\) step \\(+\\) number of ways we can reach to the \\(n -2^{nd}\\) step. So we quickly write a recursive function and will only compute if not aready computed.</p>"},{"location":"dp/problems/#code","title":"Code","text":"<pre><code>class Solution {\nprivate:\nunordered_map&lt;int, int&gt; mp;\npublic:\nint climbStairs(int n) {\nif (n &lt;= 2) return n;\nif (mp.find(n) == mp.end()) {\nint ways = climbStairs(n-2) + climbStairs(n-1);\nmp.insert({n, ways});\n} return mp[n];\n}\n};\n</code></pre>"},{"location":"dp/problems/#time-complexity","title":"Time Complexity","text":"<p>The algorithm runs in \\(O(N)\\) time and with <code>O(N)</code> memory from the <code>unordered_map</code> and also takes extra auxiliary space due to recursive implementation.</p>"},{"location":"dp/problems/#frog-jump","title":"Frog Jump","text":"<p>Find the Problem on Codestudio</p>"},{"location":"dp/problems/#problem-statement_1","title":"Problem Statement","text":"<p>There is a frog on the 1st step of an \\(N\\) stairs long staircase. The frog wants to reach the \\(N^{th}\\) stair. <code>HEIGHT[]</code> is the height of the (i+1)th stair.If Frog jumps from ith to jth stair, the energy lost in the jump is given by <code>HEIGHT[i-1] - HEIGHT[j-1]</code>. </p> <p>In the Frog is on ith staircase, he can jump either to \\((i+1)^{th}\\) stair or to \\((i+2)^{th}\\) stair. Your task is to find the minimum total energy used by the frog to reach from 1st stair to \\(N^{th}\\) stair.</p>"},{"location":"dp/problems/#approach_1","title":"Approach","text":"<ul> <li>We'll be using normal Dynamic Programming approach. We'll manually hard code the cost of moving for 0th (index which is 0) and 1st index (which is \\(\\text{heights[0] - heights[1]}\\)).</li> <li>Then for each \\(i\\) we'll see the result for \\(i-1\\) and \\(i-2\\) and select the step that uses less energy.</li> <li>We update the energy lost at step \\(i\\) then go to step \\(i+1\\).</li> <li>We don't have to store the \\([0 \\to i]\\) step costs because we are using only \\(i-1\\) and \\(i-2\\) values at any given \\(i\\). So a \\(2\\) element array or a <code>pair&lt;int, int&gt;</code> is enough.</li> </ul>"},{"location":"dp/problems/#code_1","title":"Code","text":"<pre><code>#include &lt;unordered_map&gt;\nint frogJump(int n, vector&lt;int&gt; &amp;heights) {\n// Write your code here.\nint energy_lost = 0;\npair&lt;int, int&gt; store;\nstore.first = 0;\nstore.second = std::abs(heights[1] - heights[0]);\nfor (int i=2; i&lt;n; i++) {\nint oneStepCost = store.second + std::abs(heights[i] - heights[i-1]);\nint twoStepCost = store.first + std::abs(heights[i] - heights[i-2]);\nint energyLostNow = std::min(oneStepCost, twoStepCost);\nstore.first = store.second;\nstore.second = energyLostNow;\n}\nreturn store.second;\n}\n</code></pre>"},{"location":"dp/problems/#time-complexity_1","title":"Time Complexity","text":"<p>The algorithm runs in \\(O(N)\\) time and with no extra memory.</p>"},{"location":"dp/problems/#house-robber","title":"House Robber","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_2","title":"Problem Statement","text":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p> <p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>"},{"location":"dp/problems/#examples","title":"Examples","text":"<pre><code>Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</code></pre>"},{"location":"dp/problems/#approach_2","title":"Approach","text":"<p>We'll be using a DP apporach to solve this problem, the main objective is to come up with some recursive solution standing at the \\(i^{th}\\) location. So let's build an intuition around that,</p> <p>For location \\(i = 0\\) you only can rob the \\(0^{th}\\) house, and standing at the \\(1^{st}\\) house you can either rob the \\(0^{th}\\) house and skip the \\(1^{st}\\) house or skip the \\(0^{th}\\) house and rob the \\(1^{st}\\) house whichever gives more profit. So we'll do the following, we'll indicate for index \\(i -1\\) a map <code>m</code> which will show what could have been the maximum profit we could make till \\(i-1\\) index.</p> <p>Depending upon the choice at index \\(i\\) we'll update the maximum profit we can make till this location \\(i\\).</p> <p>What are the decisions you need to make before you can make a move at location \\(i\\)? The question can be answered by looking at the \\(i-1^{th}\\) location see what is the maximum you can make till \\(i-1\\). Then you either skip this location and make a move at the next location or make a move at this location and skip the next location. Take whatever maximizes the profit.</p> <ul> <li>So profit till \\(0\\) will be <code>nums[0]</code></li> <li>profits till \\(1\\) will be <code>std::max(nums[0], nums[1])</code></li> <li>Profits at location \\(2\\) will be the following<ul> <li>Either you take the profit from the \\(0^{th}\\) index and rob the \\(2^{nd}\\) location</li> <li>or you take the profit till the \\(1^{st}\\) location and skip the second location.</li> </ul> </li> <li>\\(\\forall x \\in [0, \\text{nums.size})\\) we'll see what is maximum between the following two <code>profits[i-1]</code> and <code>profits[i-2] + nums[i]</code>. We'll take the maximum and put in the profits map or array.</li> </ul>"},{"location":"dp/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nint rob(vector&lt;int&gt;&amp; nums) {\nint size = nums.size();\n// base cases are trivially solvable\nif (size == 1) return nums[0];\nif (size == 2) return std::max(nums[0], nums[1]);\nif (size == 3) return std::max(nums[0] + nums[2], nums[1]);\npair&lt;int, int&gt; profits;\nprofits.first = nums[0];\nprofits.second = std::max(nums[0], nums[1]);\nfor (int i=2; i&lt;nums.size(); i++) {\nint max_profit_possible = std::max(profits.first + nums[i], profits.second);\nprofits.first = profits.second;\nprofits.second = max_profit_possible;\n}\nreturn profits.second;\n}\n};\n</code></pre>"},{"location":"dp/problems/#time-complexity_2","title":"Time Complexity","text":"<p>The algorithm runs in \\(O(N)\\) time and with no extra memory.</p>"},{"location":"dp/problems/#house-robber-ii","title":"House Robber II","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_3","title":"Problem Statement","text":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</p> <p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>"},{"location":"dp/problems/#approach_3","title":"Approach","text":"<p>The approach is similar to the last problem, there the last house was not connected to the first house. What we'll do in the problem is considering the first (\\(0^{th}\\)) house we'll calculate the profits, and not considering the first (\\(0^{th}\\)) house we'll calculate the profits, the we'll return the maximum.</p> <p>If we consider the first (\\(0^{th}\\)) house then we should never consider the last house so we ignore the last house. For the case when we do not consider the first (\\(0^{th}\\)) house, we must ignore the first (\\(0^{th}\\)) house explicitly. To do that we set <code>profits[0] = 0</code> and <code>profits[1] = nums[1]</code>, this forces the algorithm to drop the first (\\(0^{th}\\)) house.</p> <p>We'll also force the algorithm to take the first (\\(0^{th}\\)) house by setting <code>profits[0] = nums[0]</code> and <code>profits[1] = nums[0]</code>.</p>"},{"location":"dp/problems/#code_3","title":"Code","text":"<pre><code>class Solution {\npublic:\nint rob(vector&lt;int&gt;&amp; nums) {\nint size = nums.size();\n// base cases trivially solvable\nif (size == 1) return nums[0];\nif (size == 2) return std::max(nums[0], nums[1]);\nif (size == 3) return std::max(nums[0] + nums[2], nums[1]);\n// forcing the algorithm to take the 0th house\npair&lt;int, int&gt; profits;\nprofits.first = nums[0];\nprofits.second = nums[0];\n// profits considering 0th index\n// if we consider the 0th index then we can not rob the last index\n// so we run the algorithm till size - 2\nfor (int i=2; i&lt;=size-2; i++) {\nint max_profit_so_far = std::max(profits.first + nums[i], profits.second);\nint temp = profits.second;\nprofits.second = max_profit_so_far;\nprofits.first = temp;\n}\n// profits not considering the 1st index\n// forcing algorithm to not take the 0th house\npair&lt;int, int&gt; profits2;\nprofits2.first = 0;\nprofits2.second = nums[1];\n// profits not considering 0th index\n// if we do not consider the 0th index then we can rob the last index\n// so we run the algorithm till the last index\nfor (int i=2; i&lt;size; i++) {\nint max_profit_so_far = std::max(profits2.first + nums[i], profits2.second);\nint temp = profits2.second;\nprofits2.second = max_profit_so_far;\nprofits2.first = temp;\n}\nreturn std::max(profits.second, profits2.second);\n}\n};\n</code></pre>"},{"location":"dp/problems/#time-complexity_3","title":"Time Complexity","text":"<p>The algorithm runs in \\(O(N)\\) time and with no extra memory.</p>"},{"location":"dp/problems/#maximum-number-of-jumps-to-reach-the-last-index","title":"Maximum Number of Jumps to Reach the Last Index","text":"<p>You are given a 0-indexed array nums of n integers and an integer target.</p> <p>You are initially positioned at index 0. In one step, you can jump from index \\(i\\) to any index \\(j\\) such that:</p> <ol> <li>\\(i &lt; j\\) and</li> <li>\\(\\textsf{abs}(\\textsf{nums}[i] - \\textsf{nums}[j]) \\leq \\textsf{target}\\)</li> </ol>"},{"location":"dp/problems/#examples_1","title":"Examples","text":"<pre><code>Input: nums = [1,3,6,4,1,2], target = 2\nOutput: 3\nExplanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1. \n- Jump from index 1 to index 3.\n- Jump from index 3 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3. \n---\n\nInput: nums = [1,3,6,4,1,2], target = 3\nOutput: 5\nExplanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1.\n- Jump from index 1 to index 2.\n- Jump from index 2 to index 3.\n- Jump from index 3 to index 4.\n- Jump from index 4 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5.\n---\n\nInput: nums = [1,3,6,4,1,2], target = 0\nOutput: -1\nExplanation: It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1. \n</code></pre>"},{"location":"dp/problems/#code_4","title":"Code","text":"<pre><code>class Solution {\npublic:\nint maximumJumps(vector&lt;int&gt;&amp; nums, int target) {\nint n = nums.size();\nint dp[n]; // dp[i] = maximumJumps to reach location i.\nmemset(dp, -1, sizeof(dp));\ndp[0] = 0;\nfor (int i = 0; i &lt; n; i++) {\nif (dp[i] == -1) continue;\nfor (int j = i + 1; j &lt; n; j++) {\nif (abs(nums[i] - nums[j]) &lt;= target) {\ndp[j] = std::max(dp[j], 1 + dp[i]);\n}\n}\n}\nreturn dp[n - 1];\n}\n};\n</code></pre>"},{"location":"dp/problems/#longest-palindromic-substring","title":"Longest Palindromic Substring","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_4","title":"Problem Statement","text":"<p>Given a string s, return the longest palindromic substring in s.</p>"},{"location":"dp/problems/#examples_2","title":"Examples","text":"<pre><code>Input: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n</code></pre>"},{"location":"dp/problems/#approach_4","title":"Approach","text":"<ul> <li>We'll make a 2D array called <code>dp</code>, now for each entry \\((i, j)\\) in <code>dp</code> shows whether from \\(i \\to j\\) is a palindromic substring or not and what is the size of that pallindrome?</li> <li>First for all entries \\((i, j)\\) in <code>dp</code> such that \\(i = j\\) is a palindromic substring because one character word is always a pallindrome.</li> <li>Now we'll move diagonally right next from the main diagonal. Look at the below picture to understand how are we moving?     </li> <li>So we need to design the for loops accordingly. If we look closely to the change of \\((i, j)\\) we'll see that each time \\(i\\) start from \\(0\\) and \\(j\\) starts from \\(i + \\text{some number}\\), that some number is increasing by \\(1\\) every iteration.</li> <li>First iteration \\(i\\) starts from \\(0\\) and \\(j\\) starts from \\(i + 1\\) and then in the next iteration \\(i\\) again starts from \\(0\\) and \\(j\\) starts from \\(i + 2\\) and so on. So we can design the for loops accordingly.</li> <li>Now standing at some location \\((i, j)\\) meaning looking at the string from \\(i \\to j\\) we need to decide whether it is a pallindrome or not? If the characters \\(s[i] = s[j]\\) means it is a pallindrome if and only if the substring \\(s[i+1 \\, \\to \\, j-1]\\) is a palindrome. this item \\(s[i+1 \\, \\to \\, j-1]\\) can be reused to avoid further computation.</li> </ul>"},{"location":"dp/problems/#code_5","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint max_length = INT_MIN;\npair&lt;int, int&gt; indexOfMax;\npublic:\nstring longestPalindrome(string s) {\nint size = s.size();\n// base cases are trivially solvable\nif (size == 1) return s;\nif (size == 2) {\nif (s[0] == s[1]) return s;\n}\nif (size == 3) {\nif (s[0] == s[2]) return s;\n}\n// our storage is dp of size n x n\nvector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, 0));\n// all the size one character is a pallindrome so mark 1\nfor (int i=0; i&lt;size; i++) {\ndp[i][i] = 1;\n}\n// now we update the following pattern\n// 00 11 22 33 44 .. done\n// 10 21 32 43 54 .. \nfor (int diff = 1; diff&lt;size; diff++) {\nfor (int i=0, j=i+diff; j&lt;size; i++, j++) {\nif (s[i] == s[j]) {\n// means the last 2 elements are similar\nif (std::abs(i - j) == 1) {\n// means there is no extra element b/w\n// s[i] and s[j] they are together\n// so from i to j it is pallindrome\ndp[i][j] = 2;\nif (dp[i][j] &gt; max_length) {\nindexOfMax.first = i;\nindexOfMax.second = j;     max_length = dp[i][j];\n}\n} else {\n// means there is some elements b/w i and j\n// check they are pallindrome or not?\nif (dp[i+1][j-1] != 0) {\ndp[i][j] = dp[i+1][j-1] + 2;\nif (dp[i][j] &gt; max_length) {\nindexOfMax.first = i;\nindexOfMax.second = j;\nmax_length = dp[i][j];\n}\n} else {\ndp[i][j] = 0;\n}\n}\n} else {\n// means it is not pallindrome\ndp[i][j] = 0;\n}\n}\n}        // max size of the pallindrome is stored at indexOfMax;\n// the pallindrome is starting from indexOfMax.first to indexOfMax.second;\n// return this\nvector&lt;char&gt; result;\nfor (int i=indexOfMax.first; i&lt;=indexOfMax.second; i++) {\nresult.push_back(s[i]);\n}\nstring s1(result.begin(), result.end());\nreturn s1;\n}\n};\n</code></pre>"},{"location":"dp/problems/#palindromic-substrings","title":"Palindromic Substrings","text":"<p>Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.</p>"},{"location":"dp/problems/#examples_3","title":"Examples","text":"<pre><code>Input: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\n\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n</code></pre>"},{"location":"dp/problems/#approach_5","title":"Approach","text":"<ul> <li>The solution is almost similar to the last problem where we were required to find the longest size of the pallindrome, for that we constructed a two dimensional array <code>dp</code> to store for all possible values of \\((i, j)\\) if there exists a pallindrome or not?</li> <li>Then we found what is the maximum of them and returned it.</li> <li>But where we are required to find the number of such palindromic sub-strings. So our <code>dp</code> array indicates for each \\((i, j)\\) such that \\(i&lt;j\\) \\(\\exists\\) a pallindrome between \\(s[i \\to j]\\). So if we count the number of non zero entries in the <code>dp</code> array we'll find the number of possible substrings in the string.</li> </ul> <p>As we can see every non zero entry in the array <code>dp</code> shows us a unique substring that is a pallindrome between \\(i \\to j\\).</p>"},{"location":"dp/problems/#code_6","title":"Code","text":"<pre><code>class Solution {\npublic:\nint countSubstrings(string s) {\nint size = s.size();\nvector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, 0));\nfor (int i=0; i&lt;size; i++) {\ndp[i][i] = 1;\n}\n// go over the dp array to get the dp matrix sorted\nfor (int diff = 1; diff&lt;size; diff++) {\nfor(int i=0, j=i+diff; j&lt;size; i++, j++) {\nif (s[i] == s[j]) {\nif (std::abs(i - j) == 1) {\ndp[i][j] = 2;\n} else {\nif (dp[i+1][j-1] != 0) dp[i][j] = dp[i+1][j-1] + 2;\nelse dp[i][j] = 0;\n}\n} else {\ndp[i][j] = 0;\n}\n}\n}\n// check how many entries are non zero\nint counter = 0;\nfor (int i=0; i&lt;size; i++) {\nfor (int j=0; j&lt;size; j++) {\nif (dp[i][j] != 0) counter++;\n}\n}\nreturn counter;\n}\n};\n</code></pre>"},{"location":"dp/problems/#minimizing-coins","title":"Minimizing Coins","text":"<p>Find the problem on CSES \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_5","title":"Problem Statement","text":"<p>Consider a money system consisting of \\(n\\) coins. Each coin has a positive integer value. Your task is to produce a sum of money \\(x\\) using the available coins in such a way that the number of coins is minimal.</p> <p>For example, if the coins are \\(\\{1,5,7\\}\\) and the desired sum is \\(11\\) an optimal solution is \\(5+5+1\\) which requires \\(3\\) coins.</p> <p>Input Format The first input line has two integers n and x: the number of coins and the desired sum of money. The second line has n distinct integers \\(c_1,c_2,\\dots,c_n\\) the value of each coin.</p> <p>Output Format Print one integer: the minimum number of coins. If it is not possible to produce the desired sum, print -1.</p>"},{"location":"dp/problems/#example_1","title":"Example","text":"<p>Input: <pre><code>3 11\n1 5 7\n</code></pre> Output: <pre><code>3\n</code></pre></p>"},{"location":"dp/problems/#apporach","title":"Apporach","text":"<p>We need to build a \\(\\text{dp}\\) vector. \\(\\text{dp[}i\\text{]}\\) will indicate minimum number of coins that will be required to get the value \\(i\\). So trivially \\(\\text{dp}[0] = 0\\).</p> <p>Now from \\(1 \\to \\text{target}\\) we'll check what is the minimum number of coins that will be required to get that value. If we look closely then we'll find that for any given \\(i\\): \\(\\text{dp[}i\\text{]} = \\text{Min(dp[i], dp[i - coin])}\\) for each of the coins in the coin bag. So mathematically we can write</p> \\[ dp[i] = \\left\\{     \\begin{array}{ll}         \\infty  &amp; \\mbox{if } i &lt; 0 \\\\         0 &amp; \\mbox{if } i = 0 \\\\         \\text{min}_{c \\in \\{c_1, c_2, \\dots, c_n\\}} dp[i - c] + 1 &amp; \\mbox{if } i &gt; 0     \\end{array} \\right. \\] <p>Hence the solution below:</p>"},{"location":"dp/problems/#c-code","title":"C++ Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nint findMinNumberOfCoins(vector&lt;int&gt; &amp;coinStore, int target) {\nvector&lt;int&gt; dp(target + 1, 1e9); // dp[i] is the minimum number of coins to get target i\ndp[0] = 0;                       // to get 0 as target we need 0 coins &lt;- base case\nfor (int i = 1; i &lt;= target; i++) {\n// loop over all the coins\nfor (auto coin : coinStore) {\nif (i - coin &lt; 0) {\nbreak;\n}\ndp[i] = std::min(dp[i], dp[i - coin] + 1);\n}\n}\nreturn (dp[target] == 1e9) ? -1 : dp[target];\n}\nint main() {\n// have coins, and a target\n// find what is the min coins to take for the target\nint coins, target;\ncin &gt;&gt; coins &gt;&gt; target;\nvector&lt;int&gt; coinStore;\nwhile (coins--) {\nint coin;\nstd::cin &gt;&gt; coin;\ncoinStore.push_back(coin);\n}\nstd::sort(coinStore.begin(), coinStore.end());\ncout &lt;&lt; findMinNumberOfCoins(coinStore, target) &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#coin-combinations-i","title":"Coin Combinations I","text":"<p>Find the problem on CSES \\(\\to\\)</p> <p>Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins.</p> <p>For example, if the coins are \\(\\{2,3,5\\}\\) and the desired sum is 9 then there are \\(8\\) ways.</p>"},{"location":"dp/problems/#approach_6","title":"Approach","text":"<p>Suppose \\(dp[i]\\) is such that it defines to get \\(i\\) value how many ways there is? So trivially \\(dp[0] = 1\\) for any given set of coins \\(c_1, \\dots c_n\\). Now for any \\(i \\in \\mathbb{N}\\), \\(dp[i]\\) should be defined as follows</p> \\[ dp[i] = \\left\\{     \\begin{array}{ll}         0  &amp; \\mbox{if } i &lt; 0 \\\\         1 &amp; \\mbox{if } i = 0 \\\\         \\displaystyle\\sum_{c \\in \\{c_1, c_2, \\dots, c_n\\}} dp[i - c] &amp; \\mbox{if } i &gt; 0 \\text{ and }  i - c &gt; 0     \\end{array} \\right. \\] <p>Let's see why \\(\\displaystyle\\sum_{c \\in \\{c_1, c_2, \\dots, c_n\\}} dp[i - c]\\) holds. For the target \\(i\\) and \\(i &gt; 0\\) the number of ways to get to \\(i\\) is number of ways to get to \\(i-c\\) for each of the coins in \\(\\{c_1, c_2, \\dots, c_n\\}\\). Hence we get the sum. The following is a code example working with this idea.</p>"},{"location":"dp/problems/#code_7","title":"Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nlong long int findNumberOfWaysToGetTarget(int target, vector&lt;long long int&gt; &amp;coinStore) {\nvector&lt;long long int&gt; dp(target + 1, 0); // set all to 0 first, dp[i] represents ways to get i target via coinStore\ndp[0] = 1;                               // base case only 1 way to get 0 with {coinStore}\nfor (int i = 1; i &lt;= target; i++) {\nfor (int coin : coinStore) {\nif (i - coin &gt;= 0) {\ndp[i] += dp[i - coin];\ndp[i] = dp[i] % MOD;\n}\n}\n}\nreturn dp[target];\n}\nvoid fileIO() {\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\n}\nint main() {\nint number_of_coins, target;\nvector&lt;long long int&gt; coins;\ncin &gt;&gt; number_of_coins &gt;&gt; target;\nwhile (number_of_coins--) {\nlong long int coin;\ncin &gt;&gt; coin;\ncoins.push_back(coin);\n}\ncout &lt;&lt; findNumberOfWaysToGetTarget(target, coins) &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#coin-combinations-ii","title":"Coin Combinations II","text":"<p>Find the problem on CSES \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Same as the above problem statement but here we need to find unique solutions.</p>"},{"location":"dp/problems/#approach_7","title":"Approach","text":"<p>In the last problem we were required to find all possible ways to get to the target, so \\(dp[i]\\) was defining all the possible way we can get to the target \\(i\\). Then we did a traversal over all the coin \\(c \\in \\{c_1, c_2, \\dots, c_n\\}\\) and find out \\(dp[i]\\) as \\(\\displaystyle\\sum_{c \\in \\{c_1, c_2, \\dots, c_n\\}} dp[i - c]\\). This way considering coin \\(c\\) we added all the possibilities from \\(dp[i - c]\\).</p> <p>But here we are required to find all possible ways but those should be unique, meaning \\(5 + 5 + 1\\) is same as \\(1 + 5 + 5\\) and \\(5 + 1 + 5\\). These three are not distinct cases these three are unique cases.</p> <p>To use only distinct combinations of coins what we can do is loop over all the coins \\(c \\in \\{c_1, c_2, \\dots, c_n\\}\\), for each of the coin we set \\(dp[i]\\) as \\(dp[i] + dp[i-c]\\). Thus we'll loop over coins in order \\(c \\in \\{c_1,c_2, \\dots, c_n\\}\\) thus using unqiue combinations of coins \\(\\{c_i \\mid i \\in \\{1, \\dots, n\\}\\}\\).</p>"},{"location":"dp/problems/#code_8","title":"Code","text":"<p>The code is the exact same as the last problem, with slight changes made to the nesting of the for loops. The outer for loop of target is now inside the loop of coins in the coin store.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nlong long int findNumberOfWaysToGetTarget(int target, vector&lt;long long int&gt; &amp;coinStore) {\nvector&lt;long long int&gt; dp(target + 1, 0); // set all to 0 first, dp[i] represents ways to get i target via coinStore\ndp[0] = 1;                               // base case only 1 way to get 0 with {coinStore}\nfor (int coin : coinStore) {\nfor (int i = 1; i &lt;= target; i++) {\nif (i - coin &gt;= 0) {\ndp[i] += dp[i - coin];\ndp[i] = dp[i] % MOD;\n}\n}\n}\nreturn dp[target];\n}\nvoid fileIO() {\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\n}\nint main() {\nint number_of_coins, target;\nvector&lt;long long int&gt; coins;\ncin &gt;&gt; number_of_coins &gt;&gt; target;\nwhile (number_of_coins--) {\nlong long int coin;\ncin &gt;&gt; coin;\ncoins.push_back(coin);\n}\ncout &lt;&lt; findNumberOfWaysToGetTarget(target, coins) &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#removing-digits","title":"Removing Digits","text":"<p>Find the problem on CSES \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_7","title":"Problem Statement","text":"<p>You are given an integer n. On each step, you may subtract one of the digits from the number. How many steps are required to make the number equal to \\(0\\).</p>"},{"location":"dp/problems/#example_2","title":"Example","text":"<p>Suppose the given number is 27, then the optimal number of digit removal is 5. The optimal solution is the following \\(27 \\rightarrow 20 \\rightarrow 18 \\rightarrow 10 \\rightarrow 9 \\rightarrow 0\\).</p>"},{"location":"dp/problems/#approach_8","title":"Approach","text":"<p>We'll do a recursive apporach on this problem, the intuition for the recursive solution is really easy to understand. For a given number \\(i\\), we'll first find out what are the individual digits of this number. Then what we do is find out recursivly what is the minimum number of removals required accoss all the (number - digit) + 1.</p> <p>For example what we do is for \\(27\\) we'll find out what is minimum between \\(27 - 7\\) and \\(27 - 2\\) then add \\(1\\). We have to make sure that we don't do this for digit \\(0\\). Hence the solution is the following.</p>"},{"location":"dp/problems/#code_9","title":"Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt;\nusing namespace std;\nvector&lt;int&gt; getIndividualDigits(int number) {\nvector&lt;int&gt; digits;\nwhile (number &gt; 0) {\ndigits.push_back(number % 10);\nnumber /= 10;\n}\nreturn digits;\n}\nint findMinimumNumberOfSubtractions(int number, unordered_map&lt;int, int&gt; &amp;store) {\n// if already present then find and return\nif (number == 0) return 0;\nif (store.find(number) != store.end()) {\nreturn store[number];\n}\nvector&lt;int&gt; individualDigits = getIndividualDigits(number);\nint minimumNumberOfSubtractions = INT_MAX;\nfor (auto digit:individualDigits) {\nif (digit) minimumNumberOfSubtractions = std::min(findMinimumNumberOfSubtractions(number - digit, store), minimumNumberOfSubtractions);\n}\nstore[number] = minimumNumberOfSubtractions + 1;\nreturn store[number];\n}\nint main() {\nint number;\ncin &gt;&gt; number;\nunordered_map&lt;int, int&gt; store;\ncout &lt;&lt; findMinimumNumberOfSubtractions(number, store);\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#iterative-version-of-the-algorithm","title":"Iterative version of the algorithm","text":"<pre><code>int findMinimumNumberOfSubtractionsIterative(int number) {\nvector&lt;int&gt; dp(number+1, 0);\ndp[0] = 0;\nfor (int i=1; i&lt;=number; i++) {\nvector&lt;int&gt; individualDigits = getIndividualDigits(i);\nint minNumberOfSubtractions = INT_MAX;\nfor (int d: individualDigits) {\nif (d) minNumberOfSubtractions = std::min(minNumberOfSubtractions, dp[i - d]);\n}\ndp[i] = minNumberOfSubtractions + 1;\n}\nreturn dp[number];\n}\n</code></pre>"},{"location":"dp/problems/#grid-paths","title":"Grid Paths","text":"<p>Find the problem on CSES \\(\\rightarrow\\)</p>"},{"location":"dp/problems/#problem-statement_8","title":"Problem Statement","text":"<p>Consider an \\((n, n)\\) grid whose squares may have traps. It is not allowed to move to a square with a trap. Your task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.</p>"},{"location":"dp/problems/#example_3","title":"Example","text":"<p>We should print the number of paths modulo \\(10^9 + 7\\)</p>"},{"location":"dp/problems/#inputoutput-example","title":"Input/Output example","text":"<pre><code>Input:\n4\n....\n.*..\n...*\n*...\n\nOutput: 3\n</code></pre>"},{"location":"dp/problems/#approach_9","title":"Approach","text":"<p>We find out a simple recursive equation to find out what is the number of ways to move to \\((n, n)\\) square.</p> <p>Suppose we define \\(dp[i][j]\\) as number of ways to move to \\((n, n)\\) from location \\((i, j)\\) in the grid. Then our solution is \\(dp[0][0]\\). The base case here is at location \\((n, n)\\). Then \\(dp[n][n] = 1\\). We can easily see that the solution for any location \\((i, j)\\) is</p> \\[ dp[i][j] = \\left\\{     \\begin{array}{ll}         0  &amp; \\mbox{if } i, j \\text{ is out of bounds of the grid}\\\\         0  &amp; \\mbox{if } \\text{ grid[i][j] is a * (obstacle)}\\\\         1 &amp; \\mbox{if } (i, j) = (n, n) \\\\         dp[i + 1][j] + dp[i][j + 1] &amp; \\mbox{Otherwise}     \\end{array} \\right. \\] <p>Here \\(dp[i + 1][j] + dp[i][j + 1]\\) denotes number of ways to get from position \\((i + 1, j)\\) to \\((n, n)\\) and \\((i, j + 1)\\) to \\((n, n)\\) if \\((i, j)\\) is within the grid bounds, 0 otherwise.</p>"},{"location":"dp/problems/#code_10","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nlong long MOD = 1e9 + 7;\nusing std::cout;\nusing std::endl;\nint main() {\nint size;\nstd::cin &gt;&gt; size;\nint grid[size][size];\nint row = 0;\nwhile (row &lt; size) {\nint col = 0;\nwhile (col &lt; size) {\nchar block;\nstd::cin &gt;&gt; block;\nif (block == '.') {\ngrid[row][col] = 0;\n} else {\ngrid[row][col] = 1;\n}\ncol++;\n}\nrow++;\n}\nlong long int dp[size][size];\nif (grid[size - 1][size - 1] == 0) {\ndp[size - 1][size - 1] = 1; // trivial to go from size:size to size:size\n} else {\ncout &lt;&lt; 0 &lt;&lt; endl;\n// exit program\nreturn 0;\n}\nfor (int r = size - 1; r &gt;= 0; r--) {\nfor (int c = size - 1; c &gt;= 0; c--) {\nif ((r == size - 1 and c == size - 1))\ncontinue;\nlong long int down = (r + 1 &gt;= size) ? 0 : dp[r + 1][c];\nlong long int right = (c + 1 &gt;= size) ? 0 : dp[r][c + 1];\ndp[r][c] = down + right;\ndp[r][c] = dp[r][c] % MOD;\nif (grid[r][c])\ndp[r][c] = 0;\n}\n}\ncout &lt;&lt; dp[0][0] &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#minimum-path-sum","title":"Minimum Path Sum","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/problems/#problem-statement_9","title":"Problem Statement","text":"<p>Given a \\((m, n)\\) grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p> <p>Note: You can only move either down or right at any point in time.</p>"},{"location":"dp/problems/#example_4","title":"Example","text":"<pre><code>Input: \ngrid = \n[\n    [1,3,1],\n    [1,5,1],\n    [4,2,1]\n]\n\nOutput: 7\nExplanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n</code></pre> <pre><code>Input: grid = \n[\n    [1,2,3],\n    [4,5,6]\n]\n\nOutput: 12\n</code></pre>"},{"location":"dp/problems/#approach_10","title":"Approach","text":"<p>The approach is similar to the last problem. We'll go from \\((0, 0) \\to (m, n)\\) location of the grid row by row and column by column. For any given location \\((i, j)\\) we'll define a store \\(dp[i][j]\\) such that \\(dp[i][j]\\) indicates what is the minimum path sum to reach location \\((i, j)\\). Hence the solution should be \\(dp[m - 1][n - 1]\\).</p> <p>Our recurrence relation is the following</p> \\[ dp[i][j] = \\left\\{     \\begin{array}{ll}         0  &amp; \\mbox{if } i = 0, j = 0\\\\         10^9 \\text{ or } \\infty  &amp; \\mbox{if } (i,j) \\text{ is out of bounds}\\\\         \\min(dp[i - 1][j], dp[i][j - 1]) + \\text{grid}[i][j]&amp; \\mbox{Otherwise}     \\end{array} \\right. \\]"},{"location":"dp/problems/#code_11","title":"Code","text":"<pre><code>class Solution {\npublic:\nint minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\nint rows = grid.size();\nint cols = grid[0].size();\nint dp[rows][cols];\nmemset(dp, 0, sizeof(dp));\ndp[0][0] = grid[0][0];\nfor (int i = 0; i &lt; rows; i++) {\nfor (int j = 0; j &lt; cols; j++) {\nif (not i and not j) continue;\nint left = (j - 1 &gt;= 0) ? dp[i][j-1] : 1e9;\nint up = (i - 1 &gt;= 0) ? dp[i-1][j] : 1e9;\ndp[i][j] = std::min(left, up) + grid[i][j];\n}\n}\nreturn dp[rows - 1][cols - 1];\n}\n};\n</code></pre>"},{"location":"dp/problems/#longest-increasing-subsequence","title":"Longest increasing subsequence","text":"<ul> <li>Find the problem on Leetcode \\(\\to\\)</li> <li>Find the problem on CSES \\(\\to\\)</li> </ul>"},{"location":"dp/problems/#problem-statement_10","title":"Problem Statement","text":"<p>Given an integer array nums, return the length of the longest strictly increasing subsequence.</p>"},{"location":"dp/problems/#example_5","title":"Example","text":"<pre><code>Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n</code></pre>"},{"location":"dp/problems/#on2-approach","title":"\\(O(N^2)\\) approach","text":"<p>We define \\(dp[i]\\) as the length of the longest increasing subsequence till the index \\(i\\). So trivially we can compute \\(dp[i]\\) as the following, and our solution becomes \\(dp[n-1]\\) where \\(n\\) is the number of elements. But this \\(O(N^2)\\) approach will not be accepted</p> \\[ dp[i] = \\left\\{     \\begin{array}{ll}         1  &amp; \\mbox{if } i = 0\\\\         \\max_{j \\in \\{0, i - 1\\}}dp[j] + 1  &amp; \\mbox{Otherwise}     \\end{array} \\right. \\]"},{"location":"dp/problems/#code_12","title":"Code","text":"<pre><code>class Solution {\npublic:\nint lengthOfLIS(vector&lt;int&gt;&amp; nums) {\nint size = nums.size();\nvector&lt;int&gt; dp(size, 1);\ndp[0] = 1;\nfor (int i = 1; i&lt;size; i++) {\n// from j = i-1 till 0 what is the max then add 1\nfor (int j = i -1; j &gt;= 0; j--) {\nif (nums[i] &gt; nums[j]) {\ndp[i] = std::max(dp[i], dp[j] + 1);\n}\n}\n}\n// find max accoss all dp[i]\nint sol = dp[0];\nfor (int i=1; i&lt;size; i++) {\nsol = std::max(dp[i], sol);\n}\nreturn sol;\n}\n};\n</code></pre>"},{"location":"dp/problems/#edit-distance","title":"Edit distance","text":"<ul> <li>Find the problem on Leetcode \\(\\to\\)</li> <li>Find the problem on CSES Problem Set \\(\\to\\)</li> </ul>"},{"location":"dp/problems/#problem-statement_11","title":"Problem Statement","text":"<p>The edit distance between two strings is the minimum number of operations required to transform one string into the other.</p> <p>The allowed operations are: - Add one character to the string. - Remove one character from the string. - Replace one character in the string.</p> <p>For example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.</p> <p>Your task is to calculate the edit distance between two strings.</p> <p>Input</p> <p>The first input line has a string that contains n characters between A\u2013Z. The second input line has a string that contains m characters between A\u2013Z.</p> <p>Output</p> <p>Print one integer: the edit distance between the strings.</p>"},{"location":"dp/problems/#approach_11","title":"Approach","text":"<p>So we need to find the recurrence relation to solve this question. What we'd do is the following, we define \\(dp[i][j]\\) as the following, \\(dp[i][j]\\) is the minimum edit distance to go from string one [0 \\(\\dots\\) i] to string two [0 \\(\\dots\\) j].</p> <p>Given this we can say the following recurrence based on the following conditions</p> <ul> <li>If we add one character to string one then \\(dp[i][j]\\) becomes \\(dp[i][j - 1] + 1\\). We are adding one character to string one so \\(1\\) and as we are adding one character to string we need to consider \\(dp[i][j-1]\\) because \\(j^{\\text{th}}\\) character in string two would match with the character at i in string one then we need to move \\(j\\) one to the left.</li> <li>If we remove one character from string one then \\(dp[i][j]\\) becomes \\(dp[i - 1][j] + 1\\). We are removing one character from string one so \\(1\\) and removing one character from string one would mean that we need to check for the \\((i - 1)^{\\text{th}}\\) character in the first string with \\(j^{\\text{th}}\\) character in the second string.</li> <li>Otherwise if both are matching then we don't need to remove anything. If they are not matching and we replace then the cost becomes \\(dp[i-1][j - 1] + 1\\) if we replace the \\(i^{\\text{th}}\\) character in string one, otherwise \\(dp[i-1][j - 1] + 0\\).</li> <li>For base cases if string one or string two is empty then simply return the size of the other string.</li> </ul> <p>So in summary the following is the recurrence relation</p> \\[ dp[i][j] = \\left\\{     \\begin{array}{ll}         0 &amp; \\mbox{if } i \\&amp; j = 0\\\\         j &amp; \\mbox{if } i = 0\\\\         i &amp; \\mbox{if } j = 0\\\\         \\min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])  &amp; \\mbox{Otherwise}     \\end{array} \\right. \\]"},{"location":"dp/problems/#code_13","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;vector&gt;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nusing std::vector;\nint findMinimumEditDistace(string s1, string s2) {\nint s1Size = s1.size();\nint s2Size = s2.size();\n// dynamic programming storage\n// dp[i][j] defines what is the minimum edit distance to convert\n// from s1[0..i] to s2[0..j]\nint dp[s1Size + 1][s2Size + 1];\nmemset(dp, 0, sizeof dp);\n// base cases\nfor (int j = 0; j &lt;= s2Size; j++) {\n// all entries in dp[0][j] for j in (0 to s2.size())\ndp[0][j] = j;\n}\nfor (int i = 0; i &lt;= s1Size; i++) {\n// all entries in dp[0][j] for j in (0 to s2.size())\ndp[i][0] = i;\n}\nfor (int i = 1; i &lt;= s1Size; i++) {\nfor (int j = 1; j &lt;= s2Size; j++) {\nint costForRemovingLastFromS1 = dp[i - 1][j] + 1;\nint costForInsertingOneAtS1 = dp[i][j - 1] + 1;\nint costForReplacingAtLast = dp[i - 1][j - 1] + ((s1[i - 1] == s2[j - 1]) ? 0 : 1);\ndp[i][j] = std::min(costForRemovingLastFromS1, costForReplacingAtLast);\ndp[i][j] = std::min(costForInsertingOneAtS1, dp[i][j]);\n}\n}\nreturn dp[s1Size][s2Size];\n}\nint main() {\nstring s1;\nstring s2;\ncin &gt;&gt; s1;\ncin &gt;&gt; s2;\ncout &lt;&lt; findMinimumEditDistace(s1, s2);\nreturn 0;\n}\n</code></pre>"},{"location":"dp/problems/#maximize-the-profit-as-the-salesman","title":"Maximize the Profit as the Salesman","text":"<p>The next few questions are a part of Weighted Job Scheduling pattern. This is a famous dynamic programming pattern. Next we'll discuss that.</p>"},{"location":"dp/problems/#problem-statement_12","title":"Problem Statement","text":"<p>You are given an integer \\(n\\) representing the number of houses on a number line, numbered from \\(0\\) to \\(n - 1\\).</p> <p>Additionally, you are given a 2D integer array offers where \\(\\text{offers}[i] = \\{\\text{start}_i, \\text{end}_i, \\text{gold}_i\\}\\) indicating that \\(i^{\\text{th}}\\) buyer wants to buy all the houses from \\(\\text{start}_i \\to \\text{end}_i\\) for \\(\\text{gold}_i\\) amount of gold.</p> <p>As a salesman, your goal is to maximize your earnings by strategically selecting and selling houses to buyers.</p> <p>Return the maximum amount of gold you can earn.</p> <p>Note that different buyers can't buy the same house, and some houses may remain unsold.</p>"},{"location":"dp/problems/#examples_4","title":"Examples","text":"<pre><code>Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]\nOutput: 3\nExplanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.\nWe sell houses in the range [0,0] to 1st buyer for 1 gold and houses in the range [1,3] to 3rd buyer for 2 golds.\nIt can be proven that 3 is the maximum amount of gold we can achieve.\n---\n\nInput: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]\nOutput: 10\nExplanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.\nWe sell houses in the range [0,2] to 2nd buyer for 10 golds.\nIt can be proven that 10 is the maximum amount of gold we can achieve.\n</code></pre>"},{"location":"dp/problems/#approach_12","title":"Approach","text":"<p>The intuition behind this solution is to sort the offers by their starting positions and then use dynamic programming to compute the maximum profit that can be achieved while considering each offer.</p> <ol> <li>We start the process by sorting the offers based on their starting positions. This step ensures that the offers are considered in ascending order of their starting positions.</li> <li>Create a vector <code>first</code> to store the starting positions of each offer. This vector will help in finding the index of the next available offer for each offer.</li> </ol>"},{"location":"dp/problems/#maximum-profit-in-job-scheduling","title":"Maximum Profit in Job Scheduling","text":""},{"location":"dp/unbounded-knapsack/","title":"Knapsack (Unbounded) Pattern","text":"<p>These problems discussed below conform to one knapsack pattern called Unbounded Knapsack. Using solutions to the knapsack problem and a minor modification, you can solve almost all of the following problems. We'll discuss this as we explain the code and the approach to these problems.</p> <p>Problems Discussed</p> <ul> <li> The Unbounded Knapsack Problem</li> <li> Rod cutting</li> <li>Coin Change II</li> <li>Coin Change I (Unbounded Knapsack Way)</li> <li>Maximum Ribbon Cut</li> </ul>"},{"location":"dp/unbounded-knapsack/#the-unbounded-knapsack-problem","title":"The Unbounded Knapsack Problem","text":"<p>To recap in the \\(0/1\\) knapsack case we either include and item or not. Each item has one instance in the universe. Either we take one of e$$ach item in the bag or not. But in the unbounded knapsack case we can take any number of same item as we wish. Once we make a decision that we don't or we would take some element, we don't go back and rethink about it.</p> <p>Multiple occurences of same item is allowed. If at some time \\(t\\) we don't choose some element then we don't consider that element again (we call it processed). In \\(0/1\\) knapsack whether we consider it or not we call it processed (we don't reconsider). As here we can include that element multiple amount of time then we consider the element not processed if it is considered in the last decision.</p>"},{"location":"dp/unbounded-knapsack/#code-changes-from-01-knapsack","title":"Code changes from \\(0/1\\) knapsack","text":"<p>In \\(0/1\\) knapsack once we reject or accept an element we move onto the next element. This is shown in the following code</p> Recursion of 0/1 Knapsack<pre><code>if (wt[n - 1] &lt;= W) {\nreturn std::max(\nval[n - 1] + knapSack(W - wt[n-1], wt, val, n - 1),\nknapSack(W, wt, val, n - 1)\n);\n}\n// not include as capacity is lower\nreturn knapSack(W, wt, val, n - 1);\n</code></pre> <p>Lines 4, 9 is when we don't consider the element. When we don't consider the element knapsack and unbounded knapsack behaves the same. Hence we don't need any code changes there.</p> <p>In line \\(3\\) we are considering the inclusion of the element. Here we change the code for unbounded knapsack. Following is the code for \\(0/1\\) and unbounded knapsack solved with bottom up approach and their differences marked.</p> 0/1 Knapsack Code (Bottom Up)<pre><code>/* for all dp[i][j] */\nif (j &gt;= wt[i - 1]) {\ndp[i][j] = std::max(\ndp[i-1][j],  // not considering the i th element\ndp[i-1][j - wt[i-1]] + val[i-1] // considering the i th element\n);\n} else {\ndp[i][j] = dp[i-1][j]; // not considering the i th element\n}\n</code></pre> Unbounded Knapsack Code<pre><code>/* for all dp[i][j] */\nif (j &gt;= wt[i - 1]) {\ndp[i][j] = std::max(\ndp[i-1][j],  // not considering the i th element\ndp[i][j - wt[i-1]] + val[i-1] // considering the i th element\n);\n} else {\ndp[i][j] = dp[i-1][j]; // not considering the i th element\n}\n</code></pre> <p>Notice when including the element we do not change the <code>dp[i]</code>.</p>"},{"location":"dp/unbounded-knapsack/#rod-cutting","title":"Rod cutting","text":"<p>Asked in:  </p>"},{"location":"dp/unbounded-knapsack/#problem-statement","title":"Problem Statement","text":"<p>Given a rod of length \\(N\\) inches and an array of prices. \\(\\text{price}[i]\\) denotes the value of a piece of length \\(i\\). </p> <p>Determine the maximum value obtainable by cutting up the rod and selling the pieces.</p>"},{"location":"dp/unbounded-knapsack/#approach","title":"Approach","text":"<p>The approach is same as the unbounded knapsack problem. Think of the total bag weight as rod length \\(n\\), then you can cut any length \\(i\\) from \\(n\\) as long as it is possible. Think of cutting length \\(i\\) from \\(n\\) and putting it in a bag. The bag is the storage for all pieces. The pieces of the bag will determine the total profit which we have to maximize.</p>"},{"location":"dp/unbounded-knapsack/#code","title":"Code","text":"Rod cutting problem (bottom up approach)<pre><code>class Solution{\npublic:\nint cutRod(int price[], int n) {\n// dp[i][j] = considering the ith sized rod\n// and j total rod size, what is the max profit.\nint dp[n + 1][n + 1];\nmemset(dp, 0, sizeof(dp));\n// length of rod = 0; profit = 0;\nfor (int i = 0; i &lt;= n; i++) {\ndp[i][0] = 0;\ndp[0][i] = 0;\n}\n// dp table fillup\nfor (int i = 1; i &lt;= n; i++) {\nfor (int j = 1; j &lt;= n; j++) {\nif (i == 1) {\n// for required length = j\n// with i = 1 lenth pieces\n// total profit = j * {1st element price}\ndp[i][j] = j * price[0];\n} else {\nif (i &lt;= j) {\n// if the rod size is big enough to\n// have a cut of length[i] then consider the\n// ith element and reduce the rod size\ndp[i][j] = std::max(dp[i - 1][j], price[i - 1] + dp[i][j - i]);\n} else {\ndp[i][j] = dp[i - 1][j];\n}\n}\n}\n}\nreturn dp[n][n];\n}\n};\n</code></pre>"},{"location":"dp/unbounded-knapsack/#coin-change-ii","title":"Coin Change II","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"dp/unbounded-knapsack/#problem-statement_1","title":"Problem Statement","text":"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p> <p>Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.</p> <p>You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to fit into a signed 32-bit integer.</p>"},{"location":"dp/unbounded-knapsack/#approach_1","title":"Approach","text":"<p>This is a problem of unbounded knapsack. We have to count number of ways we can place coins to the amount. Think of <code>amount</code> as the bag size, and coins are each element with \\(v\\) profit, \\(v\\) is the value of the coin. Similar to unbounded knapsack we can put multiple instances of same coin and fill the bag up i.e, sum up to <code>amount</code>.</p>"},{"location":"dp/unbounded-knapsack/#code_1","title":"Code","text":"Coin Change II<pre><code>class Solution {\npublic:\nint change(int amount, vector&lt;int&gt;&amp; coins) {\nif (amount == 0) return 1;\nint size = coins.size();\nvector&lt;vector&lt;int&gt;&gt; dp(size + 1, vector&lt;int&gt;(amount + 1, 0));\nfor (int i = 0; i &lt;= size; i++) {\nfor (int j = 0; j &lt;= amount; j++) {\nif (j == 0) {\n// one way to select 0 amount from coins [select null set]\ndp[i][j] = 1;\n}\nif (i and j) {\ndp[i][j] = dp[i - 1][j];\nif (j - coins[i - 1] &gt;= 0) {\ndp[i][j] += dp[i][j - coins[i - 1]];\n}\n}\n}\n}\nreturn dp[size][amount];\n}\n};\n</code></pre>"},{"location":"dp/unbounded-knapsack/#coin-change-i-unbounded-knapsack-way","title":"Coin Change I (Unbounded Knapsack Way)","text":"<p>To solve the problem using most optimal way you can look \ud83d\udd17 here.</p> <p>Find the problem on leetcode \ud83d\udd17 and gfg \ud83d\udd17.</p>"},{"location":"dp/unbounded-knapsack/#problem-statement_2","title":"Problem Statement","text":"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p> <p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p> <p>You may assume that you have an infinite number of each kind of coin.</p>"},{"location":"dp/unbounded-knapsack/#approach_2","title":"Approach","text":""},{"location":"dp/unbounded-knapsack/#maximum-ribbon-cut","title":"Maximum Ribbon Cut","text":""},{"location":"graph/bfs-dfs/","title":"Breath first and depth-first search","text":"<p>BFS and DFS are two of the most common graph as well as tree traversal techniques that ever existed. You should always understand the basic understanding behind these traversals.</p>"},{"location":"graph/bfs-dfs/#things-to-remember-about","title":"Things to remember about","text":"<ul> <li>BFS uses a queue and FIFO ordering is something that it uses.</li> <li>DFS uses recursion, and recursively goes in-depth until the element is found.</li> </ul>"},{"location":"graph/bfs-dfs/#standard-graph-implementation","title":"Standard Graph implementation","text":"<p>We'll use our standard implementation for graphs and will write BFS and DFS to work on that standard graph.</p> <p>The following graph implementation may not be the very best implementation that you'll find, but it is good enough and most importantly you'll be able to implement this in an interview setting.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\nusing namespace std;\n// Directed graph implementation\nclass Graph{ private:\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; adj_list;\npublic:\nvoid add_edge(char vertex1, char vertex2, int weight){\nadj_list[vertex1].push_front(make_pair(\nvertex2, weight\n));\nE.push_back({vertex1, vertex2});\n}\nvoid register_vertex(vector&lt;char&gt; vertices){\nfor (auto v:vertices){\nlist&lt;pair&lt;char, int&gt;&gt; l;\nadj_list.insert({v, l});\n}\n}\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; view(){\nreturn adj_list;\n}\n};\n</code></pre> <p>Now on top of this custom graph [adjacency list] representation, we'll implement BFS and DFS the 2 most common algorithms in graphs and trees ever.</p>"},{"location":"graph/bfs-dfs/#bfs-with-standard-graph","title":"BFS with standard graph","text":"<p>Implementation follows the CLRS textbook for reference although is not a blind copy. <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n#include &lt;queue&gt;\nvector&lt;char&gt; BFS(Graph &amp;g, char startFromVertex){\n// create a queue\nqueue&lt;char&gt; q;\n// result order for the bfs\nvector&lt;char&gt; bfstree;\n// the graph as a map\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; graphView = g.view();\n// visited map\nunordered_map&lt;char, bool&gt; visited;\nfor (auto vertex:graphView)\nvisited[vertex.first] = false;\nq.push(startFromVertex); // startFromVertex must be in graph g\nwhile(!q.empty()){\nchar vert = q.front();\nif (visited[vert] == false){\n// if we did not visit this vertex please process\nbfstree.push_back(vert);\nauto neighbors = graphView[vert];\nfor (auto neighbor:neighbors){\nq.push(neighbor.first);\n}\nvisited[vert] = true;\n}\n// now remove the vertex\nq.pop();\n}\nreturn bfstree;\n}\n</code></pre></p>"},{"location":"graph/bfs-dfs/#dfs-on-standard-graph","title":"DFS on standard Graph","text":"<p>Implementation of DFS is recursive, it recursively goes into the graph then backtracks once there is nowhere to go. But in this implementation, I'll strictly avoid recursion because the graph is a little hard to grasp, and doing recursion on a graph may seem \\(\\text{BLACK MAGIC}\\). Instead, I'll implement DFS using a stack data structure to mimic recursion. It's an iterative implementation that is much easier to grasp.</p> <pre><code>vector&lt;char&gt; DFS(Graph &amp;g, char startFromVertex){\nvector&lt;char&gt; stack;\nunordered_map&lt;char, bool&gt; visited;\nvector&lt;char&gt; dfsOrder;\nauto graphView = g.view();\n// initialize all the visited == false\nfor (auto vertex:graphView)\nvisited[vertex.first] = false;\n// push whatever with you are starting with\nstack.push_back(startFromVertex);\nwhile(!stack.empty()){\nchar tos = stack.back();\nstack.pop_back();\nif (visited[tos] == false){\n// if this top of the stack is not visited then mark it\n// visited and push into the answer array [dfsOrder].\nvisited[tos] = true;\ndfsOrder.push_back(tos);\n}\nfor (auto adj_list:graphView[tos]){    // look at the adj_list of tos vertex\nif (visited[adj_list.first] == false){\nstack.push_back(adj_list.first);\n}\n}\n}\nreturn dfsOrder;\n}\n</code></pre>"},{"location":"graph/bfs-dfs/#application-of-depth-first-search","title":"Application of depth first search","text":""},{"location":"graph/bfs-dfs/#find-all-the-connected-components-of-a-graph","title":"Find all the connected components of a graph","text":""},{"location":"graph/bfs-dfs/#approach","title":"Approach","text":"<ul> <li>Using depth first search we can go in depth of a graph and for each connected components the DFS program will stop. </li> <li>We do this until we visit all the nodes in a graph. This way we'll find all the connected components of the graph.</li> </ul>"},{"location":"graph/bfs-dfs/#c-code","title":"C++ Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;forward_list&gt;\nusing namespace std;\nclass Graph {\nprivate:\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; adj_list;\npublic:\nGraph(vector&lt;char&gt; vertices){\nfor (char vert:vertices){\nforward_list&lt;char&gt; neighbor;\nadj_list.insert({\nvert, neighbor\n});\n}\n}\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; view(){\nreturn adj_list;\n}\nvoid add_edge(char from, char to){\nadj_list[from].push_front(to);\nadj_list[to].push_front(from);\n}\n};\nvector&lt;char&gt; DFSOrder(Graph &amp;g, char startingVertex){\nunordered_map&lt;char, bool&gt; visited;\nvector&lt;char&gt; stack;\nvector&lt;char&gt; order;\nauto view = g.view();\n// mark all node to visited == false\nfor(auto y:view)\nvisited[y.first] = false;\nstack.push_back(startingVertex);\nwhile (!stack.empty()){\nchar tos = stack.back();\nstack.pop_back();\nif (visited[tos] == false){\nvisited[tos] = true;\norder.push_back(tos);\n}\nfor (auto nbr:view[tos]){\nif (visited[nbr] == false){\nstack.push_back(nbr);\n}\n}\n}\nreturn order;\n}\nvoid connected_components(Graph &amp;g){\nunordered_map&lt;char, bool&gt; visited;\nauto view = g.view();\n// mark all node to visited == false\n// doesn't matter what is the value for each (key, value) pair in map;\n// we'll be deleting upon seeing a key that is visited.\n// we could have made a vector then the delete would become O(n);\nfor(auto y:view)\nvisited[y.first] = false;\n// while( visited == all not true)\n// use dfs;\nint connected_component_number = 0;\nwhile(!visited.empty()){\n// take any random vertex that is not yet visited\nchar startingVertex = visited.begin()-&gt;first;\nvector&lt;char&gt; dfs = DFSOrder(g, startingVertex);\ncout &lt;&lt; \"Connected Component Number: \" &lt;&lt; connected_component_number &lt;&lt; \" -&gt; \";\n// now remove all the visited in this call of dfs\nfor (char this_component_vertex:dfs){\ncout &lt;&lt; this_component_vertex &lt;&lt; \" \";\nvisited.erase(this_component_vertex);\n}\nconnected_component_number++;\ncout &lt;&lt; endl;\n}\n}\n// DRIVER CODE\nint main(){\nint number_of_vertices;\nvector&lt;char&gt; v;\ncin &gt;&gt; number_of_vertices;\nwhile (number_of_vertices){\nchar vertex;\ncin &gt;&gt; vertex;\nv.push_back(vertex);\nnumber_of_vertices--;\n}\nGraph g = Graph(v);\nint number_of_edges;\ncin &gt;&gt; number_of_edges;\nwhile(number_of_edges){\nchar from, to;\ncin &gt;&gt; from &gt;&gt; to;\ng.add_edge(from, to);\nnumber_of_edges--;\n}\nauto view = g.view();\nfor (auto vert:view){\ncout &lt;&lt; vert.first &lt;&lt; \" -&gt; \";\nfor (auto nbr:vert.second)\ncout &lt;&lt; nbr &lt;&lt; \" \";\ncout &lt;&lt; endl;\n}\nvector&lt;char&gt; dfs = DFSOrder(g, 'a');\ncout &lt;&lt; \"DFS ORDER Starting From 'a' -&gt; \";\nfor (auto i:dfs)\ncout &lt;&lt; i &lt;&lt; \" \";\ncout &lt;&lt; endl;\nconnected_components(g);\n}\n</code></pre> <p>Let's run the above program on a random graph</p> <p></p>"},{"location":"graph/bfs-dfs/#input-pattern","title":"Input Pattern","text":"<pre><code>5               &lt;- Number of vertices\na\nb\nc               &lt;- all the vertices of the graph\nd\ne\n3               &lt;- number of edges\na b             &lt;- Edges in between vertices, undirected edges\nb c\nc e\n</code></pre>"},{"location":"graph/bfs-dfs/#example-output","title":"Example Output","text":"<pre><code>e -&gt; c \nd -&gt; \nc -&gt; e b \na -&gt; b \nb -&gt; c a\n\nDFS ORDER Starting From 'a' -&gt; a b c e \nConnected Component Number: 0 -&gt; b a c e \nConnected Component Number: 1 -&gt; d \n</code></pre>"},{"location":"graph/dsu/","title":"Disjoint Set Data Structure","text":"<p>Table of Contents</p> <ul> <li>Na\u00efve implementation of DSU</li> <li>APIs to support</li> <li>Union by rank optimization</li> <li>Some Problems on Leetcode that uses Disjoint Set Structure</li> </ul>"},{"location":"graph/dsu/#naive-implementation-of-dsu","title":"Na\u00efve implementation of DSU","text":"<p>One of the na\u00efve implementation for DSU is to use an array. Here for a Leetcode problem I've shown an implementation of DSU that do not use rank-path compression optimizations, just plain and simple implementation of DSU with array.</p>"},{"location":"graph/dsu/#apis-to-support","title":"APIs to support","text":"<ul> <li><code>find(int i)</code> to find the parent of some node <code>i</code></li> <li><code>makeUnion(int i, int j)</code> to create a union of two nodes <code>i</code> and <code>j</code>.</li> <li>The following is a simple implementation of DSU that implements the upper 2 APIs.</li> </ul> <pre><code>class DSU {\nprivate:\nint size;\nvector&lt;int&gt; dsuArray;\npublic:\nDSU(int n) {\nint size = n;\nfor (int i=0;i&lt;n+1;i++) {\ndsuArray.push_back(i);\n}\n}\nvector&lt;int&gt; getArray() {\nreturn dsuArray;\n}\nint find(int n) {\nreturn dsuArray[n];\n}\nbool makeUnion(int i, int j) {\nint parent_i = find(i);\nint parent_j = find(j);\nif (parent_i == parent_j) return false;\n// find all occurences of parent_j\n// set to parent_i to make the Union\nfor (int i=1; i&lt;dsuArray.size(); i++) {\nif (dsuArray[i] == parent_j) {\ndsuArray[i] = parent_i;\n}\n}\nreturn true;\n}\n};\n</code></pre>"},{"location":"graph/dsu/#union-by-rank-optimization","title":"Union by rank optimization","text":"<p>If you see the <code>makeUnion()</code> API we are setting the parents of <code>parent_j</code> to <code>parent_i</code>. Now if the number of elements in the group of <code>j</code> is higher then there is a chance to optimize the time complexity. We can update the <code>parent_i</code> to <code>parent_j</code> as number of times <code>parent_i</code> is to be updated is much lower.</p> <p>This is called union by rank optimization. In order to do this we need to have some data structure that'll indicate the size of every group everytime we do an union. Then we can take the smaller group and updated its parents instead of updating the parent of the larger group size.</p>"},{"location":"graph/dsu/#some-problems-on-leetcode-that-uses-disjoint-set-structure","title":"Some Problems on Leetcode that uses Disjoint Set Structure","text":""},{"location":"graph/dsu/#redundant-connection","title":"Redundant Connection","text":""},{"location":"graph/dsu/#problem-statement","title":"Problem Statement","text":"<p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p> <p>You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to <code>n</code>, and was not an edge that already existed. The graph is represented as an array edges of length <code>n</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes ai and bi in the graph.</p> <p>Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.</p>"},{"location":"graph/dsu/#example","title":"Example","text":"<pre><code>Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n</code></pre>"},{"location":"graph/dsu/#approach","title":"Approach","text":"<ul> <li>We'll use a DSU to add the edges in the DSU until we get a cycle.</li> <li>When we get a cycle, we'll add it to the answer, this will be the edge that we need to return.</li> </ul>"},{"location":"graph/dsu/#code","title":"Code","text":"<pre><code>class DSU {\nprivate:\nint size;\nvector&lt;int&gt; dsuArray;\npublic:\nDSU(int n) {\nint size = n;\nfor (int i=0;i&lt;n+1;i++) {\ndsuArray.push_back(i);\n}\n}\nvector&lt;int&gt; getArray() {\nreturn dsuArray;\n}\nint find(int n) {\nreturn dsuArray[n];\n}\nbool makeUnion(int i, int j) {\nint parent_i = find(i);\nint parent_j = find(j);\nif (parent_i == parent_j) return false;\n// find all occurences of parent_j\n// set to parent_i to make the Union\nfor (int i=1; i&lt;dsuArray.size(); i++) {\nif (dsuArray[i] == parent_j) {\ndsuArray[i] = parent_i;\n}\n}\nreturn true;\n}\n};\nclass Solution {\npublic:\nvector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\nint maxim = INT_MIN;\nfor (auto j:edges) {\nmaxim = std::max(j[0], maxim);\nmaxim = std::max(j[1], maxim);\n}\n// number of nodes = maxim now.\n// now we create a DSU\nDSU dsu = DSU(maxim);\nvector&lt;int&gt; answer;\nfor (auto edgePair:edges) {\nint first = edgePair[0];\nint second = edgePair[1];\nbool possible = dsu.makeUnion(edgePair[0], edgePair[1]);\nif (not possible) {\nanswer.push_back(edgePair[0]);\nanswer.push_back(edgePair[1]);\n}\n}\nreturn answer;\n}\n};\n</code></pre>"},{"location":"graph/problems/","title":"Graph standard problems","text":"<p>Questions Discussed</p> <ul> <li>Number of Islands</li> <li>Clone Graph</li> <li>Max Area of Island</li> <li>Pacific Atlantic Water Flow</li> <li>Surrounded Regions</li> <li>All Paths From Source to Target</li> <li>Course Schedule</li> <li>Download Speed</li> <li>Building Roads</li> </ul>"},{"location":"graph/problems/#number-of-islands","title":"Number of Islands","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement","title":"Problem Statement","text":"<p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.</p> <p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>"},{"location":"graph/problems/#example","title":"Example","text":"<pre><code>Input: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n</code></pre> <pre><code>Input: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n</code></pre>"},{"location":"graph/problems/#approach","title":"Approach","text":"<p>We'll use a simple DFS apporach to find the number of islands. The appoach is to when we touch a landmass, we'll mark all the connected landmass as '0' using DFS and increase the number of islands. Then travel through the space, until we find another landmass.</p> <p>This way only new landmasses are considered in the number of islands.</p> <p>Here is a code sample that uses DFS to find the number of islands.</p>"},{"location":"graph/problems/#code","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvoid dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int i, int j, int r, int c) {\nif (i&lt; 0 || i &gt;= r || j&lt;0 || j &gt;= c || grid[i][j] == '0') {\n// if the dfs subroutine goes out of bounds,\n// or we find water during the traversal to find landmasses\n// we return\nreturn;\n}\n// if we find a grid[i][j] == \"1\" means this is a part of\n// the island so we set this position as \"0\" so that we\n// don't revisit this again\ngrid[i][j] = '0';\n// run recursive dfs on all directions\ndfs(grid, i-1, j, r, c);\ndfs(grid, i+1, j, r, c);\ndfs(grid, i, j-1, r, c);\ndfs(grid, i, j+1, r, c);\n}\npublic:\nint numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\nint islandCount = 0;\nint rows = grid.size();\nint cols = grid[0].size();\nfor (int i=0; i&lt;rows; i++) {\nfor (int j=0; j&lt;cols; j++) {\nif (grid[i][j] == '1') {\ndfs(grid, i, j, rows, cols);\nislandCount++;\n}\n}\n}\nreturn islandCount;\n}\n};\n</code></pre>"},{"location":"graph/problems/#clone-graph","title":"Clone Graph","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_1","title":"Problem Statement","text":"<p>Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.</p>"},{"location":"graph/problems/#approach_1","title":"Approach","text":"<ul> <li>We'll create a <code>unordered_map</code> to store the mapping between new and old nodes in the graph.</li> <li>Then we'll run a BFS algorithm on the graph to find new nodes and connect them to their corrospoding neighbors.</li> </ul> <p>The following is a working code example for this apporach.</p>"},{"location":"graph/problems/#code_1","title":"Code","text":"<pre><code>/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector&lt;Node*&gt;();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector&lt;Node*&gt;();\n    }\n    Node(int _val, vector&lt;Node*&gt; _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\nclass Solution {\npublic:\nNode* cloneGraph(Node* node) {\nif (not node) return nullptr;\nunordered_map&lt;Node*, Node*&gt; map;\n// create a node corrospoding to the starting node\nmap[node] = new Node(node-&gt;val);\nqueue&lt;Node*&gt; q;\nq.push(node);\nwhile (!q.empty()) {\nNode* current = q.front();\nq.pop();\n// for all neighbor of current check if we visited that or not?\n// if we don't visit we enter it in the map\nfor(auto nbr:current-&gt;neighbors) {\nif (map.find(nbr) == map.end()) {\nmap[nbr] = new Node(nbr-&gt;val);\nq.push(nbr);\n}\n// add the newly created neighbor on the map[current] neighbors\nmap[current]-&gt;neighbors.push_back(map[nbr]);\n}\n}\nreturn map[node];\n}\n};\n</code></pre>"},{"location":"graph/problems/#max-area-of-island","title":"Max Area of Island","text":"<p>You are given an \\(M \\times N\\) binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p> <p>The area of an island is the number of cells with a value 1 in the island.</p> <p>Return the maximum area of an island in grid. If there is no island, return \\(0\\).</p>"},{"location":"graph/problems/#examples","title":"Examples","text":"<pre><code>Input:\nUpper image as a 2-d grid\n\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n</code></pre> <pre><code>Input: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n</code></pre>"},{"location":"graph/problems/#approach_2","title":"Approach","text":"<ul> <li>We'll modify the previous problem Number of Islands to count the size of the island during the DFS instead of just doing nothing.</li> <li>This way we can find the size of the Islands during the DFS, we'll keep track of the max-size we've seen so far.</li> </ul>"},{"location":"graph/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int r, int c) {\nif (i &lt; 0 or j &lt;0 or i &gt;=r or j &gt;=c or grid[i][j] == 0) {\nreturn 0;\n}\ngrid[i][j] = 0;\nreturn 1 + dfs(grid, i+1, j, r, c) + dfs(grid, i-1, j, r, c) + dfs(grid, i, j + 1, r, c) + dfs(grid, i, j - 1, r, c);\n}\npublic:\nint maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\nint maxSize = 0;\nint numberOfIsland = 0;\nint rows = grid.size();\nint cols = grid[0].size();\nfor (int i=0; i&lt;rows; i++) {\nfor (int j=0; j&lt;cols; j++) {\nif (grid[i][j] == 1) {\nint size = dfs(grid, i, j, rows, cols);\nmaxSize = std::max(maxSize, size);\nnumberOfIsland++;\n}\n}\n}\nif (numberOfIsland == 0) return 0;\nreturn maxSize;\n}\n};\n</code></pre>"},{"location":"graph/problems/#pacific-atlantic-water-flow","title":"Pacific Atlantic Water Flow","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_2","title":"Problem Statement","text":"<p>There is an \\(m \\times n\\) rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.</p> <p>The island is partitioned into a grid of square cells. You are given an \\(m \\times n\\) integer matrix heights where <code>heights[r][c]</code> represents the height above sea level of the cell at coordinate \\((r, c)\\).</p> <p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.</p> <p>Return a 2D list of grid coordinates result where <code>result[i] = [ri, ci]</code> denotes that rain water can flow from cell \\((r_i, c_i)\\) to both the Pacific and Atlantic oceans.</p>"},{"location":"graph/problems/#example_1","title":"Example","text":"<pre><code>Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n</code></pre> <pre><code>Input: heights = [[2,1],[1,2]]\nOutput: [[0,0],[0,1],[1,0],[1,1]]\n</code></pre>"},{"location":"graph/problems/#approach_3","title":"Approach","text":"<ul> <li>We'll use DFS to solve this problem with a reverse approach.</li> <li>First instead of searching from where the water can flow to ocean we'll check from ocean what is the reverse of the path through which the water is flowing.</li> <li>Naturally water flows from top height to bottom height, here we'll do the opposite where we'll check if the neighbors height is greater than the current height we'll travel (because we're searching the reverse of the waterflow's path),</li> <li>Now all columns of row \\(0\\) and all the rows of column \\(0\\) has the pacific water, we'll draw a DFS to find where the water can go using our customized DFS algorithm.</li> <li>Similarly we'll do this for the atlantic ocean.</li> <li>Now we'll check where the water from both can reach, we'll return that in the answers array.</li> </ul>"},{"location":"graph/problems/#code_3","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; flowCoordinates;\nvoid dfs(vector&lt;vector&lt;int&gt;&gt;&amp; heights, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int i, int j, int r, int c) {\nvisited[i][j] = true;\nif (i&gt;0 and not visited[i-1][j] and heights[i][j] &lt;= heights[i-1][j]) {\ndfs(heights, visited, i-1,j,r,c);\n}\nif (i&lt;r-1 and not visited[i+1][j] and heights[i][j] &lt;= heights[i+1][j]) {\ndfs(heights, visited, i+1,j,r,c);\n}\nif (j&gt;0 and heights[i][j] &lt;= heights[i][j-1] and not visited[i][j-1]) {\ndfs(heights, visited, i,j-1,r,c);\n}\nif (j&lt;c-1 and heights[i][j] &lt;= heights[i][j+1] and not visited[i][j+1]) {\ndfs(heights, visited, i,j+1,r,c);\n}\n}\npublic:\nvector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {\nint rows = heights.size();\nint cols = heights[0].size();\nvector&lt;vector&lt;bool&gt;&gt; pacific(rows, vector&lt;bool&gt;(cols));\nvector&lt;vector&lt;bool&gt;&gt; atlantic(rows, vector&lt;bool&gt;(cols));\nfor (int i=0;i&lt;rows;i++) {\ndfs(heights, pacific, i, 0, rows, cols);\ndfs(heights, atlantic, i, cols-1, rows, cols);\n}\nfor (int i=0; i&lt;cols; i++) {\ndfs(heights, pacific, 0, i, rows, cols);\ndfs(heights, atlantic, rows-1, i, rows, cols);\n}\n// now check for some (i, j) both pacific and altantic shows true\nfor (int i=0; i&lt;rows; i++) {\nfor (int j=0;j&lt;cols;j++) {\nif (pacific[i][j] and atlantic[i][j]) {\nflowCoordinates.push_back({i, j});\n}\n}\n}\nreturn flowCoordinates;\n}\n};\n</code></pre>"},{"location":"graph/problems/#surrounded-regions","title":"Surrounded Regions","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_3","title":"Problem Statement","text":"<p>Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.</p> <p>A region is captured by flipping all 'O's into 'X's in that surrounded region.</p>"},{"location":"graph/problems/#example_2","title":"Example","text":"<p><pre><code>Input: \nboard = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\nOutput: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n</code></pre> Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>"},{"location":"graph/problems/#approach_4","title":"Approach","text":"<ul> <li>We'll use the approach from the previous problem. We'll do a quick reverse thinking, see we should not capture regions that are on the border so what we'll do is use a DFS to quickly capture the regions that surrounds the border with some other alphabet \"N\" let's say.</li> <li>These can be achieved by running DFS on the \"O\" at the row \\(0\\), last row and column \\(0\\) and at the last column.</li> <li>So we'll run dfs at all the positions of \"O\" at the boundaries,</li> <li>then we'll capture all the regions that are left out \"not in the border\".</li> <li>Then we'll convert the \"N\"s into \"O\"s.</li> </ul>"},{"location":"graph/problems/#code_4","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvoid dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int r, int c) {\nboard[i][j] = 'N';\nif (i&gt;0 and board[i-1][j] == 'O') {\ndfs(board, i-1, j, r, c);\n}\nif (i&lt;r-1 and board[i+1][j] == 'O') {\ndfs(board, i+1, j, r, c);\n}\nif (j&gt;0 and board[i][j-1] == 'O') {\ndfs(board, i, j-1, r, c);\n}\nif (j&lt;c-1 and board[i][j+1] == 'O') {\ndfs(board, i, j+1, r, c);\n}\n}\npublic:\nvoid solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n// capture everything except an unsurrounded region\n// if some O is there at the row 0, n-1 and col 0, n-1\n// we'll not be able to capture it.\n// run a dfs on each of the area in row 0, n-1 and col 0, n-1\n// to not capture it and marking it as N\nint rows = board.size();\nint cols = board[0].size();\n// vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols));\n// run dfs at all the positions of O at the boundaries\n// col wise\nfor (int i=0; i&lt;rows; i++) {\n// 0th column\nif (board[i][0] == 'O') {\ndfs(board, i, 0, rows, cols);\n}\n// cols-1th column\nif (board[i][cols-1] == 'O') {\ndfs(board, i, cols-1, rows, cols);\n}\n}\n// run row wise at col = 0 and rows-1\nfor (int j=1; j&lt;cols-1; j++) {\n// 1st row because 0,0 is already done\nif (board[0][j] == 'O') {\ndfs(board, 0, j, rows, cols);\n}\nif (board[rows-1][j] == 'O') {\ndfs(board, rows-1, j, rows, cols);\n}\n}\nfor (int i=0; i&lt;rows; i++) {\nfor (int j=0; j&lt;cols; j++) {\nif (board[i][j] == 'O') board[i][j] = 'X';\nif (board[i][j] == 'N') board[i][j] = 'O';\n}\n}\n}\n};\n</code></pre>"},{"location":"graph/problems/#all-paths-from-source-to-target","title":"All Paths From Source to Target","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_4","title":"Problem Statement","text":"<p>Given a directed acyclic graph (DAG) of n nodes labeled from \\(0\\) to node \\(n - 1\\), find all possible paths from node \\(0\\) to node \\(n - 1\\) and return them in any order.</p> <p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node i (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>"},{"location":"graph/problems/#examples_1","title":"Examples","text":"<pre><code>Input: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.\n</code></pre> <pre><code>Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</code></pre>"},{"location":"graph/problems/#approach_5","title":"Approach","text":"<ul> <li>We'll do a DFS approach, instead of putting the path into the answer when we reach the last node to be reachable we'll put the path when we visit \\(n-1^{th}\\) node because in the question we are asked to find all path from node \\(0\\) to node \\(n - 1\\).</li> <li>Our approach will find all the possible path via DFS recursions. In order to store the path information we'll add an array called <code>lvl</code> that is copied and shared to the next recursion level. So for each recursion calls we'll maintain a of the path visited so far called <code>lvl</code> that'll be passed to the next level. That is how we'll maintain the path information.</li> <li>At the end we'll return all the paths recorded during the recursion run.</li> </ul>"},{"location":"graph/problems/#code_5","title":"Code","text":"<pre><code>class Solution {\nprivate:\nset&lt;vector&lt;int&gt;&gt; s;\nvoid dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt; lvl, int index) {\nif (index &gt; graph.size() - 1) return;\n// stop dfs once there is no where to go\nif (index == graph.size() - 1) {\n// return once reached the final destination\n// final destination is always the n-1 vertex according to the question\nlvl.push_back(index);  // final destination added\ns.insert(lvl);  // add this path to the answer set (set for uniqueness)\nreturn;\n}\nlvl.push_back(index);\nfor (int i=0; i&lt;graph[index].size(); i++) {\n// no cycle so should not care about the already visited part\nint nbr = graph[index][i];\ndfs(graph, lvl, nbr);\n}\n}\npublic:\nvector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\nvector&lt;int&gt; lvl;\ndfs(graph, lvl, 0);\n// add the final destination to all the paths\nvector&lt;vector&lt;int&gt;&gt; answer;\nanswer.assign(s.begin(), s.end());\nreturn answer;\n}\n};\n</code></pre>"},{"location":"graph/problems/#course-schedule","title":"Course Schedule","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_5","title":"Problem Statement","text":"<p>There are a total of numCourses courses you have to take, labeled from \\(0\\) to \\(\\text{numCourses} - 1\\). You are given an array prerequisites where <code>prerequisites[i]</code> = (\\(a_i, b_i\\)) indicates that you must take course \\(b_i\\) first if you want to take course \\(a_i\\).</p> <p>For example, the pair (\\(0,1\\)) indicates that to take course \\(0\\) you have to first take course \\(1\\). Return true if you can finish all courses. Otherwise, return false.</p>"},{"location":"graph/problems/#approach_6","title":"Approach","text":"<p>If you look carefully it is a problem of finding cycle in a graph or finding the topological sort of the graph. If the graph is a DAG then only all the courses can be completed. If there is a cycle in the graph then to take course \\(a\\) you have to take \\(b\\) and to take \\(b\\) you have to take \\(a\\), which is not possible.</p> <p>So we have to find a cycle in the graph if we find a cycle then the course are not possible to complete. Now in order to find the cycle in the graph we can use DFS by coloring the vertices.</p> <p>Following is a efficient implementation of DFS and cycle finding algorithm along with a custom definition for graph and solution to the leetcode problem.</p>"},{"location":"graph/problems/#examples_2","title":"Examples","text":"<pre><code>Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</code></pre>"},{"location":"graph/problems/#code_6","title":"Code","text":"<pre><code>enum class Color{\nblack, red, grey\n};\nclass Graph {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; adj_list;\nint graph_size;\nbool has_cycle = false;\npublic:\nGraph(int V) {\ngraph_size = V;\nfor (int i=0; i&lt;V; i++) {\nvector&lt;int&gt; v;\nadj_list.push_back(v);\n}\n}\nvoid add_edge(int source, int destination) {\n// directed edge only\nadj_list[source].push_back(destination);\n}\nvoid dfsSubRoutine(unordered_map&lt;int, Color&gt;&amp;color, int nodeID) {\n// do coloring of the edges\n// color grey means not visited\n// color red means visited and not fully explored\n// color black means visited and fully explored\nif (color[nodeID] == Color::red) {\nhas_cycle = true;\nreturn;\n} else if (color[nodeID] == Color::grey){\ncolor[nodeID] = Color::red;\nfor (int nbr:adj_list[nodeID]) {\ndfsSubRoutine(color, nbr);\n}\n}\ncolor[nodeID] = Color::black;\nreturn;\n}\nbool hasCycle() {\n// run a DFS algorithm and check if there is a cycle or not?\n// check if some node is previously visited or not?\n// if some neighbor is neighbor previously visited \n// then return true;\n// means there is cycle\nunordered_map&lt;int, Color&gt; color;\nfor (int i=0; i&lt;graph_size; i++) color[i] = Color::grey;\nfor (int i = 0; i&lt;graph_size; i++) {\n// for all component of the graph run the subroutine\nif (color[i] == Color::grey) dfsSubRoutine(color, i);\n}\nreturn has_cycle;\n}\n};\nclass Solution {\npublic:\nbool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {\n// courseID = {0 .. n-1}\n// preReq[i] = {to Take i, must have taken j}\n// na\u00efve cycle detection\n// if the graph is a DAG then only a solution is possible but otherwise\n// for any cycle if you have to take a then take b\n// if you have to take b then before you take a\nGraph g = Graph(numCourses);\nfor (auto courses:prerequisites) {\ng.add_edge(courses[1], courses[0]);\n}\nreturn not g.hasCycle();\n}\n};\n</code></pre>"},{"location":"graph/problems/#download-speed","title":"Download Speed","text":"<p>Consider a network consisting of n computers and m connections. Each connection specifies how fast a computer can send data to another computer. Kotivalo wants to download some data from a server. What is the maximum speed he can do this, using the connections in the network?</p> <p>Please see here \\(\\to\\) for full explaination of the problem and the input and output structure.</p>"},{"location":"graph/problems/#example-io","title":"Example I/O","text":"<pre><code>Input:\n4 5\n1 2 3\n2 4 2\n1 3 4\n3 4 5\n4 1 3\n\nOutput:\n6\n</code></pre>"},{"location":"graph/problems/#approach_7","title":"Approach","text":"<p>Use Edmond-Karp algorithm for finding max-flow in the flow-network. Make the internet mesh as a flow network and make source set to \\(1\\) and destination set to \\(n\\). Then run Edmond-Karp algorithm to find the maximum flow. This maximum flow is the maximum download speed possible.</p>"},{"location":"graph/problems/#code_7","title":"Code","text":"<pre><code>#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\nclass Graph {\npublic:\nvector&lt;vector&lt;int&gt;&gt; adj_list;\nvector&lt;vector&lt;long long int&gt;&gt; capacity;\nint source;\nint sink;\nint getSink() {\nreturn sink;\n}\nvoid setSink(int id) {\nsink = id;\n}\nint getSource() {\nreturn source;\n}\nvoid setSource(int id) {\nsource = id;\n}\nGraph(int n) {\nfor (int i = 0; i &lt; n; i++) {\nvector&lt;int&gt; v;\nadj_list.push_back(v);\nvector&lt;long long int&gt; caprow(n, 0);\ncapacity.push_back(caprow);\n}\n}\nvoid add_directed_edge(int from, int to, long long int cap) {\nadj_list[from].push_back(to);\ncapacity[from][to] += cap;\n}\nlong long int bfs(vector&lt;int&gt; &amp;parent) {\n// find an augmenting path from s-&gt;t and return the path in\n// parent vector\nstd::fill(parent.begin(), parent.end(), -1);\nparent[source] = -2;\nqueue&lt;pair&lt;int, long long int&gt;&gt; q;\nq.push({source, LONG_MAX});\nwhile (not q.empty()) {\nint front = q.front().first;\nlong long int flow = q.front().second;\nq.pop();\nfor (int nbr : adj_list[front]) {\n// if there is no parent discovered before and there exists a flow\nif (parent[nbr] == -1 and capacity[front][nbr]) {\n// then set parent and add it to augmenting path\nparent[nbr] = front;\nlong long int new_flow = std::min(flow, capacity[front][nbr]);\nif (nbr == sink)\nreturn new_flow;\n// otherwise push onto queue with updated flow\nq.push({nbr, new_flow});\n}\n}\n}\n// there exists no s-&gt;t path so return 0 flow\nreturn 0;\n}\nlong long int findMaxFlow() {\nlong long int flow = 0;\nvector&lt;int&gt; parent(adj_list.size(), 0);\nlong long int newflow = 0;\n// backtrace to s via the parent array and use the\n// augmenting path to augment the flow\nwhile (true) {\nnewflow = bfs(parent);\nif (not newflow)\nbreak;\nint current = sink;\nflow += newflow;\n// otherwise through the augmenting path do the flow\nwhile (current != source) {\nint prev = parent[current];\n// augment the flow\ncapacity[prev][current] -= newflow;\ncapacity[current][prev] += newflow;\ncurrent = prev;\n}\n}\nreturn flow;\n}\n};\nint main() {\nint vertex, edges;\ncin &gt;&gt; vertex &gt;&gt; edges;\nGraph g(vertex + 1);\ng.setSource(1);\ng.setSink(vertex);\nwhile (edges--) {\nint from, to;\nlong long int capacity;\ncin &gt;&gt; from &gt;&gt; to &gt;&gt; capacity;\ng.add_directed_edge(from, to, capacity);\ng.add_directed_edge(to,  from, 0);\n}\nlong long int maxflow = g.findMaxFlow();\ncout &lt;&lt; maxflow &lt;&lt; endl;\n}\n</code></pre>"},{"location":"graph/problems/#building-roads","title":"Building Roads","text":"<p>Find the problem here \\(\\to\\)</p>"},{"location":"graph/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Byteland has \\(n\\) cities, and \\(m\\) roads between them. The goal is to construct new roads so that there is a route between any two cities. Your task is to find out the minimum number of roads required, and also determine which roads should be built.</p>"},{"location":"graph/problems/#apporach","title":"Apporach","text":"<ul> <li>Coming Soon</li> </ul>"},{"location":"graph/problems/#solution","title":"Solution","text":"<pre><code>// https://cses.fi/problemset/task/1666/\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvoid fileIO() {\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\n}\n/*\n * Fast Disjoint Set Union Data Structure.\n * has implementation for fast Union and find operation\n */\nclass DisjointSetUnion {\npublic:\nint totalVertex;\nvector&lt;int&gt; parent;\nvector&lt;int&gt; size;\nDisjointSetUnion(int vertex) {\nthis-&gt;totalVertex = vertex;\nfor (int i = 0; i &lt;= vertex; i++) {\nparent.push_back(i);\nsize.push_back(1);\n}\n}\nbool UNION(int u, int v) {\nint parent_u = FIND(u);\nint parent_v = FIND(v);\nif (parent_u == parent_v) {\nreturn false;\n}\nif (size[parent_u] &lt; size[parent_v]) {\nstd::swap(parent_u, parent_v);\n}\nparent[parent_v] = parent_u;\nsize[parent_u] += size[parent_v];\nreturn true;\n}\nint FIND(int i) {\n// recursive find call to find parent\nif (parent[i] == i) {\nreturn i;\n}\nreturn parent[i] = FIND(parent[i]);\n}\nvector&lt;int&gt; idConnectedComponents() {\nvector&lt;int&gt; components;\nfor (int i = 1; i &lt;= totalVertex; i++) {\nif (parent[i] == i) {\ncomponents.push_back(i);\n}\n}\nreturn components;\n}\n};\nclass City {\nprivate:\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; allRequiredRoads;\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; roads;\nint numberOfCities, numberOfRoads;\npublic:\nvoid setRoads(std::vector&lt;std::pair&lt;int, int&gt;&gt; roads) {\nthis-&gt;roads = roads;\n}\nvoid setNumberOfCities(int numberOfCities) {\nthis-&gt;numberOfCities = numberOfCities;\n}\nvoid setNumberOfRoads(int numberOfRoads) {\nthis-&gt;numberOfRoads = numberOfRoads;\n}\nvoid calculateMinimumRequiredRoads() {\n// MARK: Implemementation\nDisjointSetUnion dsu = DisjointSetUnion(this-&gt;numberOfCities);\n// the number of roads to be added to connect all cities is the number of the disjoint set - 1\n// connect each of the disjoint set by connecting one city from each of the disjoint set\nfor (auto road : roads) {\ndsu.UNION(road.first, road.second);\n}\n// build roads from each one of the connected components.\nvector&lt;int&gt; idOfEachConnectedComponents = dsu.idConnectedComponents();\nint totalConnectedComponents = idOfEachConnectedComponents.size();\nif (totalConnectedComponents == 1) {\nreturn;\n} else {\nint index = 0;\nwhile (index &lt; totalConnectedComponents - 1) {\nint city1 = idOfEachConnectedComponents[index];\nint city2 = idOfEachConnectedComponents[index + 1];\nthis-&gt;allRequiredRoads.push_back({city1, city2});\nindex += 1;\n}\n}\n}\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; getMinimumRequiredRoads() {\nreturn this-&gt;allRequiredRoads;\n}\n};\nint main() {\n// fileIO();\nint numberOfCities, numberOfRoads;\n// The goal is to construct new roads so that there is a route between any two cities.\n// total of n cities, and m roads between them\n// find out the minimum number of roads required, and also determine which roads should be built\ncin &gt;&gt; numberOfCities &gt;&gt; numberOfRoads;\nint roads = numberOfRoads;\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; allRoads;\nwhile (roads--) {\nint from, to;\ncin &gt;&gt; from &gt;&gt; to;\nallRoads.push_back({from,\nto});\n}\nCity city = City();\ncity.setNumberOfCities(numberOfCities);\ncity.setNumberOfRoads(numberOfRoads);\ncity.setRoads(allRoads);\n// given all the roads, find out what is the minimum number of new roads required\n// to connect the city up such that there is a route between any two cities.\ncity.calculateMinimumRequiredRoads();\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; minimumRoadSet = city.getMinimumRequiredRoads();\ncout &lt;&lt; minimumRoadSet.size() &lt;&lt; endl;\nfor (auto city_pair : minimumRoadSet) {\ncout &lt;&lt; city_pair.first &lt;&lt; \" \" &lt;&lt; city_pair.second &lt;&lt; endl;\n}\nreturn 0;\n}\n</code></pre>"},{"location":"graph/standard-problems/","title":"More Graph Problems","text":""},{"location":"graph/standard-problems/#cycle-detection-in-undirected-graph","title":"Cycle Detection in Undirected Graph","text":"<p>Using simple traversal techniques we can detect cycles in undirected graphs. Here first we'll implement this using breath first search then we'll also show how to do this using depth first search. <pre><code>// UNDIRECTED GRAPH DEFINITION\nclass Graph {\nprivate:\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; adj_list;\npublic:\nGraph(vector&lt;char&gt; vertexSet) {\nfor (auto i : vertexSet) {\nforward_list&lt;char&gt; l;\nadj_list.insert({i, l});\n}\n}\nvoid add_edge(char from, char to) {\n// undirected graph\nadj_list[from].push_front(to);\nadj_list[to].push_front(from);\n}\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; view() {\nreturn adj_list;\n}\n};\n</code></pre></p>"},{"location":"graph/standard-problems/#approach-using-breath-first-search","title":"Approach using breath first search","text":"<ul> <li>The apporach is very simple, if during traversal if you find any one of the neighbor of some vertex previously visited other than the immediate parent/neighbor means there is a cycle.</li> <li>So put the vertex and it's immediate parent inside a Queue (to run BFS).</li> </ul> <pre><code>bool CYCLE_DETECTABLE_SEARCH(Graph &amp;g, char startingVertex) {\n// For BFS we need a queue and this queue has vertex and it's\n// immediate parent as a pair&lt;char, char&gt;\nqueue&lt;pair&lt;char, char&gt;&gt; q;\nunordered_map&lt;char, bool&gt; visited;\nauto graphView = g.view();\nfor (auto vertexName : graphView)\nvisited[vertexName.first] = false;\n// for starting vertex parent = 'N' for NULL;\nq.push({startingVertex, 'N'});\nvisited[startingVertex] = true;\nwhile (!q.empty()) {\npair&lt;char, char&gt; front = q.front();\nq.pop();\nchar thisvertex = front.first;\nchar parent = front.second;\n// for all the neighbors for thisvertex insert into queue\n// mark thisvertex as their immediate parents\n// if we see some visited vertex other than it's immediate neighbor/parent\n// return true\nfor (char nbr : graphView[thisvertex]) {\nif (visited[nbr] == false) {\nvisited[nbr] = true;\nq.push({nbr, thisvertex});\n} else if (visited[nbr] == true and nbr != parent) {\n// this neighbor of the vertex is already visited\n// and this neighbor is not the immediate parent\n// meaning there must be a cycle.\nreturn true;\n}\n}\n}\nreturn false;\n}\nbool hasCycle(Graph &amp;g) {\n// assuming multiple connected components are there\nunordered_map&lt;char, bool&gt; visited;\nauto graphView = g.view();\nfor (auto vertexName : graphView)\nvisited[vertexName.first] = false;\nbool hasCycleForThisComponent;\nfor (auto vertex : graphView) {\nif (!visited[vertex.first]) {\nhasCycleForThisComponent = CYCLE_DETECTABLE_SEARCH(g, vertex.first);\n}\nif (hasCycleForThisComponent) {\nreturn true;\n}\n}\nreturn false;\n}\n</code></pre>"},{"location":"graph/standard-problems/#bipartite-graph-check","title":"Bipartite Graph Check","text":""},{"location":"graph/standard-problems/#problem-statement","title":"Problem Statement","text":"<p>Given a graph G find out if this is a bipartite graph? For a bipartite graph, the graph has 2 set of vertices, in each set vertices are not connected to each other.</p>"},{"location":"graph/standard-problems/#approach","title":"Approach","text":"<ul> <li>Bi-partite graph is a 2 colorable graph, one approach could be if we check a graph if it's 2 colorable then it's bipartite. Bipartite is equivalent to 2-colorable. Here we'll traverse through the graph and color every vertex. Now if we find some vertex that takes other than the 2 color considered first we'll say it is not bipartite. Else if the entire graph is 2 colorable then we'll return true.</li> <li>Also we can approach this problem as this \\(\\to\\) any odd length cycle containing graph is not a bipartite graph.</li> </ul> <pre><code>// Any 2 Colorable graph is a bipartite graph Approach is much simpler to go through.\nenum class Color { black,\nred,\ngray }; // gray is to indicate that the vertex is not visted yet\nbool isBipartite(Graph &amp;g) {\n// set all the graph vertex color as gray\nauto graph = g.view();\nunordered_map&lt;char, Color&gt; color;\nfor (auto vertex : graph) {\ncolor[vertex.first] = Color::gray;\n}\n// set a starting index where to start the journey\nchar startingVertex = graph.begin()-&gt;first;\n// create a queue for bfs\nqueue&lt;char&gt; q;\nq.push(startingVertex);\ncolor[startingVertex] = Color::red;\n// run a bfs\nwhile (!q.empty()) {\nchar thisvertex = q.front();\nq.pop();\nfor (char nbr : graph[thisvertex]) {\nif (color[nbr] == Color::gray) {\n// if not visited then only process\nif (color[thisvertex] == Color::red) {\ncolor[nbr] = Color::black;\n} else if (color[thisvertex] == Color::black) {\ncolor[nbr] = Color::red;\n}\n// push into the queue for bfs\nq.push(nbr);\n} else {\n// check for termination condition\nif (color[nbr] == color[thisvertex]) {\nreturn false;\n}\n}\n}\n}\nreturn true;\n}\n</code></pre>"},{"location":"graph/standard-problems/#directed-graph-problems","title":"Directed Graph Problems","text":"<p>In this section the given graph has directed edges, below are some standard directed graph problems that is the building block for many other graph problems in general.</p> <ul> <li>Topological Sort Problem</li> <li>Cycle Detection</li> <li>Strongly connected components (Kosaraju's algorithm).</li> </ul>"},{"location":"graph/standard-problems/#topological-sorting-of-a-directed-graph","title":"Topological Sorting of a Directed graph","text":""},{"location":"graph/standard-problems/#problem-statement_1","title":"Problem Statement","text":"<p>Topological sorting for Directed Acyclic Graph is a linear ordering of vertices such that for every directed \\((u, v) \\in \\mathbf{V}\\), \\(u\\) comes before \\(v\\). In other words in order to reach \\(v\\) you must go through \\(u\\).</p>"},{"location":"graph/standard-problems/#approach_1","title":"Approach","text":"<ul> <li>In order to start our topological sorting we must indentify a node that has no dependencies. We'll start from one of such nodes. This can be automated with the algorithm or can be relied on the user to give as an input.</li> <li>In this implementation we'll assume no such event. User will only give the Graph <code>G</code> and we'll find some node to start on on our own.</li> </ul> <pre><code>// Directed Graph Varient\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;forward_list&gt;\n#include &lt;vector&gt;\nusing namespace std;\nclass Graph{\nprivate:\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; adj_list;\npublic:\nGraph(vector&lt;char&gt; vertexSet){\nfor (auto i:vertexSet){\nforward_list&lt;char&gt; l;\nadj_list.insert({i, l});\n}\n}\nvoid add_directed_edge(char from, char to){\nadj_list[from].push_front(to);\n}\nunordered_map&lt;char, forward_list&lt;char&gt;&gt; view(){\nreturn adj_list;\n}\n};\n</code></pre>"},{"location":"graph/standard-problems/#minimum-spanning-tree-problem","title":"Minimum spanning tree problem","text":""},{"location":"graph/standard-problems/#minimum-cost-to-connect-all-the-points","title":"Minimum Cost to Connect all the points","text":"<p>we are given an array points representing integer coordinates of some points on a 2D-plane, where \\(\\text{points[i]} = (x_i,y_i)\\). The cost of connecting two points \\((x_i,y_i)\\) and \\((x_j,y_j)\\) is the manhattan distance between them: \\(\\lvert x_i - x_j \\rvert + \\lvert y_i - y_j \\rvert\\). </p> <p>Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.</p>"},{"location":"graph/usage/","title":"Graphs","text":"<p>The graph is one of the most common and important data structures. With C++ and STL I'll show you the best possible implementation for the graph that you'll be able to implement and analyze in your code at FAANG interviews within the time constraints.</p>"},{"location":"graph/usage/#graph-adjacency-list-vs-adjacency-matrix","title":"Graph Adjacency List vs Adjacency Matrix","text":"<p>Most of cases the List representation is good enough, if the graph is sparse then it will take less space, and if the graph is dense you should use the adjacency matrix representation.</p> <p>In my opinion any graph with less than 70% of the all possible edges: \\(\\text{Count(E)} \\geq 0.7 * {n \\choose 2}\\) present can be considered to be implemented as adjacency list.</p>"},{"location":"graph/usage/#c-graph-representation","title":"C++  Graph representation","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\nusing namespace std;\n// Directed graph implementation\nclass Graph{ private:\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; adj_list;\nvector&lt;pair&lt;char, char&gt;&gt; E; // edge set\npublic:\nvector&lt;pair&lt;char, char&gt;&gt; edges(){\nreturn E;\n}\nvoid add_edge(char vertex1, char vertex2, int weight){\nadj_list[vertex1].push_front(make_pair(\nvertex2, weight\n));\nE.push_back({vertex1, vertex2});\n}\nvoid register_vertex(vector&lt;char&gt; vertices){\nfor (auto v:vertices){\nlist&lt;pair&lt;char, int&gt;&gt; l;\nadj_list.insert({v, l});\n}\n}\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; view(){\nreturn adj_list;\n}\n};\n</code></pre> <p>The following code shows how to make a graph  and use it</p> <pre><code>int main() {\nGraph g;\nvector&lt;char&gt; v = {'a', 'b', 'c'};\ng.register_vertex(v);\ng.add_edge('a', 'c', 32);\ng.add_edge('a', 'd', 2);\ng.add_edge('b', 'd', 12);\ng.add_edge('b', 'c', 98);\ng.add_edge('c', 'a', 1);\nunordered_map&lt;char, list&lt;pair&lt;char, int&gt;&gt;&gt; map = g.view();\nfor (auto data:map){\ncout &lt;&lt; data.first &lt;&lt; \" \";\nfor (auto neighbor:data.second)\ncout &lt;&lt; \"[\" &lt;&lt; neighbor.first &lt;&lt; \": \" &lt;&lt; neighbor.second &lt;&lt; \"]\";\ncout &lt;&lt; \"\\n\";\n}\n// print all the edges\nauto edges = g.edges();\nfor (auto edge:edges){\ncout &lt;&lt; edge.first &lt;&lt; \"-&gt;\" &lt;&lt; edge.second &lt;&lt; \"\\n\";   }\n}\n</code></pre>"},{"location":"greedy/problems/","title":"Greedy Problems","text":"<p>Greedy algorithms are algorithms that follows the problem-solving heuristic of making the locally optimal choice at each stage. You can not go back on your decisions once you've taken it.</p> <p>Let's solve some greedy problems</p> <p>Questions solved here</p> <ul> <li>Jump Game</li> <li>Jump Game II</li> </ul>"},{"location":"greedy/problems/#jump-game","title":"Jump Game","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"greedy/problems/#problem-statement","title":"Problem Statement","text":"<p>You are given an integer array <code>nums</code>. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.</p> <p>Return <code>true</code> if you can reach the last index, or false otherwise.</p>"},{"location":"greedy/problems/#example","title":"Example","text":"<pre><code>Input: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</code></pre> <pre><code>Input: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</code></pre>"},{"location":"greedy/problems/#approach","title":"Approach","text":"<ul> <li>We'll approach the problem in a reversed order. So we'll start from the end of the array and see if it is possible to reach that place, if we find any place from where we can reach the last index in the next iteration we'll see, that we can reach that index?</li> <li>We'll try to see the updated position is possible or not?</li> </ul>"},{"location":"greedy/problems/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\nbool canJump(vector&lt;int&gt;&amp; nums) {\nint to_reach = nums.size() - 1;\nint index = nums.size() - 1;\nwhile (index &gt;=0) {\nif (nums[index] + index &gt;= to_reach) {\nto_reach = index;\n}\nindex--;\n}\nreturn to_reach == 0;\n}\n};\n</code></pre>"},{"location":"greedy/problems/#jump-game-ii","title":"Jump Game II","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"greedy/problems/#problem-statement_1","title":"Problem Statement","text":"<p>Given similar to the last problem, an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Our goal is to reach the last index in the minimum number of jumps.</p> <p>We can assume that you can always reach the last index.</p>"},{"location":"greedy/problems/#example_1","title":"Example","text":"<pre><code>Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</code></pre>"},{"location":"greedy/problems/#approach_1","title":"Approach","text":"<ul> <li>We'll do a simple BFS like approach here. We are at first at the first index of the array. We'll see upto where we can reach and save it as level 1.</li> <li>Similarly we'll see from level 1 upto where maximum we can jump to, we'll mark it as level 2.</li> <li>From each level we'll jump to the next level until we reach the last index or cross that.</li> <li>To hold the values of the levels we'll use a <code>pair&lt;int, int&gt;</code> whose first element is the lower bound of the current level and second is the upper bound of the current level.</li> </ul>"},{"location":"greedy/problems/#c-code","title":"C++ Code","text":"<pre><code>class Solution {\npublic:\nint jump(vector&lt;int&gt;&amp; nums) {\n// base cases\nif (nums.size() == 1) return 0;\nint jumpCounter = 0;\npair&lt;int, int&gt; level = {1, nums[0]};\nint index = 1;\nwhile (level.second &lt; nums.size() - 1) {\n// find if you can get out of this level, then find the max\n// distance you can get out of this level?\n// this level has bounds from level.first to level.second\nint maxJumpToTheOutSide = 0;\nfor (int i=0; i&lt;=level.second; i++) {\nmaxJumpToTheOutSide = std::max(maxJumpToTheOutSide, (nums[i] + i));\n}\n// jump to that location now\nlevel.first = level.second + 1;\nlevel.second = maxJumpToTheOutSide;\nindex = level.first;\njumpCounter++;\n}\nreturn jumpCounter + 1;\n}\n};\n</code></pre>"},{"location":"hashing/problems/","title":"Hashing problems","text":"<p>If some problem is not solvable without mental gymnastics, you can pretty much solve those with a hashtable or <code>unordered_map&lt;d_t, d_t&gt;</code> in C++.</p> <p>Let's solve some of the hashing problems which may not be straight forward.</p>"},{"location":"hashing/problems/#find-and-replace-pattern","title":"Find and Replace Pattern","text":""},{"location":"hashing/problems/#problem-statement","title":"Problem Statement","text":"<p>Given a list of strings words and a string pattern, return a list of <code>words[i]</code> that match pattern. You may return the answer in any order.</p> <p>A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.</p> <p>Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.</p>"},{"location":"hashing/problems/#approach","title":"Approach","text":"<ul> <li>We can solve this problem with a hash table but the problem is one letter is mapped to only one letter. Let's take some examples see how this can cause some problems.</li> <li>Let's say we have a pattern <code>abb</code> and we want to match from <code>[\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"]</code>. Now if we make an unordered map with <code>abb</code> to for each string mapping it will show us that <code>mee</code> is matching, <code>aqq</code> is matching and also <code>ccc</code> is matching. You can only check if <code>a</code> is mapped to only <code>c</code> or not, not the other way around. So the test case <code>acc</code> will fail our algorithm. So let's try to map the reverse way round.</li> <li>We'll map the string from the string array to the pattern string. Now the test case <code>mee</code> will have <code>m-&gt;a</code> mapping, <code>e-&gt;b</code> mapping and once more <code>e-&gt;b</code> mapping. Now let's take a look at the test case <code>abc</code>, <code>a-&gt;a</code> mapping then <code>b-&gt;c</code> mapping and then <code>c-&gt;b</code> mapping. So there is another error now. Once b is mapped to b then c can not be mapped to b. b can be only mapped to b.</li> <li>So we've looked at both directions and none of the seems to work, what if we have a bi directional <code>char</code> to <code>char</code> mapping so that we can match one letter to exactly one letter?</li> <li>So we need to implement a <code>BiMap()</code> class to solve the problem.</li> </ul> <p>Below is the implementation for BiMap.</p> <pre><code>class BiMap {\nprivate:\nunordered_map&lt;char, char&gt; front;\nunordered_map&lt;char, char&gt; back;\npublic:\nBiMap() {}\nvoid put(char key, char value) {\nfront.insert({key, value});\nback.insert({value, key});\n}\nchar checkFront(char key) {\nif (front.find(key) == front.end()) return '~';\nreturn front[key];\n}\nchar checkBack(char value) {\nif (back.find(value) == back.end()) return '~';\nreturn back[value];\n}\n};\n</code></pre> <p>Now using that BiMap we'll solve the problem.</p> <pre><code>class Solution {\nprivate:\nbool findMatching(string word, string pattern) {\nif (word.size() != pattern.size()) return false;\nint index = 0;\nBiMap b = BiMap();\nwhile (index &lt; pattern.size()) {\nchar charFromWord = word[index];\nchar charFromPattern = pattern[index];\n// if bimap returns ~ means it is not in the bimap\n// if both front and back returns ~ that means this is a new character\nif (b.checkFront(charFromWord) == '~' and b.checkBack(charFromPattern) == '~')\nb.put(charFromWord, charFromPattern);\n// else if checkFront and checkBack should return identical mapping\n// m-&gt;a and a-&gt;m\n// check if it is the same with the pattern?\nif (b.checkFront(charFromWord) != charFromPattern) {\nreturn false;\n}\nif (b.checkBack(charFromPattern) != charFromWord) {\nreturn false;\n}\nindex++;\n}\nreturn true;\n}\npublic:\nvector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt;&amp; words, string pattern) {\nvector&lt;string&gt; v;\nfor (string str:words) {\nif (findMatching(str, pattern)) {\nv.push_back(str);\n}\n}\nreturn v;\n}\n};\n</code></pre>"},{"location":"heaps/heap-pq/","title":"Priority Queues and Binary Heaps","text":""},{"location":"heaps/heap-pq/#what-are-these-priority-queues","title":"What are these priority queues?","text":"<p>A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first).</p> <p>So as a data structure designer you have the following options to design a priority queue:</p> <ul> <li>An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order.</li> <li>or an binary heap (max heap or min heap)</li> </ul> <p>Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\).</p> <p>Examples of algorithms that can benefit from a priority queue implemented as heap</p> <ul> <li>Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost.</li> <li>A* pathfinding for artificial intelligence.</li> <li>Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet.</li> <li>Heap sorting algorithm.</li> </ul>"},{"location":"heaps/heap-pq/#identification","title":"Identification","text":"<p>You should make and use heap for the problems with the following combination:</p> <ul> <li>K &amp;</li> <li>largest or smallest,</li> <li>and solvable by sorting the input seq.</li> </ul>"},{"location":"heaps/heap-pq/#stl-usage","title":"<code>STL</code> Usage","text":"<p>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a <code>std::vector&lt;T&gt;</code> underneath.</p> <p>A user-provided Compare can be supplied to change the ordering, e.g. using <code>std::greater&lt;T&gt;</code> would cause the smallest element to appear as the <code>top()</code> [Min Heap].</p>"},{"location":"heaps/heap-pq/#functions-to-remember","title":"Functions to remember","text":"<ul> <li><code>top()</code> to get the top of the heap. [either min or max element at the time]</li> <li><code>empty()</code> returns false if the heap is not empty,</li> <li><code>size()</code> number of elements in the heap,</li> <li><code>push()</code> to add element takes \\(O(\\log N)\\) comparisons and then the time for <code>push_back()</code> method for the underlying container. By default the <code>std::vector&lt;T&gt;</code> container is used,</li> <li><code>pop()</code> to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for <code>push_back()</code> method for underlying container.</li> </ul>"},{"location":"heaps/heap-pq/#recommended-use-of-heaps-instead-of-using-stl","title":"Recommended use of heaps instead of using <code>STL</code>","text":"<p>Most likely the input to the problem involving heap is a sequence of numbers given in a <code>std::vector&lt;int&gt;</code>. Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time.</p> <p>I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes.</p> <p>Must watch to follow the following code</p>"},{"location":"heaps/heap-pq/#things-to-look-out-before-you-start","title":"Things to look out before you start","text":"<ul> <li> <p>First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a <code>std::vector&lt;int&gt;</code> to represent in memory.</p> <p></p> </li> <li> <p>In this representation we do not need to store the pointers to the elements for <code>left</code> or <code>right</code>. Instead use the following functions     <pre><code>int left(int index){\n// Assuming 0 based index\nreturn index * 2 + 1;\n}\nint right(int index){\nreturn index * 2 + 2;\n}\n</code></pre></p> </li> <li> <p>Similarly to get the parent element we just have to write the inverse of the upper two functions     <pre><code>int parent(int childIndex){\n// Return floor (index / 2)\nreturn index / 2; // integer division returns floor\n}\n</code></pre></p> </li> </ul> <p>Now that we know how the heap is structured we are ready to implement 3 helper functions.</p> <p>Why are we doing this instead of <code>std::priority_queue&lt;int&gt;</code>?</p> <p>If you have the sequence before you start the function, inserting elements into a new <code>std::priority_queue&lt;int&gt;</code> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector.</p> <p>So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time.</p>"},{"location":"heaps/heap-pq/#heap-build-subroutines","title":"Heap Build Subroutines","text":"<p>There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation.</p> <ul> <li>In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\), cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be?     </li> <li>Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap.</li> </ul>"},{"location":"heaps/heap-pq/#c-code","title":"C++ Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::cout;\nusing std::endl;\n/** \n * Interface: MaxHeapify of std::vector vector, and the violation is at atIndex\n * Only solves a single violation\n * This is for maintaining the heap property\n*/\nvoid maxHeapify(std::vector&lt;int&gt; *vector, int atIndex){\nint leftChildren = atIndex*2 + 1;\nint rightChildren = atIndex*2 + 2;\nint largest = atIndex;\n// Now check of what is larger the left children or the current Index?\nif ((leftChildren &lt; vector-&gt;size()) &amp;&amp; ((*vector)[leftChildren] &gt; (*vector)[largest])){\nlargest = leftChildren;\n}\n// Now check of what is larger the right children or the current Index?\nif ((rightChildren &lt; vector-&gt;size()) &amp;&amp; ((*vector)[rightChildren] &gt; (*vector)[largest])){\nlargest = rightChildren;\n}\n// If some largest is either present in the left or right children means a swap is needed.\nif (largest != atIndex){\nstd::swap((*vector)[atIndex], (*vector)[largest]);\n// Recursively call to maxHeapify the affected children\nmaxHeapify(vector, largest);\n}\n}\n/** \n * Build heap procedure. Runs in O(N) time in-place.\n * Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the\n * tree and runs MAX-HEAPIFY on each one\n*/\nvoid buildHeap(std::vector&lt;int&gt; *vector){\nint heapSize = vector-&gt;size();\nint lastHeadIndex = heapSize / 2 - 1;\nfor (int i = lastHeadIndex; i &gt;= 0; i--) {\nmaxHeapify(vector, i);\n}\n}\n</code></pre>"},{"location":"heaps/heap-pq/#heap-sorting-with-min-heap-implementation","title":"Heap Sorting with min heap implementation","text":"<p>Using min heap we can get the smallest element in \\(O(\\log n)\\) time. For \\(n\\) elements it will take \\(O(n \\log n)\\) time. This is the best a comparison sort can get. This solution takes no extra memory as the <code>out</code> array is filled one by one and the <code>nums</code> array is reduced one by one in the public <code>sortArray()</code> method.</p> <p>The following <code>buildHeap</code> procedure actually builds the min heap in \\(O(N)\\) time in-place. <pre><code>class Solution {\nprivate:\nint leftChild(int index){\nreturn (index * 2) + 1;\n}\nint rightChild(int index){\nreturn (index * 2) + 2;\n}\nvoid minHeapify(vector&lt;int&gt; &amp;nums, int index){\nint smallest = index;\nint leftindex = leftChild(index);\nint rightindex = rightChild(index);\nint size = nums.size();\nif ((leftindex &lt; size) &amp;&amp; (nums[leftindex] &lt; nums[smallest])){\nsmallest = leftindex;\n}\nif ((rightindex &lt; size) &amp;&amp; (nums[rightindex] &lt; nums[smallest])){\nsmallest = rightindex;\n}\nif (smallest != index){\nswap(nums[smallest], nums[index]);\nminHeapify(nums, smallest);\n}\n}\nvoid buildHeap(vector&lt;int&gt; &amp;nums){\nint size = nums.size();\nint lastparent = (size / 2) - 1;\nfor (int i = lastparent; i&gt;=0; i--){\nminHeapify(nums, i);\n}\n}\npublic:\nvector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\nvector&lt;int&gt; out;\nbuildHeap(nums);\nwhile (nums.size()!=0){\nstd::swap(nums[0], nums.back());\nout.push_back(nums.back());\nnums.pop_back();\nminHeapify(nums, 0);\n}\nreturn out;\n}\n};\n</code></pre></p>"},{"location":"heaps/problems/","title":"Heap Problems","text":"<p>Questions discussed</p> <ul> <li>Kth Largest Element in an Array (Medium)</li> <li>Find all K Largest Elements in the array</li> <li>Sort a K Sorted array</li> <li>Find K Closest Elements (Medium)</li> <li>Top K Frequent Elements (Medium)</li> <li>Top K Frequent Elements</li> <li>K Closest Points to Origin</li> </ul>"},{"location":"heaps/problems/#kth-largest-element-in-an-array-medium","title":"Kth Largest Element in an Array (Medium)","text":""},{"location":"heaps/problems/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>"},{"location":"heaps/problems/#examples","title":"Examples","text":"<pre><code>Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n</code></pre>"},{"location":"heaps/problems/#constraints","title":"Constraints","text":"<ul> <li>\\(1 \\leq\\) <code>k</code> &lt;= <code>nums.size()</code> \\(\\leq\\) \\(10^4\\)</li> <li>\\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\)</li> </ul>"},{"location":"heaps/problems/#approach","title":"Approach","text":"<ul> <li>There are several approaches, in which 2 are the most efficient:<ul> <li>use a <code>k</code> size min heap and put values into the heap until sequence runs out.</li> <li>use the <code>buildHeap()</code> approach to build the given sequence into a heap, then remove top k times.</li> </ul> </li> <li>The first approach takes \\(O(N)\\) time and no extra memory.</li> <li>The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory.</li> <li>If you are given a sequence with no ending (data stream) then the second one will be the better approach.</li> <li>Here in the solution we'll be using the second approach.</li> </ul> <pre><code>class Solution {\npublic:\nint findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\nfor (auto i:nums){\nif (minHeap.size() != k){\n// Until the min Heap is not of size `K` push elements\nminHeap.push(i);\n} else {\n// Now the min Heap is of size K. Push one element [it may be the kth largest]\nminHeap.push(i);\n// If not the kth largest it'll be removed\n// Otherwise the k-1th largest will be removed\nminHeap.pop();\n}\n}\nreturn minHeap.top();\n}\n};\n</code></pre>"},{"location":"heaps/problems/#find-all-k-largest-elements-in-the-array","title":"Find all K Largest Elements in the array","text":""},{"location":"heaps/problems/#problem-statement_1","title":"Problem Statement","text":"<p>This problem is a bit different than the previous one. Here you have to return K largest elements from a given sequence. For example</p> <pre><code>flowchart LR\n    10--&gt;12\n    12--&gt;13\n    13--&gt;167\n    167--&gt;46\n    46--&gt;2157</code></pre> <p>For the above sequence the \\(K = 3\\) largest elements should be the following: <pre><code>flowchart LR\n    2157--&gt;167--&gt;46</code></pre></p>"},{"location":"heaps/problems/#approach_1","title":"Approach","text":"<ul> <li>From the above code if we look closely enough, we find that after all the operations done the remaining elements in the <code>k</code> sized heap contains all the elements that are greater or equal to the \\(K^{\\text{th}}\\) largest element in the given sequence.</li> <li>So return all the elements from the heap.</li> </ul>"},{"location":"heaps/problems/#c-code","title":"C++ Code","text":"<pre><code>std::vector&lt;int&gt; kLargestElements(std::vector&lt;int&gt; &amp;vector, int k){\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;\nstd::vector&lt;int&gt; out;\nfor (auto element:vector){\nif (minHeap.size() != k){\nminHeap.push(element);\n} else {\nminHeap.push(element);\nminHeap.pop();\n}\n}\nwhile (!minHeap.empty()){\nout.push_back(minHeap.top());\nminHeap.pop();\n}\nreturn out;\n}\n</code></pre>"},{"location":"heaps/problems/#sort-a-k-sorted-array","title":"Sort a K Sorted array","text":""},{"location":"heaps/problems/#problem-statement_2","title":"Problem Statement","text":"<p>Each element in the array must be within the range k from it's desired position, Now sort the array as efficiently as possible.</p>"},{"location":"heaps/problems/#approach_2","title":"Approach","text":"<ul> <li>For each index, the corresponding sorted element is in the array is within <code>k</code> to the left and <code>k</code> to the right of that index.     </li> <li>Now we make a min-heap of size k+1,</li> <li>Now we push first k+1 elements into the heap.</li> <li>Now for each index extract the min, then slide the window by 1 distance adding the \\((k+1) + 1^{th}\\) element to the heap and remove the min element from the min heap.</li> <li>In the next step do the same with \\((k+1) + 2^{th}\\) element, unitl this pointer reaches to the end.</li> <li>At the end extract the remaining min elements from the heap and add it to the out vector.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n/*\n    \ud83d\uddff Implementation for sorting a k sorted array using heap \ud83d\uddff\n    \ud83d\uddff Input is given a k sorted array [\ud83d\uddff pass by address \ud83d\uddff]\n    \ud83d\uddff returns the sorted array.\n*/\nstd::vector&lt;int&gt; kSortedArray(std::vector&lt;int&gt; &amp;array, int k) {\nint size = array.size();\nint index = 0;\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;\nstd::vector&lt;int&gt; out;\n// initially push k element into the min heap\nint nextuptoK = k + 1;\nwhile (nextuptoK) {\nminHeap.push(array[nextuptoK]);\nnextuptoK--;\n}\n// Now move forward with the array and put one new element into the min heap and\n// pop last element from the min heap [the minimum]. This popped element is the minimum element\n// so put it into the out vector.\nint window_last = k+2;\nwhile (window_last != size) {\nout.push_back(minHeap.top());\nminHeap.pop();\nminHeap.push(array[window_last]);\nwindow_last++;\n}\nwhile(!minHeap.empty()) {\nout.push_back(minHeap.top());\nminHeap.pop();\n}\nreturn out;\n}\n</code></pre>"},{"location":"heaps/problems/#find-k-closest-elements-medium","title":"Find K Closest Elements (Medium)","text":""},{"location":"heaps/problems/#problem-statement_3","title":"Problem Statement","text":"<p>Given a sorted integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.</p> <p>An integer a is closer to x than an integer b if:</p> <ol> <li><code>|a - x| &lt; |b - x|</code></li> <li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li> </ol>"},{"location":"heaps/problems/#examples_1","title":"Examples","text":"<pre><code>Input: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n\nInput: arr = [1,2,3,4,5], k = 4, x = -1\nOutput: [1,2,3,4]\n</code></pre>"},{"location":"heaps/problems/#approach_3","title":"Approach","text":"<ul> <li>One approach could be that we subtract <code>x</code> from each element of the array and return whose difference with \\(x\\) is in \\(\\{0 \\to k\\}\\)</li> <li>Other approach would be to use a heap. Like the previous problem we pushed K <code>largest</code> or <code>smallest</code> elements into the array. Here what we'll do is<ul> <li>Make a minHeap,</li> </ul> </li> </ul>"},{"location":"heaps/problems/#top-k-frequent-elements-medium","title":"Top K Frequent Elements (Medium)","text":""},{"location":"heaps/problems/#problem-statement_4","title":"Problem Statement","text":"<p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p>"},{"location":"heaps/problems/#examples_2","title":"Examples","text":"<pre><code>Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\nInput: nums = [1], k = 1\nOutput: [1]\n</code></pre>"},{"location":"heaps/problems/#constraints_1","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li> <li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li> <li>It is guaranteed that the answer is unique.</li> </ul> <p>Follow up: The algorithm's time complexity must be better than \\(O(n \\log n)\\), where n is the array's size.</p>"},{"location":"heaps/problems/#approach_4","title":"Approach","text":""},{"location":"heaps/problems/#code","title":"Code","text":""},{"location":"heaps/problems/#top-k-frequent-elements","title":"Top K Frequent Elements","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"heaps/problems/#problem-statement_5","title":"Problem Statement","text":"<p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order</p>"},{"location":"heaps/problems/#example","title":"Example","text":"<pre><code>Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n</code></pre> <pre><code>Input: nums = [1,12,2,34,124,124,12,31,23,123,12,312,3,123,123,123,12,31,23,123,123]\nand k = 5\nOutput: [123,12,23,31,124]\n</code></pre>"},{"location":"heaps/problems/#approach_5","title":"Approach","text":"<ul> <li>First we should make an unordered map to find the frequency of all the elements. We do not get that information by just looking at the elements of the array.</li> <li>After that once we have the frequency of all the elements, we'll push elements on to a min heap of size \\(K\\) based on the frequency of those elements.</li> <li>Making the size of the min heap limited to size \\(K\\) helps to keep track only the k most frequent elements, once we have a less frequent element, as it'll on the top of the min heap, we'll perform a heap pop.</li> </ul>"},{"location":"heaps/problems/#code_1","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n// first count all the elements and their occurences\nunordered_map&lt;int, int&gt; map;\nfor (auto i:nums){\nif(map.find(i) == map.end()) {\nmap.insert({i, 1});\n} else {\nmap[i]++;\n}\n}\n// now that we have all the counts we'll do a quick heap implementation\npriority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; minHeap;\nfor (auto it=map.begin(); it!=map.end(); it++) {\nminHeap.push({\nit-&gt;second, it-&gt;first\n});\nif (minHeap.size() &gt; k) {\nminHeap.pop();\n}\n}\n// at the end we have top k elements in the minHeap\nvector&lt;int&gt; answer;\nwhile(!minHeap.empty()) {\nanswer.push_back(minHeap.top().second);\nminHeap.pop();\n}\nreturn answer;\n}\n};\n</code></pre>"},{"location":"heaps/problems/#k-closest-points-to-origin","title":"K Closest Points to Origin","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"heaps/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Given an array of points where \\(\\text{points(i)} = [x_i, y_i]\\) represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).</p> <p>The distance between two points on the X-Y plane is the Euclidean distance (i.e., \\(\\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\\))</p> <p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</p>"},{"location":"heaps/problems/#approach_6","title":"Approach","text":"<ul> <li>We'll use max heap to store the distant points from the origin.</li> <li>To know how much distance they are in we'll make some ID system for each of the points, and calculate the distance between that point and the origin then put it in a hash table along with the ID,</li> <li>Now we'll for each entry in the hashtable we'll put the entry in a max heap (with priority being the distance to the origin), if the max heap size if greater than \\(k\\) then we'll pop from the heap,</li> <li>at last we'll get all the point's IDs remaining in the priority queue and return them via a ID to point lookup.</li> </ul>"},{"location":"heaps/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) {\nvector&lt;int&gt; origin = {0,1};\n// make an ID System to identify each of the points\n// let's say their index in the points array is their ID\n// making map of point IDs and their distance to the origin\n// ID -&gt; distance map\nunordered_map&lt;int, float&gt; distances;\nfor (int i=0; i&lt;points.size(); i++) {\nfloat distance = sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\ndistances.insert({i, distance});\n}\n// now make a priority queue to store the order and at last find k closest points\n// using a max heap we can do that\npriority_queue&lt;pair&lt;float, int&gt;&gt; pq; // Max Heap\nfor (auto v:distances) {\nint id = v.first;\nint distance = v.second;\npq.push({v.second, v.first});\nif (pq.size() &gt; k) {\npq.pop();\n}\n}\n// now the last k means the k closest points are remaining in the pq\nvector&lt;vector&lt;int&gt;&gt; answers;\nwhile (not pq.empty()) {\nauto top = pq.top();\npq.pop();\nvector&lt;int&gt; v = {points[top.second][0], points[top.second][1]};\nanswers.push_back(v);\n}\nreturn answers;\n}\n};\n</code></pre>"},{"location":"implementation/problems/","title":"Codeforces / CSES Implementation Algorithms","text":"<p>These problems are straight forward, has clear algorithms. Great starting point to initate revision when needed.</p> <p>Problems discussed</p> <ul> <li>Dalton the Teacher</li> <li>Distinct Numbers</li> </ul>"},{"location":"implementation/problems/#dalton-the-teacher","title":"Dalton the Teacher","text":"<p>Find the problem on Codeforces</p>"},{"location":"implementation/problems/#problem-statement","title":"Problem Statement","text":"<p>Given array \\(a[n]\\), find a permutation such that \\(a[i] \\neq i \\: \\forall i \\in [n]\\) with minimum number of the following move</p> <ul> <li>Choose \\(i, j\\) arbitarily, then \\(\\textsf{swap}(a[i], a[j])\\).</li> </ul>"},{"location":"implementation/problems/#approach","title":"Approach","text":"<ul> <li>If the length of the number of pairs of bad elements \\(a[i] = i \\mid\\: \\forall i \\in \\{\\textsf{Bad Elements}\\}\\) is even then pairwise swap would be the minimum number of swap needed to achieve the desired permutation.</li> <li>Otherwise do a pairwise swap of the even element than one extra pair swap with the last one.</li> </ul> <p>Hence the following is should get success</p>"},{"location":"implementation/problems/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main () {\nint testcases;\ncin &gt;&gt; testcases;\nwhile (testcases--) {\nint n;\ncin &gt;&gt; n;\nint p[n];\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; p[i];\n}\nvector&lt;int&gt; sadStudentLocations;\nfor (int i = 0; i &lt; n; i++) {\nif (p[i] == i + 1) sadStudentLocations.push_back(i);\n}\nint totalSadStudents = sadStudentLocations.size();\nif (not totalSadStudents) {\ncout &lt;&lt; 0 &lt;&lt; endl;\n} else if (totalSadStudents % 2 == 0) {\ncout &lt;&lt; totalSadStudents / 2 &lt;&lt; endl;\n} else {\ncout &lt;&lt; totalSadStudents / 2 + 1 &lt;&lt; endl;\n}\n}\nreturn 0;\n}\n</code></pre>"},{"location":"implementation/problems/#distinct-numbers","title":"Distinct Numbers","text":"<p>Find the problem in CSES.</p> <p>You are given a list of \\(n\\) integers, and your task is to calculate the number of distinct values in the list.</p>"},{"location":"implementation/problems/#approach_1","title":"Approach","text":"<ul> <li>Use set to include them and return the size of the set. We are using <code>Splitmix64Hash</code> hash to speed up the <code>unordered_set</code> otherwise the testcases are designed to do \\(O(n^2)\\) blow up of the set (ref.).</li> </ul>"},{"location":"implementation/problems/#code_1","title":"Code","text":"<pre><code>using namespace std;\nstruct Splitmix64Hash {\nstatic uint64_t splitmix64(uint64_t x) {\n// http://xorshift.di.unimi.it/splitmix64.c\nx += 0x9e3779b97f4a7c15;\nx = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;\nx = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;\nreturn x ^ (x &gt;&gt; 31);\n}\nsize_t operator()(uint64_t x) const {\nstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\nreturn splitmix64(x + FIXED_RANDOM);\n}\n};\nint main () {\nint n;\ncin &gt;&gt; n;\nunordered_set&lt;int, Splitmix64Hash&gt; s;\nfor (int i = 0; i &lt; n; i++) {\nint x;\ncin &gt;&gt; x;\ns.insert(x);\n}\ncout &lt;&lt; s.size() &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>"},{"location":"recursion/intro/","title":"Introduction to recursion","text":"<p>Recursion is when a [function] calls itself until some condition is met. Following things we need to understand very clearly before proceeding with recursion</p>"},{"location":"recursion/intro/#what-is-this-making-problem-space-smaller-idea","title":"What is this making problem space smaller idea?","text":"<p>We are not specifically looking for to reduce the problem space, instead we'll be making some decisions that will reduce the problem space. Reduction of problem space is a by-product of the decisions that we'll be making in a specific stage of the algorithm.</p> <p>For recursive function calls a new stack space is created and the function will have no memory of what were the variables in the previous function call. To avoid this we use parameterized recursive calls.</p> <p>Note</p> <p><code>static</code> is just a global variable with visibility limited to one function. So if you declare it <code>static</code>, there is exactly one variable shared by all the levels of recursion. Without <code>static</code>, the variable is local, which means each function invocation has its own copy of variable's state.</p>"},{"location":"recursion/intro/#easier-recursion-problems","title":"Easier Recursion problems","text":""},{"location":"recursion/intro/#print-some-useful-information-10-times","title":"Print some useful information 10 times","text":"<p>Following is the code for printing \"something useful\" 10 times with recursion,</p>"},{"location":"recursion/intro/#approach","title":"Approach","text":"<ul> <li>Static and global variables are stored in heap which is shared across all function calls. So we'll store a counter inside the heap to keep track of the counter across all function calls.</li> </ul> <pre><code>void print(){\nstatic int count = 10;\nif (count != 0){\ncout &lt;&lt; \"Something\\n\";\ncount--;\nprint();\n} else {\nreturn;\n}\n}\nint main() {\nprint();\nreturn 0;\n}\n</code></pre>"},{"location":"recursion/intro/#similarly-print-1-to-10-using-recursive-calls","title":"Similarly print 1 to 10 using recursive calls","text":"<pre><code>void print(){\nstatic int count = 10;\nif (count != 0){\ncout &lt;&lt; count &lt;&lt;\"\\n\";\ncount--;\nprint();\n} else {\nreturn;\n}\n}\nint main() {\nprint();\nreturn 0;\n}\n</code></pre>"},{"location":"recursion/intro/#functional-apporach","title":"Functional apporach","text":"<p>In this apporach we will think of the problem [solution] as a recursion tree and the function calls to a smaller problem.</p>"},{"location":"recursion/intro/#example-sum-of-first-n-numbers","title":"Example: Sum of first N numbers","text":"<pre><code>int sumOfFirstNNumbers(int startFrom, int UpTo){\nif (startFrom &lt;= UpTo){\nsum = startFrom + sumOfFirstNNumbers(startFrom+1, UpTo);\n}\nreturn sum;\n}\n// OR\nint sumOfFirstNNumbers_2(int N){\nif (N == 0) return 0;\nreturn N + sumOfFirstNNumbers_static(N - 1);\n}\nint main() {\nstd::cout &lt;&lt; sumOfFirstNNumbers(1, 4);\n}\n</code></pre> <p>Stepwise recursive calls for this apporach.</p> <p></p>"},{"location":"recursion/intro/#other-approaches","title":"Other approaches","text":"<p>Using a static variable that is shared accross multiple function calls also works.</p> <pre><code>int sumOfFirstNNumbers_static(int N){\nstatic int sum = 0; // THIS is the ACCUMULATOR\nif (N == 0) return 0;\nsum += N; // Accumulate the \"N\"s into the SUM.\nsumOfFirstNNumbers_static(N - 1);\nreturn sum;\n}\n</code></pre>"},{"location":"recursion/intro/#reverse-an-array-of-numbers-using-recursive-calls-only","title":"Reverse an array of numbers using recursive calls only","text":"<p>Approach: Add <code>n</code>th element and recursively call the function from 1 to \\(n-1\\), and add \\(n-1^{th}\\) elements to the answer array, again recursively call the function until we reach \\(0^{th}\\) element.</p> <pre><code>std::vector&lt;int&gt; reverse(std::vector&lt;int&gt; &amp;arr, int from, int to){\n// reverse using recursion only\nstatic std::vector&lt;int&gt; ans;\nif (to != -1){\nans.push_back(arr[to]);\nreverse(arr, from, to-1);\n}\nreturn ans;\n}\n</code></pre> <p></p> <p>We can also modify the original to avoid extra spaces. We can swap the last and first elements until first pointer crosses last pointer.</p> <p>The following is \\(O(N)\\) auxiliary space solution.</p>"},{"location":"recursion/intro/#code","title":"Code","text":"<pre><code>void reverse(std::vector&lt;int&gt; &amp;arr, int from, int to){\n// reverse using recursion only\nif (from &lt;= to){\nstd::swap(arr[from], arr[to]);\nreverse(arr, from+1, to-1);\n}\n}\n</code></pre>"},{"location":"recursion/intro/#find-all-the-sub-sequences-that-sums-up-to-k","title":"Find all the sub-sequences that sums up to K.","text":""},{"location":"recursion/intro/#problem-statement","title":"Problem Statement","text":"<p>You'll be given a sequence and with recursive calls find out all the sub-sequences that sum up to K.</p>"},{"location":"recursion/intro/#approach_1","title":"Approach","text":"<ol> <li>First we can either take or not take one element of the sequence,</li> <li>each time we'll check if the number is taken the sum is greater than the required or not,</li> <li>If greater we stop and return else we include it and check if the sum is equal to K?</li> <li>If equal we simply print the sequence.</li> </ol>"},{"location":"recursion/intro/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::cout;\nusing std::endl;\nvoid solver(std::vector&lt;int&gt; &amp;v, int index, int k, int sum){\n// sub-seq whose sum is K from the given sequence V\n// shared across all recursive calls\nstatic std::vector&lt;int&gt; b;\nif (index &gt; v.size() - 1) return;\nif (sum &lt; k){\n// try with the current value\nb.push_back(v[index]);\nsum = sum + v[index];\nsolver(v, index+1, k, sum);\n// again try without the current value\nb.pop_back();\nsum = sum - v[index];\nsolver(v, index+1, k, sum);\n}\nif (sum == k){\nfor (auto i:b){\ncout &lt;&lt; i &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n}\n}\n</code></pre>"},{"location":"recursion/problems/","title":"Recursion, Backtracking and Subset Problems","text":"<p>These pattern of questions include subset formation, backtracking and recursive calls. Almost all of the questions are leetcode medium level questions. Solving these following problems will help people gain a better understanding of</p> <ol> <li>Backtracking,</li> <li>Recursion calls,</li> <li>Subset pattern of questions.</li> </ol>"},{"location":"recursion/problems/#find-all-the-subsets","title":"Find all the subsets","text":"<p>Problem on Leetcode \\(\\to\\)</p> <p>Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.</p>"},{"location":"recursion/problems/#approach","title":"Approach","text":"<p>With basic recursive approach, we first include an element and don't include an element. This is how we can generate all the unique subsets from a given set. We push the subset to the answer only at the last step of the recursion tree when the index reaches to the last element.</p>"},{"location":"recursion/problems/#code","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; answer;\nvoid recurse(vector&lt;int&gt;&amp; v, int index) {\nstatic vector&lt;int&gt; b;\nif (index &gt; v.size() - 1) {\n// Push the subset only at the last step of the recursion tree\nvector&lt;int&gt; c(b); // create a copy of b and add it into answer\nanswer.push_back(c);\nreturn;\n}\n// with the element\nb.push_back(v[index]);\nrecurse(v, index + 1);\n// without the current element\nb.pop_back();\nrecurse(v, index + 1);\n}\npublic:\nvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\nrecurse(nums, 0);\nreturn answer;\n}\n};\n</code></pre>"},{"location":"recursion/problems/#subsets-ii","title":"Subsets II","text":"<p>Subsets II is a little bit different, given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p> <p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>"},{"location":"recursion/problems/#approach_1","title":"Approach","text":"<ul> <li>The approach should be similar to the subset approach, now in order to avoid duplicates in the power set what we can do is the following<ul> <li>We can first sort the input array </li> <li>then skip duplicates while traversing through the array in the recursive calls by instead of skipping 1 index, skip multiple indexes until we can't find a new value.</li> <li>This specific modification helps us avoid duplicates     <pre><code>while(index &lt; nums.size() - 1 and nums[index] == nums[index + 1]){\nindex++;\n}\n</code></pre></li> </ul> </li> <li>Now we can avoid duplicates in the power set.</li> </ul>"},{"location":"recursion/problems/#code_1","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; answer;\nvoid recurse(vector&lt;int&gt;&amp; nums, int index){\nstatic vector&lt;int&gt; b;\nif (index &gt;= nums.size()) {\n// at the end of tree\nvector&lt;int&gt; c(b);\nanswer.push_back(c);\nreturn;\n}\nb.push_back(nums[index]);\nrecurse(nums, index + 1);\nb.pop_back();\nwhile(index &lt; nums.size() - 1 and nums[index] == nums[index + 1]){\nindex++;\n}\nrecurse(nums, index + 1);\n}\npublic:\nvector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\nstd::sort(nums.begin(), nums.end());\nrecurse(nums, 0);\nreturn answer;\n}\n};\n</code></pre>"},{"location":"recursion/problems/#combination-sum","title":"Combination Sum","text":"<p>Problem on Leetcode \\(\\to\\)</p> <p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p> <p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p> <p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>"},{"location":"recursion/problems/#examples","title":"Examples","text":"<pre><code>Input: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nInput: candidates = [2], target = 1\nOutput: []\n</code></pre>"},{"location":"recursion/problems/#constraints","title":"Constraints:","text":"<ul> <li>\\(1 \\leq\\) <code>candidates.length</code> \\(\\leq 30\\)</li> <li>\\(1 \\leq\\) &lt;= <code>candidates[i]</code> \\(\\leq 200\\)</li> <li>All elements of candidates are distinct.</li> <li>\\(1 \\leq\\) <code>target</code> \\(\\leq 500\\)</li> </ul>"},{"location":"recursion/problems/#approach_2","title":"Approach","text":"<ul> <li>We'll create a recursive subroutine called <code>recurse</code> which will recursively find all the sub-sequences that sums up to <code>target</code></li> <li>Recall a similar problem in the intro section where we solved Find all the sub-sequences that sums up to K. But here the problem is little different, here one element can be added multiple times.</li> <li>So we create a modification in the first recursive call: <code>recurse(candidates, target, sum, index);</code>. In this case we are again calling with the same index so that we can check if multiple times we can add the same element.</li> <li>For the case where we are not considering a particular element [as] we are not considering a particular element, we'll simply call the recursive call <code>recurse(candidates, target, sum, index + 1;</code> with \\(\\text{Index} + 1\\).</li> </ul>"},{"location":"recursion/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; answer;\nvoid recurse(vector&lt;int&gt; &amp;candidates, int target, int sum, int index) {\nstatic vector&lt;int&gt; b; // shared data structure\nif (index &gt; candidates.size() - 1) return;\nif (sum &lt; target) {\n// check with the current index\nb.push_back(candidates[index]);\nsum = sum + candidates[index];\nrecurse(candidates, target, sum, index); // can take the same index multiple times\n// remove the current index and check again\nb.pop_back();\nsum = sum - candidates[index];\nrecurse(candidates, target, sum, index+1); // index+1 bcz we are no longer interested with that index\n}\nif (sum == target) {\nvector&lt;int&gt; bk(b);\nanswer.push_back(bk);\n}\n}\nvector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\nrecurse(candidates, target, 0, 0);\nreturn answer;\n}\n};\n</code></pre>"},{"location":"recursion/problems/#combination-sum-iii","title":"Combination Sum III","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"recursion/problems/#problem-statement","title":"Problem Statement","text":"<p>This is a slight modification of the previous problem, find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p> <ul> <li>Only numbers 1 through 9 are used.</li> <li>Each number is used at most once.</li> </ul> <p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>"},{"location":"recursion/problems/#approach_3","title":"Approach","text":"<p>Similar to the last problem we'll continue with a recursive approach and use a shared data structure <code>b</code> to keep track of the combinations. The code will be the almost same as the previous problem but we'll include the answer if and only if the size of the answer is equal to <code>k</code> according to the question specifications.</p> <p>For candidates the question says they are \\(1 \\to 9\\), but we'll include \\(10\\) because the following test case will fail if we don't include \\(10\\). Figure out why on your own. (Hint: draw the recursion tree)</p> <pre><code>TEST CASE FAILURE:\ntarget = 45\nk = 9\n\nACTUAL RESULT SHOULD BE RETURENED:\n[1,2,3,4,5,6,7,8,9]\n\nFailure: fails to return the result if the candidates are {1 to 9}\n</code></pre>"},{"location":"recursion/problems/#code_3","title":"Code","text":"<pre><code>class Solution {\nprivate:\nvector&lt;vector&lt;int&gt;&gt; answer;\nvoid build(int k, int target, int sum, int index, vector&lt;int&gt;&amp; candidates) {\n// shared data structure across recursion\nstatic vector&lt;int&gt; b;\nif (index &gt; candidates.size() - 1) return;\nif (sum &lt; target) {\nb.push_back(candidates[index]);\nbuild(k, target, sum+candidates[index], index+1, candidates);\nb.pop_back();\nbuild(k, target, sum, index+1, candidates);\n}\nif (sum == target and b.size() == k) {\nvector&lt;int&gt; lvl(b);\nanswer.push_back(lvl);\n}\n}\npublic:\nvector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {\nvector&lt;int&gt; candidates = {1,2,3,4,5,6,7,8,9,10};\nbuild(k, n, 0, 0, candidates);\nreturn answer;\n}\n};\n</code></pre>"},{"location":"stacks/problems/","title":"Stack Problems","text":"<p>Problem Index</p> <ul> <li>Nearest greater to right or Next Largest Element</li> <li>Next Greater Element I</li> <li>Nearest greater to left (NGEle)</li> <li>Nearest smaller to left (NSEle)</li> <li>Minimum Stack with extra space</li> <li>Stock Span Problem</li> <li>Maximum Area Histogram</li> <li>Max Area Rectangle under binary matrix</li> <li>The Skyline problem</li> <li>Score of Parentheses</li> <li>Implement a stack with single queue</li> <li>Cd and pwd commands</li> </ul> <p>Patterns of questions when to use a stacks.</p> <p>Using Same concept</p> <ul> <li>Nearest greater to right or Next Largest Element</li> <li>Nearest greater to left</li> <li>Nearest smaller to right</li> <li>Nearest smaller to left</li> </ul> <p>Using the code from the previous concept</p> <ul> <li>Stock Span Problem</li> <li>Maximum area of histgram</li> </ul> <p>Using the code from the previous two concepts</p> <ul> <li>Max area of rectangle in binary matrix</li> </ul> <p>Other good problems on stack</p> <ul> <li>Rain water trapping</li> <li>Implement Min stack with or without extra space</li> </ul> <p>For problems with array think of using stacks, also for problems that uses nested <code>for loops</code> and the inner <code>for</code> loop is dependent upon the outer <code>for</code> loop like the following</p> <p><pre><code>for (int i; i&lt; n; i++){\nfor(int j; j -&gt; 0 to i; j++);\nfor(int j; j -&gt; i to 0; j--);\nfor(int j; j -&gt; i to n; j++);\nfor(int j; j -&gt; n to i; j--);\n}\n</code></pre> there is a huge chance that a stack data structure can be used to optimize the solution.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#nearest-greater-to-right-or-next-largest-element","title":"Nearest greater to right or Next Largest Element","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement","title":"Problem statement","text":"<p>Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. </p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#examples","title":"Examples","text":"<p>Input Array: <code>[4, 5, 2, 25]</code> <pre><code>Element       NGE\n   4      --&gt;   5\n   5      --&gt;   25\n   2      --&gt;   25\n   25     --&gt;   -1\n</code></pre></p> <p>Input Array: <code>[1, 3, 2, 4]</code> <pre><code>Element       NGE\n   1     --&gt;   3\n   3     --&gt;   4\n   2     --&gt;   4\n   4     --&gt;   -1\n</code></pre></p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#brute-force-approach","title":"Brute Force approach","text":"<ul> <li>Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i.</li> <li>This is a pattern for nested <code>for loops</code> and the inner <code>for</code> loop is dependent upon the outer <code>for</code> loop. So we can use a stack to optimize the solution.</li> </ul> <pre><code>def brute_force_NGE(array: list[int]) -&gt; None:\nfor i in range(len(array)):\nfor j in range(i+1, len(array)):\n# ...\npass\n# ...\npass\nreturn None\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#optimized-solution-with-stacks","title":"Optimized solution with Stacks","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#stack-implementation","title":"Stack implementation","text":"<pre><code>from collections import deque\nclass Stack:\ndef __init__(self):\nself.container = deque()\ndef pop(self):\nreturn self.container.pop()\ndef push(self, value):\nself.container.append(value)\ndef tos(self):\nreturn self.container[-1] if self.container else -1\ndef isEmpty(self):\nreturn len(self.container) == 0\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#optimized-apporach-with-stacks","title":"Optimized apporach with stacks","text":"<ul> <li>We start from the very last, and maintain a stack.</li> <li>if the stack is empty means that there is no element that is just greater to the right of this element so return -1</li> <li>if we don't find anything then push the element onto the stack.</li> <li>if the <code>a[i]</code> element is &lt; the top of the stack means that <code>tos()</code> is the next greater element,</li> <li>if the <code>a[i]</code> is &gt; the top of the stack then we <code>pop()</code> from the stack to find if there is any element &gt; the <code>a[i]</code>, if not return -1.</li> </ul> <pre><code>def NGE(array):\nstack = Stack()\nreturnarray = []\nend = len(array) - 1\nwhile end &gt;= 0:  # unitl we reach to the front\nif stack.isEmpty():\nstack.push(array[end])\nreturnarray.append(-1)\nelse:\nwhile not stack.isEmpty() and stack.tos() &lt;= array[end]:\nstack.pop()\nif stack.isEmpty():\nstack.push(array[end])\nreturnarray.append(-1)\nelif stack.tos() &gt; array[end]:\nreturnarray.append(stack.tos())\nstack.push(array[end])\nend -= 1\nreturn returnarray[::-1]\n</code></pre> <pre><code>from rich.console import Console\nconsole = Console()\nconsole.print(NGE([1, 3, 2, 4]))\n</code></pre> <pre><code>console.print(NGE([4, 5, 2, 25]))\n</code></pre> <pre><code>console.print(NGE([3, 2, 1, 0, 2, 4, 2, 6, 9]))\nconsole.print(NGE([3, 2, 11, -0.4, 2, 4, 2, 6, 91]))\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#next-greater-element-i","title":"Next Greater Element I","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_1","title":"Problem Statement","text":"<p>The next greater element of some element \\(x\\) in an array is the first greater element that is to the right of \\(x\\) in the same array.</p> <p>You are given two distinct <code>0</code>-indexed integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p> <p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index j such that <code>nums1[i] == nums2[j]</code> and determine the next greater element of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is \\(-1\\).</p> <p>Return an array ans of length nums1.length such that <code>ans[i]</code> is the next greater element as described above.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#example","title":"Example","text":"<pre><code>Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach","title":"Approach","text":"<p>We'll use the up above technique (usage of stacks) to find the next greater element to the right.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\nvector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\nstd::unordered_map&lt;int, int&gt; nge;\nvector&lt;int&gt; stack;\nint last = nums2.back();\nstack.push_back(last);\nnge[last] = -1;\nint size = nums2.size();\nfor (int i = size - 2; i &gt;= 0; i--) {\nwhile (not stack.empty() and nums2[i] &gt; stack.back()) {\nstack.pop_back();\n}\nif (stack.empty()) {\nnge[nums2[i]] = -1;\n} else if (nums2[i] &lt; stack.back()) {\nnge[nums2[i]] = stack.back();\n}\nstack.push_back(nums2[i]);\n}\nvector&lt;int&gt; answer;\nfor (int i:nums1) {\nanswer.push_back(nge[i]);\n}\nreturn answer;\n}\n};\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#nearest-greater-to-left-ngele","title":"Nearest greater to left (NGEle)","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_2","title":"Problem statement","text":"<p>Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. </p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#examples_1","title":"Examples","text":"<p>Input Array: <code>[4, 5, 2, 25]</code> <pre><code>Element       NGEle\n   4      --&gt;   -1\n   5      --&gt;   -1\n   2      --&gt;   5\n   25     --&gt;   -1\n</code></pre></p> <p>Input Array: <code>[1, 3, 2, 4]</code> <pre><code>Element       NGEle\n   1     --&gt;   -1\n   3     --&gt;   -1\n   2     --&gt;   3\n   4     --&gt;   -1\n</code></pre></p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_1","title":"Approach","text":"<ul> <li>Similar to the NGE but we start from the left because we have to operate on the left sub-array.</li> </ul> <pre><code>from collections import deque\nclass Stack:\ndef __init__(self):\nself.s = deque()\ndef push(self, value):\nself.s.append(value)\ndef pop(self):\nreturn self.s.pop()\ndef tos(self):\nreturn self.s[-1]\ndef isEmpty(self):\nreturn len(self.s) == 0\ndef NGEle(array: list[int]):\nlast = len(array)\nout = []\nstack = Stack()\nfor i in range(0, last):\nif stack.isEmpty():\nstack.push(array[i])\nout.append(-1)\nelse:\nwhile not stack.isEmpty() and stack.tos() &lt; array[i]:\nstack.pop()\nif stack.isEmpty():\nstack.push(array[i])\nout.append(-1)\nelif stack.tos() &gt; array[i]:\nout.append(stack.tos())\nstack.push(array[i])\nreturn out\n</code></pre> <pre><code>print(NGEle([4, 5, 2, 25]))    # --&gt; [-1, -1, 5, -1]\n</code></pre> <pre><code>print(NGEle([1, 3, 2, 4]))    # --&gt; [-1, -1, 3, -1]\n</code></pre> <pre><code>print(NGEle([4, 5, 2, 0.5, 25]))\nprint(NGEle([1]), NGEle([]), NGEle([-13, -12, -11, -10])) # Some corner cases\n</code></pre> <pre><code>[-1, -1, 5, 2, -1]\n[-1] [] [-1, -1, -1, -1]\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#nearest-smaller-to-left-nsele","title":"Nearest smaller to left (NSEle)","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_3","title":"Problem statement","text":"<p>Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. </p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#examples_2","title":"Examples","text":"<p>Input Array: <code>[4, 5, 2, 25]</code> <pre><code>Element       NSEle\n   4      --&gt;   -1\n   5      --&gt;   4\n   2      --&gt;   -1\n   25     --&gt;   2\n</code></pre></p> <p>Input Array: <code>[1, 3, 2, 4]</code> <pre><code>Element       NSEle\n   1     --&gt;   -1\n   3     --&gt;   1\n   2     --&gt;   1\n   4     --&gt;   2\n</code></pre></p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_2","title":"Approach","text":"<ul> <li>Drop the bad Brute force approach, we should use a stack</li> <li>Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\)</li> <li>For each element check the left sub-array using a stack.</li> <li>Pop elements out of the stack if they are greater and push the current element.</li> <li>return -1 for empty stack and <code>tos()</code> if we find elements lesser (i.e. the lesser element).</li> </ul> <pre><code>from collections import deque\nclass Stack:\ndef __init__(self):\nself.s = deque()\ndef pop(self):\nreturn self.s.pop()\ndef isEmpty(self):\nreturn len(self.s) == 0\ndef push(self, value):\nself.s.append(value)\ndef tos(self):\nreturn self.s[-1]\ndef NSEle(array: list[int]) -&gt; list[int]:\nend = len(array)\nstack = Stack()\nout = []\nfor i in range(0, end):\nif stack.isEmpty():\nstack.push(array[i])\nout.append(-1)\nelse:\nwhile not stack.isEmpty() and (stack.tos() &gt; array[i]):\nstack.pop()\nif stack.isEmpty():\nstack.push(array[i])\nout.append(-1)\nelif stack.tos() &lt; array[i]:\nout.append(stack.tos())\nstack.push(array[i])\nreturn out\n</code></pre> <p><pre><code>print(NSEle([4, 5, 2, 25]))\nprint(NSEle([1, 3, 2, 4]))\nprint(NSEle([4, 5, 2, 0.5, 25]))\nprint(NSEle([-13, -12, -11, -10]))\nprint(NSEle([1]), NSEle([]), NSEle([13, 12, 11, 10])) # Some corner cases\n</code></pre> <pre><code>[-1, 4, -1, 2]\n[-1, 1, 1, 2]\n[-1, 4, -1, -1, 0.5]\n[-1, -13, -12, -11]\n[-1] [] [-1, -1, -1, -1]\n</code></pre></p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#minimum-stack-with-extra-space","title":"Minimum Stack with extra space","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_4","title":"Problem Statement","text":"<p>Implement a stack with the following methods:</p> <ol> <li><code>MinimumStack()</code> constructs a new instance of a minimum stack</li> <li><code>append(int val)</code> appends val to the stack</li> <li><code>peek()</code> retrieves the last element in the stack</li> <li><code>min()</code> retrieves the minimum value in the stack</li> <li><code>pop()</code> pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called.</li> </ol>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#constraints","title":"Constraints","text":"<p>\\(n \u2264 100000\\) where <code>n</code> is the number of calls to append, peek, min, and pop.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_3","title":"Approach","text":"<ul> <li>We'll use a two stack approach, one to keep track of all the stack elements (<code>self.container</code>) and an auxiliary stack to keep track all the minimum elements.</li> <li>Whenever we find a new <code>min</code> element we'll push it into the <code>self.aux</code> stack.</li> <li>When we find <code>pop()</code> and find same <code>tos()</code> for <code>self.container</code> and <code>self.aux</code> means that the current minimum element is being <code>popped</code> off. So we <code>pop()</code> from both.</li> </ul> PythonC++ <pre><code>class MinimumStack:\ndef __init__(self):\nself.container = deque()\nself.aux = deque()\ndef append(self, val):\nself.container.append(val)\nif len(self.aux) == 0:\nself.aux.append(val)\nelif len(self.aux) &gt; 0 and val &lt; self.aux[-1]:\nself.aux.append(val)\ndef peek(self):\nreturn self.container[-1]\ndef min(self):\nreturn self.aux[-1]\ndef pop(self):\nif self.aux[-1] == self.container[-1]:\nk = self.container.pop()\nself.aux.pop()\nreturn k\nelse:\nreturn self.container.pop()\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nclass MinStack{\nprivate:\nvector&lt;int&gt; stack;\nvector&lt;int&gt; auxStack;\nint ClassPrivateSize;\npublic:\nMinStack(){\nClassPrivateSize = 0;\n}\nint size(){\nreturn ClassPrivateSize;\n}\nvoid push(int value){\nif (ClassPrivateSize == 0){\nstack.push_back(value);\nauxStack.push_back(value);\nClassPrivateSize += 1;\n}else{\nif (value &lt; auxStack.back()){\nstack.push_back(value);\nauxStack.push_back(value);\n}else{\nstack.push_back(value);\n}\nClassPrivateSize += 1;\n}\n}\nint pop(){\nif (ClassPrivateSize == 0){\nthrow runtime_error(\"pop(): Empty Stack\");\n}else{\nif (auxStack.back() == stack.back()){\nint value = stack.back();\nauxStack.pop_back();\nstack.pop_back();\nreturn value;\n}else{\nint value = stack.back();\nstack.pop_back();\nreturn value;\n}\nClassPrivateSize -=1;\n}\n}\nbool isEmpty() const{\nif (ClassPrivateSize == 0){\nreturn true;\n}\nreturn false;\n}\nint min(){\nreturn auxStack.back();\n}\nint peek() {\nreturn stack.back();\n}\n};\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#time-complexity","title":"Time Complexity","text":"<ul> <li><code>push()</code> takes \\(\\mathcal{O}(1)\\)</li> <li><code>pop()</code> takes \\(\\mathcal{O}(1)\\)</li> <li><code>min()</code> takes \\(\\mathcal{O}(1)\\)</li> <li><code>peek()</code> takes \\(\\mathcal{O}(1)\\)</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#space-complexity","title":"Space Complexity","text":"<p>At the very worst total space complexity is \\(\\mathcal{O}(N)\\)</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#stock-span-problem","title":"Stock Span Problem","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_5","title":"Problem Statement","text":"<p>Equivalent problems are on LeetCode and GeeksForGeeks</p> <ul> <li>The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days.</li> <li>The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day. </li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#example-testcase","title":"Example testcase","text":"<p>For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\), then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\). For simplicity,</p> <ul> <li>For day \\(1\\), no days are before this day that has more than this day's stock value so return \\(1\\)</li> <li>For day \\(3\\), no days are before this day that has more than this day's stock value so return \\(1\\)</li> <li>For day \\(4\\), there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\)</li> <li>For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\). So return \\(5+1 =6\\)</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_4","title":"Approach","text":"<p>If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was?</p> <p>So the apporach should be</p> <ul> <li>Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space.</li> <li>Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple.</li> <li>Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs.</li> <li>Now for the <code>stockSpan()</code> function we will return the difference between the position of current element and the position of the NGEle element.</li> </ul> <p> </p> Stock Span Problem Brainstorm! <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; NGEle(vector&lt;int&gt; vect){\n// Return a pair with NGEle and the position of the NGEle.\nvector&lt;pair&lt;int, int&gt;&gt; out;\n// While storing the values into stack just add the current index to keep track\n// of where the NGEle is located.\nvector&lt;pair&lt;int, int&gt;&gt; stack;\n// Common NGEle Code [it's the same lolzzzzz].\nint index = 0;\nfor (int element:vect){\nif (stack.size() == 0){\nout.push_back({-1, -1});\nstack.push_back({element, index});\n}else{\nwhile ((stack.size() != 0) &amp;&amp; (stack.back().first &lt; element)){\nstack.pop_back();\n}\nif (stack.size() == 0){\nout.push_back({-1, index});\nstack.push_back({element, index});\n}else if (stack.back().first &gt; element){\nout.push_back({stack.back().first,stack.back().second});\nstack.push_back({element, index});\n}\n}\nindex++;\n}\nreturn out;\n}\nvector&lt;int&gt; stockSpan(vector&lt;int&gt; marketCap){\n// find NGEle Values for each day along with their indexes.\nvector&lt;pair&lt;int, int&gt;&gt; ngele = NGEle(marketCap);\nvector&lt;int&gt; out;\nint idx = 0;\n// Now for each element find the distance between it and it's NGEle.\nfor (auto i: ngele){\nif (i.second != -1){\nout.push_back(idx - i.second + 1);\n}else{\nout.push_back(1);\n}\nidx++;\n}\nreturn out;\n}\n</code></pre> <p>Let's test the code out. Run the following code to see the code working. <pre><code>int main(){\nvector&lt;int&gt; v = {100, 70, 85, 59, 15, 60, 87};\nvector&lt;pair&lt;int, int&gt;&gt; ngele = NGEle(v);\nvector&lt;int&gt; stkspan = stockSpan(v);\ncout &lt;&lt; \"Market CAP\" &lt;&lt;endl;\nfor (auto j: v)\ncout &lt;&lt; j &lt;&lt; \" \";\ncout &lt;&lt; endl;\ncout &lt;&lt; endl;\n// ngele Array\nfor (auto i: ngele){\ncout &lt;&lt; i.first &lt;&lt; \" from: \" &lt;&lt; i.second &lt;&lt; \"\\n\";\n}\ncout &lt;&lt; endl;\ncout &lt;&lt; \"Stock Span\" &lt;&lt;endl;\nfor (auto h: stkspan)\ncout &lt;&lt; h &lt;&lt; \" \";\ncout &lt;&lt; endl;\nreturn 0;\n}\n</code></pre></p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#time-complexity_1","title":"Time Complexity","text":"<p>At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the <code>marketCap</code> vector only once during the subroutine <code>NGEle()</code> and once in the subroutine <code>stockSpan()</code>.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#space-complexity_1","title":"Space Complexity","text":"<p>Space complexity is \\(O(\\mathcal{N})\\).</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#maximum-area-histogram","title":"Maximum Area Histogram","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Similar problem on Leetcode</p> <p>Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\), return the area of the largest rectangle in the histogram.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#examples_3","title":"Examples","text":"<pre><code>Input: heights = [2,1,5,6,2,3]\nOutput: 10\n\nExplanation: \nThe above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#thought-process","title":"Thought process","text":"Brainstorm!","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_5","title":"Approach","text":"Proper Approach!","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#time-and-space-complexity","title":"Time and Space complexity","text":"<p>\\(O(\\mathcal{N})\\) time and space is taken.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#code_1","title":"Code","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#subroutines","title":"Subroutines","text":"<p>Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#nsr-nse-nearest-smaller-to-the-right-implementation","title":"NSR (NSE, Nearest smaller to the Right) implementation","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::vector;\nusing std::pair;\nvector&lt;pair&lt;int, int&gt;&gt; NSE(vector&lt;int&gt; vect){\n// Nearest smallest to the right\n// finds and returns NSE array pair.first -&gt; value\n// pair.second -&gt; index of the NSE element\nvector&lt;pair&lt;int, int&gt;&gt; out;\nvector&lt;pair&lt;int, int&gt;&gt; stack;\nint last = vect.size() - 1;\nwhile (last != -1){\nif (stack.size() == 0){\nout.push_back({-1, -1});\nstack.push_back({vect[last], last});\n}else{\nwhile ((stack.size() != 0) &amp;&amp; (stack.back().first &gt;= vect[last])){\nstack.pop_back();\n}\nif (stack.size() == 0){\nout.push_back({-1, -1});\nstack.push_back({vect[last], last});\n}else if (stack.back().first &lt; vect[last]){\nout.push_back({stack.back().first, stack.back().second});\nstack.push_back({vect[last], last});\n}\n}\nlast--;\n}\nreturn out;\n}\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#nsele-nearest-smaller-to-the-left-implementation","title":"NSEle (Nearest smaller to the left) implementation","text":"<pre><code>vector&lt;pair&lt;int, int&gt;&gt; NSEle(vector&lt;int&gt; vect){\nvector&lt;pair&lt;int, int&gt;&gt; out;\nvector&lt;pair&lt;int, int&gt;&gt; stack;\nint start = 0;\nwhile (start != vect.size()){\nif (stack.size() == 0){\nout.push_back({-1, -1});\nstack.push_back({vect[start], start});\n}else{\nwhile ((stack.size() != 0) &amp;&amp; (stack.back().first &gt;= vect[start])){\nstack.pop_back();\n}\nif (stack.size() == 0){\nout.push_back({-1, -1});\nstack.push_back({vect[start], start});\n}else if (stack.back().first &lt; vect[start]){\nout.push_back({stack.back().first, stack.back().second});\nstack.push_back({vect[start], start});\n}\n}\nstart++;\n}\nreturn out;\n}\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#the-main-function-maxareahistogram","title":"The main function <code>maxAreaHistogram()</code>","text":"<pre><code>void maxAreaHistogram(vector&lt;int&gt; v){\nvector&lt;int&gt; out;\nvector&lt;pair&lt;int, int&gt;&gt; nsr = NSE(v);\n// NSR has to-be reverse because we started from the begining\nstd::reverse(nsr.begin(), nsr.end());\nvector&lt;pair&lt;int, int&gt;&gt; nsele = NSEle(v);\nint currentMax = -1;\nint index = 0;\nint currentArea = 0;\nfor (int i:v){\nif ((nsr[index].first != -1) &amp;&amp; (nsele[index].first != -1)){\n// Both upper and lower bound is within the array\n// Start from left bound + 1\n// end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller)\ncurrentArea = i * ((nsr[index].second - 1) - (nsele[index].second + 1) + 1);\n}else if ((nsr[index].first == -1) &amp;&amp; (nsele[index].first != -1)){\n// right side -&gt; -1 no smaller element to the right\n// Start from left bound + 1, (don't consider the left bound)\n// end at last\ncurrentArea = i * (v.size()-1 - (nsele[index].second + 1) + 1);\n}else if ((nsele[index].first == -1) &amp;&amp; (nsr[index].first != -1)){\n// No bound to the left\n// So from index zero -&gt; the upper bound\ncurrentArea = i * (nsr[index].second - 1 + 1);\n}else{\n// No bound at all -&gt; size * magnitude\ncurrentArea = i * (v.size());\n}\nout.push_back(currentArea);\nindex++;\n}\nfor (auto value:out)\nstd::cout &lt;&lt; BOLDBLUE &lt;&lt; value &lt;&lt; \" \";\nstd::cout &lt;&lt; std::endl;\n}\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#testing-the-code-out","title":"Testing the code out","text":"<pre><code>int main(){\n// testsForNSE();\n// testsForNSEle();\nvector&lt;int&gt; v = {1, 2, 3, 1, 2, 3, 4, 5, 5, 5};\nstd::cout &lt;&lt; BOLDCYAN &lt;&lt; \"TEST CASE 1\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v);\nvector&lt;int&gt; v1 = {2,1,5,6,2,3};\nstd::cout &lt;&lt; BOLDYELLOW &lt;&lt; \"TEST CASE 2\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v1);\nvector&lt;int&gt; v2 = {2,4,1,4,4,5};\nstd::cout &lt;&lt; BOLDMAGENTA &lt;&lt; \"TEST CASE 4\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v2);\nvector&lt;int&gt; v12 = {5,5,5,5,5,2,4,2,1};\nstd::cout &lt;&lt; BOLDGREEN &lt;&lt; \"TEST CASE 3\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v12);\nvector&lt;int&gt; v23 = {3,2,1};\nstd::cout &lt;&lt; BOLDMAGENTA &lt;&lt; \"TEST CASE 4\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v23);\nvector&lt;int&gt; v231 = {10, 9, 8, 7};\nstd::cout &lt;&lt; BOLDRED &lt;&lt; \"TEST CASE 4\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v231);\nvector&lt;int&gt; v2321 = {7,8,9,10};\nstd::cout &lt;&lt; BOLDMAGENTA &lt;&lt; \"TEST CASE 4\" &lt;&lt; RESET &lt;&lt; std::endl;\nmaxAreaHistogram(v2321);\nreturn 0;\n}\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#output","title":"Output","text":"<pre><code>TEST CASE 1\n10 4 3 10 12 15 16 15 15 15 \n\nTEST CASE 2\n2 6 10 6 8 3 \n\nTEST CASE 4\n4 4 6 12 12 5 \n\nTEST CASE 3\n25 25 25 25 25 16 4 16 9 \n\nTEST CASE 4\n3 4 3 \n\nTEST CASE 4\n10 18 24 28 \n\nTEST CASE 4\n28 24 18 10 \n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#max-area-rectangle-under-binary-matrix","title":"Max Area Rectangle under binary matrix","text":"<p>Problem On leetcode \\(\\to\\)</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_7","title":"Problem Statement","text":"<p>Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\), where all elements in \\(R = 1\\)</p> <p></p> <p>Explanation</p> <p>Input: matrix = <code>[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]</code></p> <p>Output: 6</p> <p>Explanation: The maximal rectangle is shown in the above picture.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#constraints_1","title":"Constraints:","text":"<ul> <li><code>rows</code> == <code>matrix.length</code></li> <li><code>cols</code> == <code>matrix[i].length</code></li> <li>1 &lt;= <code>row, cols</code> &lt;= 200</li> <li><code>matrix[i][j]</code> is \\(0\\) or \\(1\\).</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_6","title":"Approach","text":"Proper Approach! <ul> <li>We should start with creating histogram for each level.</li> <li>Then we call the <code>MAH()</code> algorithm implemented in the previous question.</li> <li>Then we find the maximum accross all levels.</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#the-skyline-problem","title":"The Skyline problem","text":"<p>Same Problem on Leetcode \\(\\to\\)</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_8","title":"Problem Statement","text":"<p>A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#score-of-parentheses","title":"Score of Parentheses","text":"<p>Problem on leetcode \\(\\to\\)</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_9","title":"Problem Statement","text":"<p>Given a balanced parentheses string s, return the score of the string - \"()\" has score 1, - AB has score A + B, where A and B are balanced parentheses strings, - (A) has score 2 * A, where A is a balanced parentheses string.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#examples_4","title":"Examples","text":"<pre><code>Input: s = \"()\"\nOutput: 1\n\nInput: s = \"(())\"\nOutput: 2\n\nInput: s = \"()()\"\nOutput: 2\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#constraints_2","title":"Constraints","text":"<ul> <li>\\(2\\) &lt;= <code>s.length</code> &lt;= \\(50\\)</li> <li><code>s</code> consists of only <code>'('</code> and <code>')'</code>.</li> <li><code>s</code> is always a balanced parentheses string.</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_7","title":"Approach","text":"<ul> <li>Using recursion because seems like a recursive problem with pattern of <code>return (what is inside of(what is inside of (what is inside)))</code>.</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#c-code","title":"C++ code","text":"<pre><code>class Solution {\nprivate:\nint globalTracker = 0;\npublic:\nint scoreOfParentheses(string s) {\nint score = 0;\n// Using recursion bcz seems like a recursive problem\n// return (what is inside of(what is inside of (what is inside)))\nwhile(globalTracker &lt; s.size() - 1){\nchar first = s.at(globalTracker);\nglobalTracker++;\nchar second = s.at(globalTracker);\nif (first == '('){\nif (second == ')'){\nscore = score + 1;\nglobalTracker++;\n} else {\nscore = score + 2 *(scoreOfParentheses(s));\n}\n} else {\nreturn score;\n}\n}\nreturn score;\n}\n};\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#implement-a-stack-with-single-queue","title":"Implement a stack with single queue","text":"<p>Find the problem on leetcode</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_10","title":"Problem Statement","text":"<p>Implement a last-in-first-out (LIFO) stack using only single queue. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>). Implement the MyStack class</p> <ul> <li><code>void push(int x)</code> Pushes element \\(x\\) to the top of the stack.</li> <li><code>int top()</code> Returns the element on the top of the stack.</li> <li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li> <li><code>boolean empty()</code> Returns true if the stack is empty, false otherwise.</li> </ul>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#apporach","title":"Apporach","text":"<p>It is easy to implement a stack with two queues. But the question requires us to use a single queue for storage. Our apporach will be the following:</p> <p>Once a value comes to our stack we'll insert it into the internal queue, then from \\(i \\in \\{0 \\dots size - 1\\}\\) times we'll take the front of the queue and push it to the back of the queue. Then <code>pop</code> from the front of the queue. This will rearange the queue to have the data ordered like a stack.</p> <p>Thus our <code>queue.front()</code> will return the element on the top of the stack and <code>queue.pop()</code> will pop the top of the stack.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#code_2","title":"Code","text":"<pre><code>class MyStack {\npublic:\nqueue&lt;int&gt; q;\nint size = 0;\nMyStack() {}\nvoid push(int x) {\nsize++;\nq.push(x);\nfor (int i = 0; i &lt; size - 1; i++) {\nq.push(q.front());\nq.pop();\n}\n}\nint pop() {\nint val = q.front();\nq.pop();\nsize--;\nreturn val;\n}\nint top() {\nreturn q.front();\n}\nbool empty() {\nreturn size == 0;\n}\n};\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#cd-and-pwd-commands","title":"Cd and pwd commands","text":"","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#problem-statement_11","title":"Problem Statement","text":"<p>Implement the Unix like <code>cd</code> and <code>pwd</code> commands. - <code>pwd</code> of root should return <code>/</code>, - <code>cd /home/vasya</code> will go to <code>cd /home/vasya</code>, then if we do <code>cd /home/theroyakash</code> it'll go to root and then go to <code>home</code> to <code>theroyakash</code>, - <code>cd /home/vasya</code> and then <code>cd home/theroyakash</code> sends present working directory to <code>cd /home/vasya/home/theroyakash</code>, notice that second <code>cd</code> do not start with <code>/</code>.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#approach_8","title":"Approach","text":"<p>Standard Stack approach.</p>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/problems/#code_3","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n/*\n * Tokenise a string of path to individual folders\n * eg. /home/theroyakash/go should return &lt;home, theroyakash, go&gt;\n*/\nvector&lt;string&gt; tokenize(string s, char delimeter) {\nint size = s.size();\nvector&lt;string&gt; tokens;\nstring current = \"\";\nfor (int i = 0; i &lt; size; i++) {\nif (s[i] == delimeter and current != \"\") {\ntokens.push_back(current);\ncurrent = \"\";\n} else if (s[i] != delimeter){\ncurrent += s[i];\n}\n}\ntokens.push_back(current);\nreturn tokens;\n}\nint main() {\nint commands;\ncin &gt;&gt; commands;\nvector&lt;string&gt; stack;\nwhile (commands--) {\nstring command;\ncin &gt;&gt; command;\nif (command == \"pwd\") {\nif (stack.empty()) {\ncout &lt;&lt; \"/\" &lt;&lt; endl;\ncontinue;\n}\nfor (int i = 0; i &lt; stack.size(); i++) {\nif (i == 0 and stack[i][0] != '/') {\ncout &lt;&lt; \"/\";\n}\ncout &lt;&lt; stack[i] &lt;&lt; \"/\";\n}\ncout &lt;&lt; endl;\n}\nif (command == \"cd\") {\nstring directoryString;\ncin &gt;&gt; directoryString;\nif (directoryString[0] == '/') {\nstack.clear();\n}\nvector&lt;string&gt; tokenizedDirectory = tokenize(directoryString, '/');\nfor (auto directory : tokenizedDirectory) {\n// cout &lt;&lt; directory &lt;&lt; endl;\nif (directory != \"..\") {\nstack.push_back(directory);\n} else {\nstack.pop_back();\n}\n}\n}\n}\nreturn 0;\n}\n</code></pre>","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"]},{"location":"stacks/usage/","title":"Implementation of Stacks and Queues","text":"<p>A stack and Queue provides 2 basic operations, for stack it is <code>push()</code> and <code>pop()</code> and for queues it is <code>enqueue()</code>, <code>dequeue()</code>. Using Python's collection's deque we can implement both stack as well as queue in no time.</p> <p>In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations.</p> <ul> <li>Stacks from Scratch</li> <li>Queue from Scratch</li> </ul> <p>In interview setting I highly recommend you to use the <code>collections.dequeue</code> to implement the stack and queue classes.</p>"},{"location":"stacks/usage/#source-code","title":"Source Code","text":"<pre><code>from collections import deque\nfrom rich.console import Console\nconsole = Console()  # For printing purposes\nclass QueueWithDequeue:\ndef __init__(self, iterable=None):\nif not iterable:\nself.queue = deque()\nelse:\nself.queue = deque(iterable)\ndef dequeue(self):\n# Automatically will raise Error if the queue is empty\nreturn self.queue.popleft()\ndef enqueue(self, value):\nself.queue.append(value)\ndef show(self):\nconsole.print([data for data in self.queue])\n</code></pre>"},{"location":"stacks/usage/#stacks-implementation-with-deque-module","title":"Stacks implementation with Deque Module","text":"<pre><code>class Stack:\ndef __init__(self, iterable=None):\nif not iterable:\nself.container = deque()\nelse:\nself.container = deque(iterable)\ndef pop(self):\nreturn self.container.pop()\ndef push(self, val):\nreturn self.container.append(val)\ndef tos(self):\n# Get the top of the stack\nreturn self.container[-1]\ndef __repr__(self):\nreturn f\"{[data for data in self.container]}\"\n</code></pre>"},{"location":"stacks/usage/#stacks-implementation-with-c","title":"Stacks implementation with C++","text":"<p>With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nclass MinStack{\nprivate:\nvector&lt;int&gt; stack;\nvector&lt;int&gt; auxStack;\nint ClassPrivateSize;\npublic:\nMinStack(){\nClassPrivateSize = 0;\n}\nint size(){\nreturn ClassPrivateSize;\n}\nvoid push(int value){\nif (ClassPrivateSize == 0){\nstack.push_back(value);\nauxStack.push_back(value);\nClassPrivateSize += 1;\n}else{\nif (value &lt; auxStack.back()){\nstack.push_back(value);\nauxStack.push_back(value);\n}else{\nstack.push_back(value);\n}\nClassPrivateSize += 1;\n}\n}\nint pop(){\nif (ClassPrivateSize == 0){\nthrow runtime_error(\"pop(): Empty Stack\");\n}else{\nif (auxStack.back() == stack.back()){\nint value = stack.back();\nauxStack.pop_back();\nstack.pop_back();\nreturn value;\n}else{\nint value = stack.back();\nstack.pop_back();\nreturn value;\n}\nClassPrivateSize -=1;\n}\n}\nbool isEmpty() const{\nif (ClassPrivateSize == 0){\nreturn true;\n}\nreturn false;\n}\nint min(){\nreturn auxStack.back();\n}\nint peek() {\nreturn stack.back();\n}\n};\n</code></pre></p>"},{"location":"trees/implementation/","title":"Tree implementation","text":"<p>Tree is a non linear graph data structure which has no cycle. Tree is hiararchical data structure, any sort of data that has some sort of hiararchy we can use a tree to represent, get, delete efficiently.</p>"},{"location":"trees/implementation/#tree-standard-struct","title":"Tree Standard struct","text":"<p><code>STL</code> don't have general binary tree representation [has red black tree (height balanced binary search tree)]. The following <code>struct</code> can be used to represent a tree structure.</p> <pre><code>struct TreeNode {\nint data;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int value) {\ndata  = value;\nleft  = nullptr;\nright = nullptr;\n}\n};\n// Create a Tree Structure\nint main() {\nTreeNode *root = new TreeNode(12);\nroot-&gt;left     = new TreeNode(112);\nroot-&gt;right    = new TreeNode(44);\n}\n</code></pre> <p>Visual representation of the structure: <pre><code>graph TD\n\n    subgraph After Inserstions\n    12((12)) --&gt; 44((44)) &amp; 112((112))\n    112      --&gt; aa[null_ptr] &amp; bb[null_ptr]\n    44       --&gt; aaa[null_ptr] &amp; bbb[null_ptr]\n    end\n\n    subgraph At the start\n    A((12)) --&gt; b[null_ptr] &amp; c[null_ptr]\n    end</code></pre></p>"},{"location":"trees/implementation/#tree-from-input-stream","title":"Tree from input stream","text":"<p>Now for some cases you may have to take input from a stream of numbers and create a tree structure from them. Here is a detailed implementation on how to do that.</p> <p>First we create a character array and put the entire stream into that character array, <pre><code>// Get complete binray tree input from a stream\nchar a[1000];\ncin.getline(a, 1000);\n</code></pre></p> <p>Now we create a vector and we'll tokenize the character array and get all the numbers from them into the vector. <pre><code>vector&lt;int&gt; v;\n// String TOKENIZER to get all the numbers and convert them into integers\n// then push it into the vector\nchar *ans = strtok(a, \" \");\nwhile (ans != NULL){\nv.push_back(stoi(ans));\nans = strtok(NULL, \" \");\n}\n</code></pre></p> <p>Now most of the cases this will be some traversal order, and from this traversal order we create a binary tree. The most logical way one can provide the input is that they give you the level order traversal of the tree in that stream.</p> <p>Here is a Tree Class and a function to create a binary tree from a vector of numbers.</p> <pre><code>// Tree Definition\nclass Tree {\npublic:\nint data;\nTree* left, *right;\nTree(int d){\ndata = d;\nleft = nullptr;\nright = nullptr;\n}\n};\n</code></pre> <p>Creating tree from the input vector</p> <pre><code>Tree* createTreeFromVector(vector&lt;int&gt; v) {\nif (v.size()==0) return nullptr;\nint root = v[0];\nTree* treeRoot = new Tree(root);\n// start from the 1st element and push into a queue and add it to left of root;\n// because we push data in from left to right in complete binary tree\nqueue&lt;Tree*&gt; q;\nq.push(treeRoot);\nint i = 1;\nwhile(!q.empty()){\nTree* thisNode = q.front();\nq.pop();\nthisNode-&gt;left = new Tree(v[i++]);\nq.push(thisNode-&gt;left);\nif (i &gt;= v.size()) break;\nthisNode-&gt;right = new Tree(v[i++]);\nq.push(thisNode-&gt;right);\nif (i &gt;= v.size()) break;\n}\nreturn treeRoot;\n}\n</code></pre>"},{"location":"trees/implementation/#see-the-problem-section-now","title":"See the problem section now","text":"<p>Tree Problem Section</p>"},{"location":"trees/problems/","title":"Tree Problems","text":"<p>Questions discussed</p> <ol> <li>Traversal problems</li> <li>N-ary Tree Preorder Traversal</li> <li>Balanced Binary Tree</li> <li>Branch Sum Problem</li> <li>Invert a binary tree</li> <li>Iterative In Order Traversal</li> <li>Minimum Depth of a Binary Tree</li> <li>Connect Level Order Siblings</li> <li>Binary Tree Path Sum</li> <li>Count All Paths for a Sum</li> <li>Traceout All Paths for a Sum</li> <li>Validate a Binary Search Tree</li> <li>Find Kth Largest value in the binary search tree</li> <li>Find the total number of Binary Search Trees possible</li> <li>Same Binary Search Tree</li> <li>Binary Search Tree Iterator</li> <li>Count Complete Tree Nodes</li> <li>Deepest Leaves Sum</li> <li>Sum of Nodes with Even-Valued Grandparent</li> <li>Same Tree</li> <li>Flatten Binary Tree to Linked List</li> <li>Lowest Common Ancestor of a Binary Search Tree</li> <li>Maximum Product of Splitted Binary Tree</li> <li>Count Good Nodes in Binary Tree</li> <li>Trim a Binary Search Tree</li> <li>Binary Tree Right Side View</li> </ol>"},{"location":"trees/problems/#traversal-problems","title":"Traversal problems","text":""},{"location":"trees/problems/#inorder-preorder-and-postorder-traversal","title":"Inorder, preorder, and postorder traversal","text":"<p>Let's don't waste time and finish the \"confusing\" topic of pre order, post order and in order traversal on binary trees. Most of my friends tell me that they often forget how each traversal works and ask me how to remember them. Well, here you go</p> <p>When running through a tree (binary or binary search tree) we start from the root. Now arrange the queue of nodes like this if we visit</p> <ol> <li>the node for the first time we add that to the pre-order queue,</li> <li>the node for the second time we add that to the in-order queue,</li> <li>the node for the 3rd time we add that to the post-order queue.</li> </ol> <p>And now you have 3 queues each with pre-in-post order traversal path.</p> <p>Also make a note that if the binary tree is a binary search tree, then the in-order traversal will give a sorted array. We can use this property to check if the binary tree is a binary search tree or not.</p>"},{"location":"trees/problems/#more-formal-definition","title":"More formal definition","text":"<ol> <li>Pre order traversal is implemented like this: \\(\\text{Root} \\to \\text{Left} \\to \\text{Right}\\)</li> <li>In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Root} \\to \\text{Right}\\)</li> <li>In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\)</li> </ol>"},{"location":"trees/problems/#c-code","title":"C++ Code","text":"<pre><code>// Definition of the tree node\nstruct TreeNode {\nint data;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int value) {\ndata  = value;\nleft  = nullptr;\nright = nullptr;\n}\n};\nvoid inOrderTraversal(TreeNode *nodePointer){\nif (nodePointer != nullptr) {\ninOrderTraversal(nodePointer-&gt;left);\nprintf(\"%d \", nodePointer-&gt;data);\ninOrderTraversal(nodePointer-&gt;right);\n}\n}\nvoid preOrderTraversal(TreeNode *nodePointer){\nif (nodePointer != nullptr) {\nprintf(\"%d \", nodePointer-&gt;data);\npreOrderTraversal(nodePointer-&gt;left);\npreOrderTraversal(nodePointer-&gt;right);\n}\n}\nvoid postOrderTraversal(TreeNode *nodePointer){\nif (nodePointer != nullptr) {\npostOrderTraversal(nodePointer-&gt;left);\npostOrderTraversal(nodePointer-&gt;right);\nprintf(\"%d \", nodePointer-&gt;data);\n}\n}\n</code></pre>"},{"location":"trees/problems/#level-order-traversal-for-binary-trees","title":"Level order traversal for binary trees","text":"<p>For the following binary tree</p> <pre><code>graph TB\n    12((12)) --&gt; 44((44)) &amp; 112((112))\n    112      --&gt; aa((34)) &amp; bb((55))\n    44       --&gt; aaa((69)) &amp; bbb((420))</code></pre> <p>The equivalent level order traversal should be</p> <pre><code>graph LR  \n    a[12] --&gt; b[44] --&gt; c[112] --&gt; 34 --&gt; 55 --&gt; 69 --&gt; 420</code></pre>"},{"location":"trees/problems/#approach","title":"Approach","text":"<ul> <li>If you see there is a queuing order, every level of the tree gets processed from left to right.</li> <li>Then in the next level they are processed from left to right as well as their parent's order.</li> <li>So if we use a queue we can solve this problem.     </li> <li>With queue we can solve this problem, and here is a step by step approach     </li> </ul>"},{"location":"trees/problems/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\nvector&lt;vector&lt;int&gt;&gt; v;\nif (!root) return v;\nqueue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\nint depth = 1;\nq.push({root, depth});\nwhile(!q.empty()){\nTreeNode* front = q.front().first;\nint depth = q.front().second;\nq.pop();\nif (depth &gt; v.size()) {\nvector&lt;int&gt; v1;\nv1.push_back(front-&gt;val);\nv.push_back(v1);\n} else if (depth == v.size()) {\nv[depth - 1].push_back(front-&gt;val);\n}\nif (front-&gt;left) q.push({front-&gt;left, depth+1});\nif (front-&gt;right) q.push({front-&gt;right, depth+1});\n}\nreturn v;\n}\n};\n</code></pre>"},{"location":"trees/problems/#n-ary-tree-preorder-traversal","title":"N-ary Tree Preorder Traversal","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement","title":"Problem Statement","text":"<p>Given the root of an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>"},{"location":"trees/problems/#example","title":"Example","text":"<pre><code>Input: root = [1,null,3,2,4,null,5,6]\nOutput: [1,3,5,6,2,4]\n</code></pre> <pre><code>Input: \nroot = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</code></pre>"},{"location":"trees/problems/#approach_1","title":"Approach","text":"<ul> <li>We know the approach to find the preorder traversal of a binary tree, there we'd do the root, then left then right</li> <li>Instead here we'll do the root, then first from the left, then second from the left and so on until we reach n'th children of the root. So the coding should be pretty simple as following</li> </ul>"},{"location":"trees/problems/#code_1","title":"Code","text":"<pre><code>/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n    Node() {}\n    Node(int _val) {\n        val = _val;\n    }\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\nclass Solution {\nprivate:\nvector&lt;int&gt; order;\npublic:\nvector&lt;int&gt; preorder(Node* root) {\nif (root) {\norder.push_back(root-&gt;val);\nfor (auto tr:root-&gt;children) {\npreorder(tr);\n}\n}\nreturn order;\n}\n};\n</code></pre>"},{"location":"trees/problems/#balanced-binary-tree","title":"Balanced Binary Tree","text":"<p>Problem on leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_1","title":"Problem Statement","text":"<p>Given a binary tree, determine if it is height-balanced.</p>"},{"location":"trees/problems/#approach_2","title":"Approach","text":"<ul> <li>If a binary tree is height-balanced then the difference of height of the right subtree and left subtree should not be greater than 2.</li> <li>Now from the last problem we can recursivly find the height of the left and right subtrees and check if the difference between them is &gt; 1.</li> <li>If at any point we find that the height difference is &gt; 1, we indicate this some how to the main function and say it's not height balanced.</li> </ul>"},{"location":"trees/problems/#code_2","title":"Code","text":"<pre><code>class Solution {\npublic:\nint height(TreeNode *root) {\nif (!root) return 0;\n// recursively find the height of subtrees\nint leftheight = height(root-&gt;left);\nint rightheight = height(root-&gt;right);\n// if we find a height imbalance we inform it to the parent.\nif (std::abs(leftheight - rightheight) &gt; 1) return -1;\n// If [at parent] we find one of the subtrees has height imbalance\n// we return -1 and exit the program\nif (leftheight == -1 or rightheight == -1) return -1;\nreturn 1 + max(leftheight, rightheight);\n}\nbool isBalanced(TreeNode* root) {\n// if the subroutine finds anywhere in the tree a height imbalance\n// we return false.\nreturn height(root) != -1;\n}\n};\n</code></pre>"},{"location":"trees/problems/#branch-sum-problem","title":"Branch Sum Problem","text":""},{"location":"trees/problems/#problem-statement_2","title":"Problem Statement","text":"<p>You'll be given the root node of the binary tree. Now you have to return all the branch's \"SUM\" in a vector.</p>"},{"location":"trees/problems/#example_1","title":"Example:","text":""},{"location":"trees/problems/#approach_3","title":"Approach","text":"<p>The code should be almost similar to the height finding recursive approach for binary trees. Here we will change the code slightly so that we pass a <code>int sum</code> with each recursion and continue to add until we reach the bottom of the tree. </p> <p>At leaf node we check if <code>(tree-&gt;left == nullptr and tree-&gt;right == nullptr)</code> then we just push the sum to the answer and return.</p>"},{"location":"trees/problems/#code_3","title":"Code","text":"<pre><code>void branchSum(vector&lt;int&gt; &amp;v, Tree* tree, int sum) {\nif (tree-&gt;left == nullptr and tree-&gt;right == nullptr) {\nv.push_back(sum + tree-&gt;data);\nreturn;\n}\nbranchSum(v, tree-&gt;left, sum+tree-&gt;data);\nbranchSum(v, tree-&gt;right, sum+tree-&gt;data);\n}\nint main(){\nvector&lt;int&gt; v;\nbranchSum(v, root, 0);\nfor (auto t:v)\ncout &lt;&lt; t &lt;&lt; \" \";\n}\n</code></pre> <p>Output <pre><code>INORDER TRAVERSAL OF THE TREE\n4 2 5 1 6 3 7 \nBranch Sum of TREE\n7 8 10 11 \n</code></pre></p>"},{"location":"trees/problems/#invert-a-binary-tree","title":"Invert a binary tree","text":""},{"location":"trees/problems/#problem-statement_3","title":"Problem statement","text":"<p>You'll be given a binary tree, find out the inverted equivalent of the tree. It is prefered to do the inversion in place.</p> <p>Example</p> <p>Let's say we have a binary tree B. Inverting the binary tree will result into the mirror immage of the tree. </p>"},{"location":"trees/problems/#apporach","title":"Apporach","text":"<ul> <li>This is probably one of the best tree questions, it seems that there are a lot of things to track here. So solving this problem requires attention to lot of details.</li> <li>The apporach to solve this is to swap the nodes instead of the values.</li> <li>First we swap the left node with the right node for the head and then recursively swap the left and right nodes for the left and right nodes.</li> </ul> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nTreeNode* invertTree(TreeNode* root) {\nif (root){\nTreeNode* temp = root-&gt;left;\nroot-&gt;left = root-&gt;right;\nroot-&gt;right = temp;\ninvertTree(root-&gt;left);\ninvertTree(root-&gt;right);\n}\nreturn root;\n}\n};\n</code></pre>"},{"location":"trees/problems/#approach-with-bfs","title":"Approach With BFS","text":"<p>I personally don't prefer any recursive approach. With BFS also we can easily solve this problem. We put the node in queue to be processed and when we are at this node if this is not <code>NULL</code> we swap it's left and right children.</p> <p>This is the way we can swap left and right thus inverting it level by level because BFS works level order. <pre><code>class Solution {\npublic:\nTreeNode* invertTree(TreeNode* root) {\nqueue&lt;TreeNode*&gt; q;\nq.push(root);\nwhile(!q.empty()){\nTreeNode* thisNode = q.front();   // get front of the queue to process\nq.pop();\nif (thisNode != nullptr){\n// swap it's left and right\nTreeNode* left = thisNode-&gt;left;\nthisNode-&gt;left = thisNode-&gt;right;\nthisNode-&gt;right = left;\nq.push(thisNode-&gt;left);  // put both the children to be processed later\nq.push(thisNode-&gt;right);\n}\n}\nreturn root;\n}\n};\n</code></pre></p>"},{"location":"trees/problems/#iterative-in-order-traversal","title":"Iterative In Order Traversal","text":"<p>As you probably guessed, I don't like to use recursive approaches all that much. In tree traversals you have to iterate over the tree in the following order: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\).</p> <p>Now how can we avoid recursion? One possible solution could be to use stack and imitate the call stack.</p>"},{"location":"trees/problems/#code_4","title":"Code","text":"<p>We should mimic the behavior of the recursion in the recursive implementation of the in order traversal. <pre><code>void iterativeInOrderTraversal(Tree* root){\nvector&lt;Tree*&gt; stack;\nTree* traveller = root;\nwhile (true){\nif (traveller != nullptr){\nstack.push_back(traveller);\ntraveller = traveller-&gt;left;\n} else {\nif (stack.empty()) break;\ntraveller = stack.back();\nstack.pop_back();\ncout &lt;&lt; traveller-&gt;data &lt;&lt; \" \";\ntraveller = traveller-&gt;right;\n}\n}\n}\n</code></pre></p> <p>Now that we've seen the code, we should analyse the code using a dry run.</p> <p>This is the starting of the algorithm. In first step we go left until the first <code>NULL</code> is found, and we put all the nodes into the stack so to process later. </p> <p>Now at this point we've reached the point where we should start processing the node. This node <code>stack.top()</code> do not have any left children so for left we don't do anything, and print this node, then we should go to right and process that. </p> <p>We keep on deleting from stack and print until we go right of Node 1. </p> <p>Now we reached to a <code>non-NULL</code> node so the <code>if</code> part will be executed. It will put all the left of <code>3</code> into the stack until a <code>NULL</code> is reached.   </p> <p>At the very last step \\(\\text{NODE}(5)\\) will be processed which I did not show. It's a genuinely good problem and there is a lot to keep track of in the iterative version for a easy recursive problem. </p> <p>This goes to show how much the recursion stack actually helps, but at the cost of proper mental gymnastics to come up with a recursive approach.</p>"},{"location":"trees/problems/#minimum-depth-of-a-binary-tree","title":"Minimum Depth of a Binary Tree","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_4","title":"Problem statement","text":"<p>Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node.</p>"},{"location":"trees/problems/#examples","title":"Examples:","text":"<p>Depth = Path of 1 \\(\\to\\) 3. So the code should return 2. <pre><code>graph TD\n    1((1)) --&gt; 2((2)) &amp; 3((3))\n    2      --&gt; 4((4)) &amp; 5((5))\n    style 1 fill:#bbf, color:#fff\n    style 3 fill:#bbf, color:#fff</code></pre></p> <p>Depth = Path of 12 \\(\\to\\) 7 \\(\\to\\) 9. So the code should return 3.</p> <pre><code>graph TD\n    12((12)) --&gt; 7((7)) &amp; 1((1))\n    7 --&gt; 9((9))\n    1      --&gt; 10((10)) &amp; 5((5))\n    10 --&gt; 11((11))\n    style 12 fill:#bbf, color:white\n    style 7 fill:#bbf, color:#ffffff\n    style 9 fill:#bbf, color:#ffffff</code></pre>"},{"location":"trees/problems/#approach_4","title":"Approach","text":"<ul> <li>This is a pattern related to breath first search traversal.</li> <li>Think of this logically, if you traverse level by level and you find the first node that is a leaf node. This means you found the shallowest node in the binary tree.</li> <li>You track and return the depth of that shallowest node.</li> </ul>"},{"location":"trees/problems/#c-code_1","title":"C++ Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nint minDepth(TreeNode* root) {\nif (!root) return 0;\nqueue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\nint depth = 1;\nq.push({root, 1});\nwhile(!q.empty()){\nTreeNode* front = q.front().first;\nint nextDepth = q.front().second + 1;\nq.pop();\nif (front-&gt;left) q.push({front-&gt;left, nextDepth});\nif (front-&gt;right) q.push({front-&gt;right, nextDepth});\nif (!front-&gt;left and !front-&gt;right) return nextDepth - 1;\ndepth = nextDepth;\n}\nreturn depth;\n}\n};\n</code></pre>"},{"location":"trees/problems/#connect-level-order-siblings","title":"Connect Level Order Siblings","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_5","title":"Problem statement","text":"<p>Given a binary tree, connect each node with its level order successor. The last node of each level should point to a null node in place.</p> <p>A new <code>next</code> attribute is added to the tree structure. Update the <code>next</code> in-place.</p>"},{"location":"trees/problems/#example_2","title":"Example","text":""},{"location":"trees/problems/#approach-with-extra-space","title":"Approach With Extra Space","text":"<ul> <li>We store level wise node references in a <code>vector&lt;vector&lt;Node *&gt;&gt;</code> using BFS and a modified queue,</li> <li>then we link them together. To maintain the <code>vector&lt;vector&lt;Node *&gt;&gt;</code> we need \\(O(N)\\) Space.</li> </ul>"},{"location":"trees/problems/#code-for-this-approach","title":"Code for this approach","text":"<pre><code>/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\nclass Solution {\npublic:\nNode* connect(Node* root) {\nif (!root) return root;\nqueue&lt;pair&lt;Node*, int&gt;&gt; q;\nvector&lt;vector&lt;Node*&gt;&gt; v;\nint depth = 1;\nq.push({root, depth});\nwhile(!q.empty()) {\nNode* front = q.front().first;\nint depth = q.front().second;\nq.pop();\nif (depth &gt; v.size()) {\nvector&lt;Node*&gt; v1;\nv1.push_back(front);\nv.push_back(v1);\n} else if (depth == v.size()) {\nv[depth - 1].push_back(front);\n}\nif (front-&gt;left) q.push({front-&gt;left, depth + 1});\nif (front-&gt;right) q.push({front-&gt;right, depth + 1});\n}\n// for each level of nodes process the next attribute and set to its neighbors.\nfor (auto level:v) {\nint size = level.size();\nint index = 0;\nwhile(index &lt; size - 1){\nlevel[index] -&gt; next = level[index + 1];\nindex++;\n}\nlevel[index]-&gt;next = nullptr;\n}\nreturn root;\n}\n};\n</code></pre>"},{"location":"trees/problems/#approach-with-a-bit-less-space","title":"Approach with a bit less space","text":"<p>Question on Leetcode \\(\\to\\)</p> <p>In this approach, instead of storing the level wise ordering in a vector of vectors, we simply link the nodes as we go by just keeping one reference to the previously processed node. But still we have to keep the queue in order to run the BFS. So the extra space is actually needed which is \\(\\text{MAX(WIDTH of TREE)}\\).</p>"},{"location":"trees/problems/#code-for-this-approach_1","title":"Code for this approach","text":"<ul> <li>We'll enqueue next level nodes in right to left order, then connect them with each other. <pre><code>class Solution {\npublic:\nNode* connect(Node* root) {\nif (not root) return nullptr;\nqueue&lt;Node*&gt; q;\nq.push(root);\nwhile (not q.empty()) {\nNode* right = nullptr;\nint queue_size = q.size();\nfor (int i=queue_size; i&gt;0; i--) {\nNode* front = q.front();\nfront-&gt;next = right;\nright = front;\nq.pop();\n// add the siblings in reverse order\nif (front-&gt;right) q.push(front-&gt;right);\nif (front-&gt;left) q.push(front-&gt;left);\n}\n}\nreturn root;\n}\n};\n</code></pre></li> </ul>"},{"location":"trees/problems/#binary-tree-path-sum","title":"Binary Tree Path Sum","text":""},{"location":"trees/problems/#problem-statement_6","title":"Problem Statement","text":"<p>Given a binary tree and a number \u2018S\u2019, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals \u2018S\u2019.</p>"},{"location":"trees/problems/#example_3","title":"Example","text":"<ol> <li>Path Sum = \\(28\\). Output = TRUE.</li> <li>Path Sum = \\(21\\). Output = False. No path in the following tree has sum 21. <pre><code>graph TD\n    12((12)) --&gt; 7((7)) &amp; 1((1))\n    7 --&gt; 9((9))\n    1      --&gt; 10((10)) &amp; 5((5))\n    10 --&gt; 11((11))\n    style 12 fill:#bbf, color:white\n    style 7 fill:#bbf, color:#ffffff\n    style 9 fill:#bbf, color:#ffffff</code></pre></li> </ol>"},{"location":"trees/problems/#code-approach-1","title":"Code approach 1","text":"<ul> <li>We recursively go in depth first search and check if the sum is matching with the path,</li> <li>if yes we return <code>true</code>.</li> </ul> <pre><code>class Solution {\npublic:\nbool hasPathSum(TreeNode* root, int targetSum) {\nif (!root) return false;\nif (!root-&gt;left and !root-&gt;right) {\nif (targetSum == root-&gt;val) {\nreturn true;\n}\n}\nreturn hasPathSum(root-&gt;left, targetSum - root-&gt; val) || hasPathSum(root-&gt;right, targetSum - root-&gt; val);\n}\n};\n</code></pre>"},{"location":"trees/problems/#code-approach-2","title":"Code approach 2","text":"<p>It has a separate private boolean variable <code>a</code> which can even be modified to store how many times a path sum target is met. <pre><code>class Solution {\nprivate:\nbool a[2] = {false, false};\npublic:\nbool hasPathSum(TreeNode* root, int targetSum) {\nif (!root) return false;\nif (not root-&gt;left and not root-&gt;right) {\nif (root-&gt;val == targetSum) {\na[0] = true;\na[1] = true; // sets if at least 1 true occurred\n} else {\na[0] = false; // resets to false if some branch did not cut it\n}\n}\nhasPathSum(root-&gt;left, targetSum-root-&gt;val);\nhasPathSum(root-&gt;right, targetSum-root-&gt;val);\nreturn a[0] || a[1];\n}\n};\n</code></pre></p>"},{"location":"trees/problems/#count-all-paths-for-a-sum","title":"Count All Paths for a Sum","text":"<p>In the previous example we checked if some path contains the sum or not? but here find all paths from root-to-leaf such that the sum of all the node values of each path equals \u2018S\u2019. Return the count of paths matching the sum.</p>"},{"location":"trees/problems/#approach_5","title":"Approach","text":"<p>Approach is the same as the previous approach's code #\\(2\\), with a little modification. Instead of marking true if some path gives a match we'll update some counter.</p>"},{"location":"trees/problems/#code_5","title":"Code","text":"<pre><code>class Solution {\nprivate:\npair&lt;bool, int&gt; a = {false, 0}; // instead we put a counter in there.\npublic:\nint countPathSum(TreeNode* root, int targetSum) {\nif (!root) return false;\nif (not root-&gt;left and not root-&gt;right) {\nif (root-&gt;val == targetSum) {\na.first = true;\na.second += 1; // updates per target sum occurrences.\n} else {\na.first = false; // resets to false if some branch did not cut it\n}\n}\ncountPathSum(root-&gt;left, targetSum-root-&gt;val);\ncountPathSum(root-&gt;right, targetSum-root-&gt;val);\nreturn a.second;\n}\n};\n</code></pre>"},{"location":"trees/problems/#traceout-all-paths-for-a-sum","title":"Traceout All Paths for a Sum","text":"<p>It is the same as the previous problem but here you have to return the path where the sum is matching. Return a <code>vector&lt;vector&lt;Tree*&gt;&gt;</code>. Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p> <p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p> <p>Same Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#example_4","title":"Example","text":"<p>Target sum for the following tree: \\(34\\) <pre><code>graph TD\n    12((12)) --&gt; 7((1)) &amp; 1((1))\n    7 --&gt; 9((21))\n    1      --&gt; 10((10)) &amp; 5((5))\n    10 --&gt; 11((11))\n    style 12 fill:#bbf\n    style 7 fill:#bbf\n    style 10 fill:#bbf\n    style 9 fill:#bbf\n    style 11 fill:#bbf\n    style 1 fill:#bbf</code></pre></p> <p>Paths that returns \\(34\\) are the following:</p> <ul> <li>\\(12 \\to 1 \\to 21\\)</li> <li>\\(12 \\to 1 \\to 10 \\to 11\\)</li> </ul> <p>So these 2 path should be returned as the function finishes.</p>"},{"location":"trees/problems/#approach_6","title":"Approach","text":"<ul> <li>We create 2 vectors: one <code>vector&lt;vector&lt;Tree*&gt;&gt;</code> and one <code>vector&lt;Tree*&gt;</code>, the second one <code>vector&lt;Tree*&gt;</code> will be unique for each recursion level,</li> <li>When we traverse the tree Depth First we put the nodes into <code>vector&lt;Tree*&gt;</code>,</li> <li>When we reach the leaf node we check if the sum is matchting with the desired path sum. If yes we record the path sum.</li> </ul>"},{"location":"trees/problems/#code_6","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nvector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\nvector&lt;int&gt; thisLevel;\nvector&lt;vector&lt;int&gt;&gt; answer;\n// recursively go dfs\nhelper(root, targetSum, thisLevel, answer);\nreturn answer;\n}\nvoid helper(TreeNode* root, int targetSum, vector&lt;int&gt; thisLevel, vector&lt;vector&lt;int&gt;&gt; &amp;answer){\nif (!root) return;\nthisLevel.push_back(root-&gt;val);\nif (not root-&gt;left and not root-&gt;right) {\nif (targetSum == root-&gt;val) {\n// means this path sum is exactly the targetSum\n// record the path\nanswer.push_back(thisLevel);\n}\n}\nhelper(root-&gt;left, targetSum - root-&gt;val, thisLevel, answer);\nhelper(root-&gt;right, targetSum - root-&gt;val, thisLevel, answer);\n}\n};\n</code></pre>"},{"location":"trees/problems/#validate-a-binary-search-tree","title":"Validate a Binary Search Tree","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_7","title":"Problem Statement","text":"<p>Given a binary tree check if the binary tree conforms to the criteria for a binary search tree.</p>"},{"location":"trees/problems/#approach_7","title":"Approach","text":"<ol> <li>Given a binary tree (with unit node) it is always considered a binary search tree.</li> <li>Given a binary tree with one unit left node and unit right node, if \\(\\text{Val(left)} \\leq \\text{Val(parent)} \\leq \\text{Val(right)}\\) then it is a binary search tree.</li> <li>Given a binary tree with left subtree and right subtree, it is considered a binary search tree if both the left and right subtrees are binary search trees and condition 2 satisfies.</li> <li>Using these 3 steps we can determine if the binary tree is binary search tree.</li> <li>But using only these three steps can not independently determine if the binary tree is binary search tree? For example in the following tree, all the elements to the right subtree of the Node \\(10\\) must be greater than \\(10\\). But the first \\(3\\) steps of the algorithm only checks for local violations.     <pre><code>graph TD\n\n    subgraph With No local and global violation\n    10a((10)) --&gt; 5a((5)) &amp; 15((15))\n    5a --&gt; 2((2)) &amp; 5b((6))\n    2 --&gt; 1a((1)) &amp; null1((null))\n    15 --&gt; 13((13)) &amp; 22((22))\n    13 --&gt; null12((null)) &amp; 14((14))\n    end\n\n    subgraph With Global violation at 3\n    10((10)) --&gt; 1((1)) &amp; 4((4))\n    4      --&gt; 3((3)) &amp; 6((6))\n    end</code></pre></li> <li>If we look closely all the elements of right subtree for 10 the for tree with no local violation, has the value \\(\\gt 10\\) so minimum for such elements in the right subarray is at least \\(\\gt 10\\). And there is no max limit as such for any element in the right subtree. But once we fix the right of \\(10\\) as \\(15\\) then the left of \\(15\\) can have the maximum value at most \\(14\\) (because all are integers) and at minimum \\(11\\) because it is on the right of 10. </li> <li>So now let's analyse for all nodes what can be the maximum and what can be the minimum value. Then if we recursively check we should check for Binary Search Tree property.</li> </ol> <p>Below this is a tree and for each nodes the minumum and maximum is calculated</p> <p></p> <p>From the diagram we can see that when we travel to left, the minimum for the left children is \\(\\text{Parent.Minimum}\\) and the maximum is \\(\\text{Parent.Value}\\). When we travel to right, the minimum for the right children is \\(\\text{Parent.Value}\\) and the maximum is \\(\\text{Parent.Maximum}\\).</p> <ul> <li>So upon travel to left, bound for left's value is \\(\\text{Min} = \\text{Parent.Min}\\) and \\(\\text{Max} = \\text{Parent.Value}\\)</li> <li>Upon travel to right, bound for right's value is \\(\\text{Min} = \\text{Parent.Value}\\) and \\(\\text{Max} = \\text{Parent.Maximum}\\)</li> </ul> <p>Now let's transfer it into a working C++ Code.</p>"},{"location":"trees/problems/#code_7","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nbool subRoutine (TreeNode* root, long minim, long maxim) {\nif (!root) return true;\nlong valueHere = root-&gt;val;\nbool thisLevel = false;\nif (minim &lt; valueHere and valueHere &lt; maxim) thisLevel = true;\nbool isLeft = subRoutine(root-&gt;left, minim, root-&gt;val);\nbool isRight = subRoutine(root-&gt;right, root-&gt;val, maxim);\nreturn thisLevel &amp;&amp; isLeft &amp;&amp; isRight;\n}\npublic:\nbool isValidBST(TreeNode* root) {\nreturn subRoutine(root, LONG_MIN, LONG_MAX);\n}\n};\n</code></pre>"},{"location":"trees/problems/#find-kth-largest-value-in-the-binary-search-tree","title":"Find Kth Largest value in the binary search tree","text":"<p>Problem On Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_8","title":"Problem Statement","text":"<p>Given a binary search tree find the kth largest value accross all the nodes in the tree.</p>"},{"location":"trees/problems/#approach_8","title":"Approach","text":"<p>We should traverse the tree in-order, so the values encountered are in non descending order. Now we count until we reach kth smallest value. We record the kth smallest value in some variable and return.</p>"},{"location":"trees/problems/#code_8","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint treeNodeCount = 1; // starting index is 1\nint setValue; // should hold the kth smallest value\npublic:\nint kthSmallest(TreeNode* root, int k) {\nif (root) {\nkthSmallest(root-&gt;left, k);\nif (treeNodeCount == k) {\nsetValue = root-&gt;val; // set the kth smallest value\n}\ntreeNodeCount++;\nkthSmallest(root-&gt;right, k);\n}\nreturn setValue;\n}\n};\n</code></pre>"},{"location":"trees/problems/#time-and-memory-complexity","title":"Time and memory complexity","text":"<ul> <li>We are essentially traversing in-order so the it's \\(O(N)\\)</li> <li>Extra memory is \\(O(1)\\). For usage of recursive function calls we need at least \\(O(\\lg N)\\) (height of the tree) auxiliary space.</li> </ul>"},{"location":"trees/problems/#find-the-total-number-of-binary-search-trees-possible","title":"Find the total number of Binary Search Trees possible","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_9","title":"Problem Statement","text":"<p>Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.</p>"},{"location":"trees/problems/#approach_9","title":"Approach","text":"<p>It's the nth catalan number which represents the number of structures possible with upto n nodes. Now for each structure there can be only one inorder traversal which represents to a sorted order. So n'th catalan number is the answer.</p>"},{"location":"trees/problems/#code_9","title":"Code","text":"<pre><code>class Solution {\nprivate:\nunsigned long int catalan(int n) {\nvector&lt;unsigned long int&gt; catalanTable;\ncatalanTable.push_back(1); // catalan(0)\ncatalanTable.push_back(1); // catalan(1)\nfor (int i=2; i&lt;=n; i++) {\ncatalanTable.push_back(0);\nfor (int j = 0; j &lt; i; j++)\ncatalanTable[i] += catalanTable[j] * catalanTable[i - j - 1];\n}\nreturn catalanTable.back();\n}\npublic:\nint numTrees(int n) {\n// catalan's number is the answer\nreturn (int) catalan(n);\n}\n};\n</code></pre>"},{"location":"trees/problems/#same-binary-search-tree","title":"Same Binary Search Tree","text":""},{"location":"trees/problems/#problem-statement_10","title":"Problem Statement","text":"<p>You are given 2 sequences of numbers. Find out if you put numbers in a binary search tree in those 2 orders it'll be the same binary search tree. The caveat is that you can't construct the tree yourself and compare using some tree traversal techniques.</p>"},{"location":"trees/problems/#input-format","title":"Input Format","text":"<p>You'll be given 2 binary search tree insertion order in 2 <code>vector&lt;int&gt;</code>. This is the order you are expected to insert into the binary search tree. Compare both and return <code>true</code> if the binary search trees are essentially the same.</p>"},{"location":"trees/problems/#example_5","title":"Example","text":"<p><code>vector&lt;int&gt; v1 = {10, 15, 8, 12, 94, 81, 5, 2, 11};</code> and <code>vector&lt;int&gt; v2 = {10, 8, 5, 15, 2, 12, 11, 94, 81}</code> inserting using v1 order and v2 order will result in the same binary search tree, so the function will return <code>true</code>.</p>"},{"location":"trees/problems/#approach_10","title":"Approach","text":"<p>If we look closely we'll see that the binary search tree is constructed uniquely if all the elements coming to left of the root element (10) is in the same order in both the cases. The elements that is greater than the root element (10) will not interfere with the left subtree of the binary search tree.</p> <p>So we compare the order of elements &lt; root (10) and compare order of elements &gt; root (10). If the order are same then both must be the same binary search tree.</p>"},{"location":"trees/problems/#time-and-space-complexity","title":"Time and Space complexity","text":"<p>No extra space is required, the algorithm runs in \\(O(n)\\) time.</p>"},{"location":"trees/problems/#binary-search-tree-iterator","title":"Binary Search Tree Iterator","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_11","title":"Problem Statement","text":"<p>Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):</p> <ul> <li><code>BSTIterator(TreeNode root)</code> Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li> <li><code>boolean hasNext()</code> Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</li> <li>int <code>next()</code> Moves the pointer to the right, then returns the number at the pointer.</li> </ul> <p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p> <p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>"},{"location":"trees/problems/#approaches","title":"Approaches","text":""},{"location":"trees/problems/#straight-forward-apporach","title":"Straight forward apporach","text":"<p>A straight forward solution is to build the in-order traversal when the binary search tree is constructed. Then solve the <code>next()</code> and <code>hasNext()</code> problem accordingly.</p>"},{"location":"trees/problems/#code-with-straight-forward-apporach","title":"Code with Straight Forward Apporach","text":"<pre><code>class BSTIterator {\nprivate:\nvector&lt;int&gt; inOrder;\nint current;\nvoid makeInOrder(TreeNode* root) {\nif (root) {\nmakeInOrder(root-&gt;left);\ninOrder.push_back(root-&gt;val);\nmakeInOrder(root-&gt;right);\n}\n}\npublic:\nBSTIterator(TreeNode* root) {\n// Make the in-order traversal beforehand\nmakeInOrder(root);\ncurrent = -1; // start with -1\n// so when first next() is called we return the root\n}\nint next() {\ncurrent++;\nreturn inOrder[current];\n}\nbool hasNext() {\nif (current == inOrder.size() - 1) {\nreturn false;\n}\nreturn true;\n}\n};\n</code></pre>"},{"location":"trees/problems/#count-complete-tree-nodes","title":"Count Complete Tree Nodes","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_12","title":"Problem statement","text":"<p>Given the root of a complete binary tree, return the number of the nodes in the tree.</p> <p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p> <p>Design an algorithm that runs in less than O(n) time complexity.</p>"},{"location":"trees/problems/#approach_11","title":"Approach","text":"<p>We can easily solve this problem with recursion but as in this problem sub-trees of the binary tree is complete binary tree we can use the formula to calculate the number of nodes as \\(2^{\\text{height}}\\). This way the overall time complexity reduces.</p> <p>Otherwise if \\(O(N)\\) is possible we could just run an in order traversal algorithm to find the number of nodes in the tree.</p>"},{"location":"trees/problems/#code_10","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nint two_pow(int n) {\n// find 2^n\nint result=1;\nwhile (n!=0) {\nresult *= 2;\nn--;\n}\nreturn result;\n}\nint lh(TreeNode* root) {\n// find left height of a given tree\nif (!root) return 0;\nreturn 1 + lh(root-&gt;left);\n}\nint rh(TreeNode* root) {\n// find right height of a given tree\nif (!root) return 0;\nreturn 1 + rh(root-&gt;right);\n}\nint count(TreeNode* root) {\nint leftHeight = lh(root);\nint rightHeight = rh(root);\n// if both left and right height is the same then\n// with respect to the root at current recursion level it is balanced and complete\n// so the number of node will be 2^n - 1\nif (leftHeight == rightHeight) {\nreturn two_pow(leftHeight) - 1;\n}\n// else we continue with the normal recursive counting\nreturn 1 + count(root-&gt;left) + count(root-&gt;right);\n}\npublic:\nint countNodes(TreeNode* root) {\nif (not root) return 0;\nreturn count(root);\n}\n};\n</code></pre>"},{"location":"trees/problems/#deepest-leaves-sum","title":"Deepest Leaves Sum","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statemet","title":"Problem Statemet","text":"<p>Given the root of a binary tree, return the sum of values of its deepest leaves.</p>"},{"location":"trees/problems/#approach_12","title":"Approach","text":"<p>We shoud use my BFS technique with passing depth. Using this technique</p> <ul> <li>when we find a leaf node we store it in a <code>pair&lt;int, int&gt;</code> and save the depth.</li> <li>If we find a leaf node less than this depth, so this can not be in the answer so we ignore it.</li> <li>If we find a leaf node is at the same level this means it can be included in the answer and later if we find any node at a deeper depth we'll discard all the calculations before.</li> </ul> <p>So here is the code using the upper approach</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\npair&lt;int, int&gt; sumAndDepth = {0,0};\nint deepestLeavesSum(TreeNode* root) {\nqueue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\n// set root node at depth 1\nq.push({root, 1});\nwhile (!q.empty()) {\nTreeNode* front = q.front().first;\nint depth = q.front().second;\nq.pop();\nif (not front-&gt;left and not front-&gt;right) {\n// it is a leaf node\nif (depth == sumAndDepth.second) {\n// if the leaf node is at 'presumably' the deepest node\n// add the values\nsumAndDepth.first += front-&gt;val;\nsumAndDepth.second = depth;\n} else if (depth &gt; sumAndDepth.second) {\n// else if some other node is at a greater depth\n// reset the depth and sum\nsumAndDepth.first = 0 + front-&gt;val;\nsumAndDepth.second = depth;\n}\n}\n// simple BFS strategy\nif (front-&gt;left) q.push({front-&gt;left, depth+1});\nif (front-&gt;right) q.push({front-&gt;right, depth+1});\n} return sumAndDepth.first;    // return the sum at the last\n}\n};\n</code></pre>"},{"location":"trees/problems/#sum-of-nodes-with-even-valued-grandparent","title":"Sum of Nodes with Even-Valued Grandparent","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_13","title":"Problem Statement","text":"<p>Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.</p> <p>A grandparent of a node is the parent of its parent if it exists.</p>"},{"location":"trees/problems/#approach_13","title":"Approach","text":"<p>It's a simple recursive problem, we'll get to every node and check if it is even then if it has a grandparent. Every node has 4 possible grand-children:</p> <ul> <li>left of left children,</li> <li>right of left children,</li> <li>right of right children,</li> <li>left of right children,</li> </ul> <p>With that apporach let's code</p>"},{"location":"trees/problems/#code_11","title":"Code","text":"<pre><code>class Solution {\nprivate:\nint sum = 0;\npublic:\nint sumEvenGrandparent(TreeNode* root) {\nif (root) {\nif (root-&gt;val % 2 == 0) {\n// if even number check all the grandchildren\nif (root-&gt;left) {\nif (root-&gt;left-&gt;left) {\nsum +=root-&gt;left-&gt;left-&gt;val;\n}\nif (root-&gt;left-&gt;right) {\nsum +=root-&gt;left-&gt;right-&gt;val;\n}\n}\nif (root-&gt;right) {\nif (root-&gt;right-&gt;left) {\nsum +=root-&gt;right-&gt;left-&gt;val;\n}\nif (root-&gt;right-&gt;right) {\nsum +=root-&gt;right-&gt;right-&gt;val;\n}\n}\n}\nsumEvenGrandparent(root-&gt;left);\nsumEvenGrandparent(root-&gt;right);\n}\nreturn sum;\n}\n};\n</code></pre>"},{"location":"trees/problems/#same-tree","title":"Same Tree","text":"<p>Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_14","title":"Problem Statement","text":"<p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p> <p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>"},{"location":"trees/problems/#example_6","title":"Example","text":"<pre><code>Input: p = [1,2,3], q = [1,2,3]\nOutput: true\n</code></pre>"},{"location":"trees/problems/#approach_14","title":"Approach","text":"<ul> <li>We'll go through both the tree with a simultaneous in-order traversal, if we find any incorrect order we'll report false.</li> </ul>"},{"location":"trees/problems/#code_12","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif (not p and not q) return true;\nif (p and q) {\nreturn (p-&gt;val == q-&gt;val) and isSameTree(p-&gt;left, q-&gt;left) and isSameTree(p-&gt;right, q-&gt;right);\n}\nreturn false;\n}\n};\n</code></pre>"},{"location":"trees/problems/#flatten-binary-tree-to-linked-list","title":"Flatten Binary Tree to Linked List","text":"<p>Find Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_15","title":"Problem Statement","text":"<p>Given the root of a binary tree, flatten the tree into a \"linked list\":</p> <ul> <li>The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.</li> <li>The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.</li> </ul>"},{"location":"trees/problems/#approach_15","title":"Approach","text":"<ul> <li>We have to solve this using a recursive approach, otherwise, the problem will become too complicated to solve because then you also have to keep track of the call stack.</li> <li>In recursion, we'll assume we have a <code>leftEnd</code> and <code>rightEnd</code> after the recursion, for any given root of the binary tree <code>leftEnd</code> is the flattened <code>root-&gt;left</code> of that root.</li> <li>Now as per the problem statement we set the following three<ul> <li><code>leftEnd-&gt;right = root-&gt;right;</code></li> <li><code>root-&gt;right = root-&gt;left;</code></li> <li><code>root-&gt;left = nullptr;</code></li> </ul> </li> <li>and now at the end, we return the <code>__End</code>, which is used recursively to connect the flattened binary tree. We'll return the <code>rightEnd</code> if possible else the <code>leftEnd</code> or <code>root</code>.</li> </ul>"},{"location":"trees/problems/#code_13","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nTreeNode* recursive_descent(TreeNode* root) {\nif (root) {\nTreeNode* leftEnd = recursive_descent(root-&gt;left);\nTreeNode* rightEnd = recursive_descent(root-&gt;right);\nif (root-&gt;left) {\nleftEnd-&gt;right = root-&gt;right;\nroot-&gt;right = root-&gt;left;\nroot-&gt;left = nullptr;\n}\nif (rightEnd) return rightEnd;\nelse if (not rightEnd and leftEnd) return leftEnd;\nelse return root;\n}\nreturn nullptr;\n}\npublic:\nvoid flatten(TreeNode* root) {\nrecursive_descent(root);\n}\n};\n</code></pre>"},{"location":"trees/problems/#lowest-common-ancestor-of-a-binary-search-tree","title":"Lowest Common Ancestor of a Binary Search Tree","text":""},{"location":"trees/problems/#problem-statement_16","title":"Problem Statement","text":"<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p> <p>According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d</p>"},{"location":"trees/problems/#approach_16","title":"Approach","text":"<ul> <li>We'll use a simple recursive technique to find the lowest common ancestor, if the node <code>p</code> and node <code>q</code> are in different subtrees from a certain root, then it is must that the root is the lowest common ancestor.</li> <li>If we find the both the node <code>p</code> and node <code>q</code> are in the same subtree, we'll recursively descent into that subtree in search for the lowest common ancestor.</li> </ul>"},{"location":"trees/problems/#code_14","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\nbool findOnSubTree(TreeNode* root, TreeNode* q) {\nif (root) {\nreturn findOnSubTree(root-&gt;left, q) or (root-&gt;val == q-&gt;val) or findOnSubTree(root-&gt;right, q);\n}\nreturn false;\n}\npublic:\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n// check if both in the same tree or not?\n// recursively go to that subtree only\nif (findOnSubTree(root-&gt;left, p) and findOnSubTree(root-&gt;left, q)) {\nreturn lowestCommonAncestor(root-&gt;left, p , q);\n} else if (findOnSubTree(root-&gt;right, p) and findOnSubTree(root-&gt;right, q)) {\nreturn lowestCommonAncestor(root-&gt;right, p , q);\n}\n// both in different sub-tree\nreturn root;\n}\n};\n</code></pre>"},{"location":"trees/problems/#another-approach","title":"Another approach","text":"<p>We can also take on the fact that we have a binary search tree, so we can say that if we start at the root node of the tree then if p and q value both are less than the root we search in the left subtree and if p and q value both are greater than the root node we search in the right subtree. Any case other than that, means values have split between left and right subtrees from that position, that means this is the lowest common ancestor. So return that.</p>"},{"location":"trees/problems/#code-for-this-approach_2","title":"Code for this approach","text":"<pre><code>class Solution {\npublic:\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\nTreeNode* current = root;\nwhile (current) {\nif (p-&gt;val &lt; current-&gt;val and q-&gt;val &lt; current-&gt;val) {\ncurrent = current-&gt;left;\n} else if (p-&gt;val &gt; current-&gt;val and q-&gt;val &gt; current-&gt;val) {\ncurrent = current-&gt;right;\n} else {\nreturn current;\n}\n}\n// base case of all\nreturn root;\n}\n};\n</code></pre>"},{"location":"trees/problems/#maximum-product-of-splitted-binary-tree","title":"Maximum Product of Splitted Binary Tree","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_17","title":"Problem Statement","text":"<p>Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.</p> <p>Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo \\(10^9 + 7\\).</p> <p>Note that you need to maximize the answer before taking the mod and not after taking it.</p>"},{"location":"trees/problems/#examples_1","title":"Examples","text":"<p> <pre><code>Input: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n</code></pre></p> <p> <pre><code>Input: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n</code></pre></p>"},{"location":"trees/problems/#approach_17","title":"Approach","text":"<ul> <li>We'll find the sum in each of the subtrees. If we know the sum of a subtree, the answer is <code>max( (total_sum - subtree_sum) * subtree_sum)</code> in each node.</li> <li>To find the <code>total_sum</code> we run a subroutine <code>helper()</code> that'll find the sum with post order traversal.</li> <li>At the end keep track of the max of <code>max( (total_sum - subtree_sum) * subtree_sum)</code> for each of the subtrees for every node.</li> </ul>"},{"location":"trees/problems/#code_15","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nint M = 1e9 + 7;\nlong long max_prod = 0;\nint helper(TreeNode* root) {\nint total = 0;\nif (not root) return 0;\ntotal += root-&gt;val + helper(root-&gt;left) + helper(root-&gt;right);\nreturn total;\n}\nint subroutine(TreeNode* root, int total) {\nif (not root) return 0;\nint sum = root-&gt;val;\nint left = subroutine(root-&gt;left, total);\nint right = subroutine(root-&gt;right, total);\nsum = sum + left + right;\nmax_prod = std::max(max_prod, (left*1LL) * ((total - left)*1LL));\nmax_prod = std::max(max_prod, (right*1LL) * ((total - right)*1LL));\nreturn sum;\n}\npublic:\nint maxProduct(TreeNode* root) {\nint total = helper(root);\nsubroutine(root, total);\nreturn max_prod % M;\n}\n};\n</code></pre>"},{"location":"trees/problems/#count-good-nodes-in-binary-tree","title":"Count Good Nodes in Binary Tree","text":"<p>Find the problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_18","title":"Problem Statement","text":"<p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p> <p>Return the number of good nodes in the binary tree.</p>"},{"location":"trees/problems/#example_7","title":"Example","text":"<pre><code>Input: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -&gt; (3,4) is the maximum value in the path starting from the root.\nNode 5 -&gt; (3,4,5) is the maximum value in the path\nNode 3 -&gt; (3,1,3) is the maximum value in the path.\n</code></pre>"},{"location":"trees/problems/#approach_18","title":"Approach","text":"<ul> <li>We'll send a <code>maxSeen</code> so far variable down with the recursive calls. If we find a node with value greater or equal to the current node we'll increment the counter of good notes.</li> <li>At last we'll return the <code>good_node_counter</code> global variable.</li> </ul>"},{"location":"trees/problems/#code_16","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\nint good_node_counter = 0;\nvoid recursive_subroutine(TreeNode* root, int maxSeen) {\nif (not root) return;\nif (root-&gt;val &gt;= maxSeen) {\ngood_node_counter++;\n}\nmaxSeen = std::max(maxSeen, root-&gt;val);\nrecursive_subroutine(root-&gt;left, maxSeen);\nrecursive_subroutine(root-&gt;right, maxSeen);\n}\npublic:\nint goodNodes(TreeNode* root) {\nrecursive_subroutine(root, root-&gt;val);\nreturn good_node_counter;\n}\n};\n</code></pre>"},{"location":"trees/problems/#trim-a-binary-search-tree","title":"Trim a Binary Search Tree","text":"<p>Find the Problem on Leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_19","title":"Problem Statement","text":"<p>Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer.</p> <p>Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.</p>"},{"location":"trees/problems/#example_8","title":"Example","text":"<pre><code>Input: root = [1,0,2], low = 1, high = 2\nOutput: [1,null,2]\n</code></pre> <pre><code>Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3\nOutput: [3,2,null,1]\n</code></pre>"},{"location":"trees/problems/#approach_19","title":"Approach","text":"<p>We'll do a recursive descent into the binary search tree. As it is a binary search tree we can find the way to go down the recursion based on the values at the current node.</p> <p>Few of the moves that we'll be taking during the recursion are the following</p> <ul> <li>If some <code>root-&gt;left-&gt;val</code> is less than the low means that the current node's left child should become the current node's left's right child (making all the <code>left-&gt;left-&gt;right&amp;left</code> invalid because they will be less than the lower bound on the binary search tree). Even then there can be a problem that the new <code>left</code> of the current node is out of bounds again. So we recursively call the function on that same node again.</li> <li>After this when we are done correcting the <code>node</code> there may be a chance that some of the children are not corrected yet, so we recursively call the function on the left children <code>trimBST(root-&gt;left, low, high);</code>.</li> <li>We symmatically solve the right children.</li> <li>This is how we solved the left and the right children but we didn't solved the current root yet. To solve this we'll do a simple recursive return from the left or the right depending upon the value at the root node.     <pre><code>if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);\nif (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);    </code></pre></li> </ul>"},{"location":"trees/problems/#code_17","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nTreeNode* trimBST(TreeNode* root, int low, int high) {\nif (not root) return root;\nif (root-&gt;left and root-&gt;left-&gt;val &lt; low) {\nroot-&gt;left = root-&gt;left-&gt;right;\ntrimBST(root, low, high);\n}\ntrimBST(root-&gt;left, low, high);\nif (root-&gt;right and root-&gt;right-&gt;val &gt; high) {\nroot-&gt;right = root-&gt;right-&gt;left;\ntrimBST(root, low, high);\n}\ntrimBST(root-&gt;right, low, high);\nif (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);\nif (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);\nreturn root;\n}\n};\n</code></pre>"},{"location":"trees/problems/#binary-tree-right-side-view","title":"Binary Tree Right Side View","text":"<p>Find the problem on leetcode \\(\\to\\)</p>"},{"location":"trees/problems/#problem-statement_20","title":"Problem Statement","text":"<p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>"},{"location":"trees/problems/#example_9","title":"Example","text":"<pre><code>Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n</code></pre> <pre><code>Input: root = [1,null,3]\nOutput: [1,3]\n</code></pre> <pre><code>Input: root = []\nOutput: []\n</code></pre>"},{"location":"trees/problems/#approach_20","title":"Approach","text":"<ul> <li>If you look closely to the example above, you can see that the right side view is the right most node of the tree for each level,</li> <li>armed with that knowledge you can travel level by level using a level order traversal, then find what is the last node of that level, you return that value.</li> <li>At the worst case the Binary Tree is skewed so at most \\(O(N)\\) space and time is required to find the right view of that tree.</li> <li>The following is the code example that implements this approach.</li> </ul>"},{"location":"trees/problems/#code_18","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nvector&lt;int&gt; answer;\nvector&lt;int&gt; rightSideView(TreeNode* root) {\nif (not root) return answer;\nvector&lt;vector&lt;int&gt;&gt; levelOrder;\nqueue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\nq.push({root, 1});\nwhile (!q.empty()) {\nTreeNode* front = q.front().first;\nint depth = q.front().second;\nq.pop();\nif (front-&gt;left) q.push({front-&gt;left, depth+1});\nif (front-&gt;right) q.push({front-&gt;right, depth+1});\nif (depth &gt; levelOrder.size()) {\nvector&lt;int&gt; v;\nv.push_back(front-&gt;val);\nlevelOrder.push_back(v);\n} else if (depth == levelOrder.size()){\nlevelOrder[depth-1].push_back(front-&gt;val);\n}\n}\nfor (int i=0; i&lt;levelOrder.size(); i++) {\nvector&lt;int&gt; lvl = levelOrder[i];\nanswer.push_back(lvl[lvl.size() - 1]);\n}\nreturn answer;\n}\n};\n</code></pre>"}]}