{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"theroyakash algorithms Materials for FAANG and top startup coding interview and running notes on that. Made by theroyakash . Getting started \u2022 Freebies \u2022 theroyakash Learning Platform \u2022 License Support this project on GitHub by becoming a sponsor This project is completely free and funded by @theroyakash and private sponsors. What is this? This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures , algorithms , and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I and SDE II algorithm round. Content overview Sliding Window Pattern , more is being added. Arrays and Strings (Coming soon) Recursion overview and recursion problems (more) coming soon Linked lists overview and problems Stacks overview and stack problems and Queues (coming soon) Binary Search overview and Problems (more coming soon) Trees overview and tree problem Graphs overview , graph bfs and dfs and Graph Problems , Heaps overview and heap problems and 2 heaps problems . Greedy algorithms Bit Manipulation (With C/C++) (coming soon) Dynamic Programming (coming soon) Problem Counter The following table is meant to represent the amount of problems has a full analysis in the website. Maybe incorrectly represented upto 1-2 problems. Problem Concepts Number of problems with detailed solutions Linked List Problems \\(15\\) Binary Search (Interview Problems) \\(22\\) Tree Problems \\(26\\) Graph Traversals, BFS, DFS and applications \\(3\\) Graph Standard Problems \\(4\\) Graph Interview Problems \\(3\\) Stack Problems \\(10\\) Heap Problems \\(7\\) 2 Heap Problems \\(2\\) problem scheduled to be added Array Problems \\(22\\) Array + Sliding window concept Problems \\(4\\) Recursion Problems \\(3\\) , more will be added soon Dynamic Programming Not started yet Greedy Algorithms 2 Total Number of Problems with Full analysis \\(123\\) problems with FULL analysis Also Coming Soon Few more freebies coming soon - Distributed Systems Book (expected 2023 Summer). Other Products See the freebies page to see more products available for free to use. Who am I? This is me! I go by theroyakash on the internet. I am a computer scientist, a masters student in computer science from Indian Institute of Technology (IIT) Madras , with research in high-performance algorithms , data structures , distributed systems , and beyond. See my work searching google for theroyakash and on Github . Other links Visit my website here . My Github , More about me , Send me an email .","title":"Introduction"},{"location":"#what-is-this","text":"This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures , algorithms , and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I and SDE II algorithm round.","title":"What is this?"},{"location":"#content-overview","text":"Sliding Window Pattern , more is being added. Arrays and Strings (Coming soon) Recursion overview and recursion problems (more) coming soon Linked lists overview and problems Stacks overview and stack problems and Queues (coming soon) Binary Search overview and Problems (more coming soon) Trees overview and tree problem Graphs overview , graph bfs and dfs and Graph Problems , Heaps overview and heap problems and 2 heaps problems . Greedy algorithms Bit Manipulation (With C/C++) (coming soon) Dynamic Programming (coming soon)","title":"Content overview"},{"location":"#problem-counter","text":"The following table is meant to represent the amount of problems has a full analysis in the website. Maybe incorrectly represented upto 1-2 problems. Problem Concepts Number of problems with detailed solutions Linked List Problems \\(15\\) Binary Search (Interview Problems) \\(22\\) Tree Problems \\(26\\) Graph Traversals, BFS, DFS and applications \\(3\\) Graph Standard Problems \\(4\\) Graph Interview Problems \\(3\\) Stack Problems \\(10\\) Heap Problems \\(7\\) 2 Heap Problems \\(2\\) problem scheduled to be added Array Problems \\(22\\) Array + Sliding window concept Problems \\(4\\) Recursion Problems \\(3\\) , more will be added soon Dynamic Programming Not started yet Greedy Algorithms 2 Total Number of Problems with Full analysis \\(123\\) problems with FULL analysis","title":"Problem Counter"},{"location":"#also-coming-soon","text":"Few more freebies coming soon - Distributed Systems Book (expected 2023 Summer).","title":"Also Coming Soon"},{"location":"#other-products","text":"See the freebies page to see more products available for free to use.","title":"Other Products"},{"location":"#who-am-i","text":"This is me! I go by theroyakash on the internet. I am a computer scientist, a masters student in computer science from Indian Institute of Technology (IIT) Madras , with research in high-performance algorithms , data structures , distributed systems , and beyond. See my work searching google for theroyakash and on Github .","title":"Who am I?"},{"location":"#other-links","text":"Visit my website here . My Github , More about me , Send me an email .","title":"Other links"},{"location":"blind75/","tags":["Blind 75","ONGOING SERIES"],"text":"Blind 75 problems This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum II Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":"Blind 75 Problems"},{"location":"blind75/#blind-75-problems","text":"This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum II Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":" Blind 75 problems"},{"location":"freebies/","text":"Freebies Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked. C++ I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . How to use the stdin and stdout and take input from files and write output to text files to quickly submit solutions to online coding platforms. Here is an article with that information . Writing C++ Output with color Distinguishing C++ output inside the terminal is a hard job. Use the following color pallette to distinguish the outputs. #define RESET \"\\033[0m\" #define BLACK \"\\033[30m\" /* Black */ #define RED \"\\033[31m\" /* Red */ #define GREEN \"\\033[32m\" /* Green */ #define YELLOW \"\\033[33m\" /* Yellow */ #define BLUE \"\\033[34m\" /* Blue */ #define MAGENTA \"\\033[35m\" /* Magenta */ #define CYAN \"\\033[36m\" /* Cyan */ #define WHITE \"\\033[37m\" /* White */ #define BOLDBLACK \"\\033[1m\\033[30m\" /* Bold Black */ #define BOLDRED \"\\033[1m\\033[31m\" /* Bold Red */ #define BOLDGREEN \"\\033[1m\\033[32m\" /* Bold Green */ #define BOLDYELLOW \"\\033[1m\\033[33m\" /* Bold Yellow */ #define BOLDBLUE \"\\033[1m\\033[34m\" /* Bold Blue */ #define BOLDMAGENTA \"\\033[1m\\033[35m\" /* Bold Magenta */ #define BOLDCYAN \"\\033[1m\\033[36m\" /* Bold Cyan */ #define BOLDWHITE \"\\033[1m\\033[37m\" /* Bold White */ Usage with std::cout Everytime you use any of the color you must reset the color from the terminal like the following: int main () { vector < int > v = { 1 , 0 , 1 , 0 , 0 }; for ( auto i : v ) cout << BOLDCYAN << i << \" \" << RESET ; cout << \" \\n \" ; return 0 ; } Algorithms C++ C++ Algorithms is a simple data structure implementation library that you can remember to implement in an interview setting. Contributing There is some open positions for contribution in AKDSFramework tinyds , and C++ Algorithms projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Freebies"},{"location":"freebies/#freebies","text":"Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked.","title":"Freebies"},{"location":"freebies/#c","text":"I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . How to use the stdin and stdout and take input from files and write output to text files to quickly submit solutions to online coding platforms. Here is an article with that information .","title":"C++"},{"location":"freebies/#writing-c-output-with-color","text":"Distinguishing C++ output inside the terminal is a hard job. Use the following color pallette to distinguish the outputs. #define RESET \"\\033[0m\" #define BLACK \"\\033[30m\" /* Black */ #define RED \"\\033[31m\" /* Red */ #define GREEN \"\\033[32m\" /* Green */ #define YELLOW \"\\033[33m\" /* Yellow */ #define BLUE \"\\033[34m\" /* Blue */ #define MAGENTA \"\\033[35m\" /* Magenta */ #define CYAN \"\\033[36m\" /* Cyan */ #define WHITE \"\\033[37m\" /* White */ #define BOLDBLACK \"\\033[1m\\033[30m\" /* Bold Black */ #define BOLDRED \"\\033[1m\\033[31m\" /* Bold Red */ #define BOLDGREEN \"\\033[1m\\033[32m\" /* Bold Green */ #define BOLDYELLOW \"\\033[1m\\033[33m\" /* Bold Yellow */ #define BOLDBLUE \"\\033[1m\\033[34m\" /* Bold Blue */ #define BOLDMAGENTA \"\\033[1m\\033[35m\" /* Bold Magenta */ #define BOLDCYAN \"\\033[1m\\033[36m\" /* Bold Cyan */ #define BOLDWHITE \"\\033[1m\\033[37m\" /* Bold White */","title":"Writing C++ Output with color"},{"location":"freebies/#usage-with-stdcout","text":"Everytime you use any of the color you must reset the color from the terminal like the following: int main () { vector < int > v = { 1 , 0 , 1 , 0 , 0 }; for ( auto i : v ) cout << BOLDCYAN << i << \" \" << RESET ; cout << \" \\n \" ; return 0 ; }","title":"Usage with std::cout"},{"location":"freebies/#algorithms-c","text":"C++ Algorithms is a simple data structure implementation library that you can remember to implement in an interview setting.","title":"Algorithms C++"},{"location":"freebies/#contributing","text":"There is some open positions for contribution in AKDSFramework tinyds , and C++ Algorithms projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Contributing"},{"location":"stdinout-usage/","text":"Standard input output usage Taking data in and writing data out to a file In some of the problems in SDE 1 and SDE 2 online coding rounds, you have to take care of the program inputs. Here is an example of how we can write all inputs to a text file and then run our algorithms. You must add 2 files called \"input.txt\" and \"output.txt\" in the same directory and add these 2 lines of code in the main() freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Input Now in the input.txt file, you design as the inputs are given in the following case the input was 3 a b c 4 a b 12 c b 2 b a 99 c a 8 Output The corresponding output file is written as c [a: 8][b: 2] b [a: 99] a [b: 12] a->b c->b b->a c->a Code #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; int main () { freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Graph g ; int vertex ; cin >> vertex ; vector < char > v ; while ( vertex != 0 ){ char vertex_label ; cin >> vertex_label ; v . push_back ( vertex_label ); vertex -- ; } g . register_vertex ( v ); int numberofedges ; cin >> numberofedges ; while ( numberofedges != 0 ){ char from , to ; int weight ; cin >> from >> to >> weight ; g . add_edge ( from , to , weight ); numberofedges -- ; } unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } cout << \" \\n \" ; // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } cout << \" \\n \" ; }","title":"Standard Input Output"},{"location":"stdinout-usage/#standard-input-output-usage","text":"","title":"Standard input output usage"},{"location":"stdinout-usage/#taking-data-in-and-writing-data-out-to-a-file","text":"In some of the problems in SDE 1 and SDE 2 online coding rounds, you have to take care of the program inputs. Here is an example of how we can write all inputs to a text file and then run our algorithms. You must add 2 files called \"input.txt\" and \"output.txt\" in the same directory and add these 2 lines of code in the main() freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout );","title":"Taking data in and writing data out to a file"},{"location":"stdinout-usage/#input","text":"Now in the input.txt file, you design as the inputs are given in the following case the input was 3 a b c 4 a b 12 c b 2 b a 99 c a 8","title":"Input"},{"location":"stdinout-usage/#output","text":"The corresponding output file is written as c [a: 8][b: 2] b [a: 99] a [b: 12] a->b c->b b->a c->a","title":"Output"},{"location":"stdinout-usage/#code","text":"#include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; int main () { freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Graph g ; int vertex ; cin >> vertex ; vector < char > v ; while ( vertex != 0 ){ char vertex_label ; cin >> vertex_label ; v . push_back ( vertex_label ); vertex -- ; } g . register_vertex ( v ); int numberofedges ; cin >> numberofedges ; while ( numberofedges != 0 ){ char from , to ; int weight ; cin >> from >> to >> weight ; g . add_edge ( from , to , weight ); numberofedges -- ; } unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } cout << \" \\n \" ; // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } cout << \" \\n \" ; }","title":" Code"},{"location":"2heaps/problems/","text":"Two heaps problems These are the problems that generally requires two binary heaps i.e. a min heap and a max heap. We can divide the problem in two parts, we'll use a Min Heap to find the smallest element and a Max Heap to find the biggest element and combine the parts together. Let's see some questions on this. Find the Median of a Number Stream Design a class to calculate the median of a number stream. The class should have the following two methods insertNum(int num) : stores the number in the class findMedian() : returns the median of all numbers inserted in the class Just like a normal median function, if the count of numbers inserted in the class is even, the median will be the average of the middle two numbers. Example insertNum(3) insertNum(1) findMedian() \\(\\to\\) output: 2 insertNum(5) findMedian() \\(\\to\\) output: 3 insertNum(4) findMedian() \\(\\to\\) output: 3.5 Sliding Window Median Given an array of numbers and a number \u2018k\u2019, find the median of all the \u2018k\u2019 sized sub-arrays (or windows) of the array. Examples Input: nums = \\([1, 2, -1, 3, 5]\\) , \\(k = 2\\) Output: \\([1.5, 0.5, 1.0, 4.0]\\) Explanation: Lets consider all windows of size \\(2\\) : \\([1, 2, -1, 3, 5] \\to\\) median is \\(1.5\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(0.5\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(1.0\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(4.0\\)","title":"Two Heaps Problems"},{"location":"2heaps/problems/#two-heaps-problems","text":"These are the problems that generally requires two binary heaps i.e. a min heap and a max heap. We can divide the problem in two parts, we'll use a Min Heap to find the smallest element and a Max Heap to find the biggest element and combine the parts together. Let's see some questions on this.","title":"Two heaps problems"},{"location":"2heaps/problems/#find-the-median-of-a-number-stream","text":"Design a class to calculate the median of a number stream. The class should have the following two methods insertNum(int num) : stores the number in the class findMedian() : returns the median of all numbers inserted in the class Just like a normal median function, if the count of numbers inserted in the class is even, the median will be the average of the middle two numbers.","title":"Find the Median of a Number Stream"},{"location":"2heaps/problems/#example","text":"insertNum(3) insertNum(1) findMedian() \\(\\to\\) output: 2 insertNum(5) findMedian() \\(\\to\\) output: 3 insertNum(4) findMedian() \\(\\to\\) output: 3.5","title":"Example"},{"location":"2heaps/problems/#sliding-window-median","text":"Given an array of numbers and a number \u2018k\u2019, find the median of all the \u2018k\u2019 sized sub-arrays (or windows) of the array.","title":"Sliding Window Median"},{"location":"2heaps/problems/#examples","text":"Input: nums = \\([1, 2, -1, 3, 5]\\) , \\(k = 2\\) Output: \\([1.5, 0.5, 1.0, 4.0]\\) Explanation: Lets consider all windows of size \\(2\\) : \\([1, 2, -1, 3, 5] \\to\\) median is \\(1.5\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(0.5\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(1.0\\) \\([1, 2, -1, 3, 5] \\to\\) median is \\(4.0\\)","title":"Examples"},{"location":"LinkedLists/problems/","tags":["Linked List Problems","SDE 1 and SDE 2"],"text":"Linked List problems Questions discussed Implement Linked list and write reverse() Problem Statement Middle of the Linked List Merge 2 sorted lists Delete Node in a Linked List Remove Nth Node From End of List Add Two Numbers Given as LinkedLists Intersection of Two Linked Lists Detect a cycle in linked list Palindrome Linked list Find the starting point of cycle in linked list Given the head of a linked list, rotate the list to the right by k places Copy List with Random Pointer Merge k Sorted Lists Reverse Nodes in k-Group Implement Linked list and write reverse() Problem Statement Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\) Approach Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space. C++ Code for Linked List #include <iostream> #include <vector> using namespace std ; template < class T > class Node { public : T data ; Node < T >* next ; Node ( T value ) { data = value ; next = nullptr ; } }; template < class T > class LinkedList { private : int size ; public : Node < T >* head ; Node < T >* end ; LinkedList () { head = nullptr ; end = nullptr ; } ~ LinkedList () { // delete each and every node that is allocated while ( head ) { Node < T >* temp = head -> next ; delete ( head ); head = temp ; } } void push_front ( T value ) { Node < T >* newNode = new Node < T > ( value ); if ( not head and not end ) { head = newNode ; end = newNode ; } else { newNode -> next = head ; head = newNode ; } size ++ ; } void push_back ( T value ) { Node < T >* newNode = new Node < T > ( value ); if ( not head and not end ) { head = newNode ; end = newNode ; } else { end -> next = newNode ; end = newNode ; } } void out () const { Node < T >* traveller = head ; while ( traveller ) { cout << traveller -> data << \" \" ; traveller = traveller -> next ; } } T front () { return head -> data ; } T back () { return end -> data ; } }; linkedlist_reverse() method We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Middle of the Linked List Problem Statement Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\) Approach Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; } Merge 2 sorted lists Find the problem on Leetcode \\(\\to\\) Problem Statement You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4] Approach We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list. Code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; } Time and Space complexity Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation. Implementing this problem in-place Step wise iteration explainer Iteration 1 Iteration 2 Iteration 3 Iteration 4 Iteration 5, and so on and the last /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } }; Delete Node in a Linked List Problem on Leetcode \\(\\to\\) Problem Statement Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. Example Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Approach Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } }; Remove Nth Node From End of List Given the head of a linked list, remove the nth node from the end of the list and return its head Video Explaination Example For elements \\([1, 2, 3, 4, 5]\\) , remove the second node from the last. This will return \\([1, 2, 3, 5]\\) . Similarly \\([1]\\) and \\(n = 1\\) will return \\([]\\) . Constraints Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ The number of nodes in the list is \\(\\mathcal{N}\\) 1 <= \\(\\mathcal{N}\\) <= 30 0 <= (new ListNode())->val <= 100 1 <= n <= \\(\\mathcal{N}\\) (n is within the bounds). Approach Implementation with two pass Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; } Implementation with one pass only With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last. A bit modification We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following Edge Case There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; } C++ Code ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; } Time and space complexity For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution. Add Two Numbers Given as LinkedLists Asked in Amazon, Microsoft, Facebook, Qualcomm. Elsewhere Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\) Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Testcase Examples \\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\) Approach Do normal addition from 1st standard and add digit by digit in a new linked list. C++ code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; } C++ code for leetcode with custom definition for singly-linked list Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } }; Intersection of Two Linked Lists Find the problem on Leetcode \\(\\to\\) Problem Statement Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null . Example For the following problem, head1 and head2 are given, find the marked blue intersection point. Approach Brute Force approach For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space. Using Hash table As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point. C++ Code class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } }; Time and Space Complexity As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first. Linear time and Constant Space Approach Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean: C++ Code for Most Optimal Approach class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } }; Time and Space Complexity The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required. Detect a cycle in linked list Problem Statement Given head, the head of a linked list, determine if the linked list has a cycle in it. Approach Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true . C++ Code class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } }; Time and space complexity \\(O(N)\\) time and no extra space. Palindrome Linked list Problem Statement Given the head of a singly linked list, return true if it is a palindrome. Approach With More Space First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false . C++ Code class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } }; More optimized approach Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } }; Find the starting point of cycle in linked list Problem on Leetcode \\(\\to\\) Problem Statement Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory, Linked List definition // Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} }; Approach with extra space We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle. Pseudocode for this apporach ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; } Time and Space complexity Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable. Approach with no extra space First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet. Video for intuition The following is a video explaining why this apporach works? C++ Code class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } }; Given the head of a linked list, rotate the list to the right by k places Find the problem on Leetcode \\(\\to\\) Problem Statement Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints: The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\) Approach First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL . C++ Code class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } }; Another Approach We get hold of the last node and the size of the list, Rotating k times to the right means rotating \\(\\text{size} - k\\) times to the left, Once we have that, rotating left is as easy as the following Set markers on start and end of the list, Set new head as the head->next , Set end->next as the node previously at the start of the list, Set new end as this node, and Set new end->next as nullptr This is how we can easily rotate the list. C++ Code /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : int sizeOf ( ListNode * head ) { int size = 0 ; while ( head ) { head = head -> next ; size ++ ; } return size ; } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( not head or not head -> next ) return head ; int size = sizeOf ( head ); // k times rotate to the right means size - k times rotate to left int rotations = size - ( k % size ); // set the end pointer ListNode * end = head ; while ( end -> next ) end = end -> next ; while ( rotations > 0 ) { ListNode * tempHead = head ; head = head -> next ; ListNode * tempEnd = end ; end -> next = tempHead ; tempHead -> next = nullptr ; end = tempHead ; rotations -- ; } return head ; } }; Copy List with Random Pointer Find the Problem on leetcode \\(\\to\\) Problem Statement A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. C++ Node definition class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } }; Approach Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } }; Time and Memory complexity We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity. Merge k Sorted Lists Problem Statement You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1->4->5, 1->3->4, 2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Input: lists = [] Output: [] Input: lists = [[]] Output: [] Approach To merge \\(K\\) sorted list we'll use a subroutine merge \\(2\\) sorted list. Using that merge2list subroutine will merge like the merge sort algorithm, and the result will be a sorted list. To merge 2 sorted list you should watch the explaination here . Code /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : ListNode * merge2list ( ListNode * head1 , ListNode * head2 ) { if ( ! head1 ) return head2 ; if ( ! head2 ) return head1 ; ListNode * l1 ; ListNode * l2 ; if ( head1 -> val <= head2 -> val ) { l1 = head1 ; l2 = head2 ; } if ( head1 -> val > head2 -> val ) { l1 = head2 ; l2 = head1 ; } ListNode * dummy = new ListNode (); ListNode * temp = dummy ; while ( l1 and l2 ) { if ( l1 -> val < l2 -> val ) { temp -> next = l1 ; l1 = l1 -> next ; } else if ( l1 -> val >= l2 -> val ) { temp -> next = l2 ; l2 = l2 -> next ; } temp = temp -> next ; } if ( ! l1 ) temp -> next = l2 ; if ( ! l2 ) temp -> next = l1 ; return dummy -> next ; } public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { // call mergeSubRoutine on 2 lists // until mergeAll results to 1 list only if ( lists . size () == 0 ) return nullptr ; if ( lists . size () == 1 ) return lists [ 0 ]; while ( lists . size () > 1 ) { vector < ListNode *> temp ; for ( int i = 0 ; i < lists . size (); i += 2 ) { // take up 2 lists to merge ListNode * l1 = lists [ i ]; ListNode * l2 ; if ( i + 1 > lists . size () - 1 ) { l2 = nullptr ; } else { l2 = lists [ i + 1 ]; } temp . push_back ( merge2list ( l1 , l2 )); } // now in temp we have all the 2 merged lists // we should update the lists as the temp lists = temp ; } // at the end all are merged so we've only one list, so return it return lists [ 0 ]; } }; Reverse Nodes in k-Group Find the Problem on Leetcode \\(\\to\\) Problem Statement Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Example Input: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5] Approach We'll find the \\(k^{th}\\) node from the head of the list and then reverse it in-place, let's call it a group We'll then jump k places to reverse the next group, until we find the last group where there is remaining \\(\\geq 0 \\text{ and} \\leq k\\) elements. Then we stop there. Code /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : ListNode * kth ( ListNode * head , int k ) { while ( head and k > 0 ) { head = head -> next ; k -- ; } return head ; } public : ListNode * reverseKGroup ( ListNode * head , int k ) { auto dummy = new ListNode ( 0 , head ); auto prevEnd = dummy ; while ( true ) { auto kthNode = kth ( prevEnd , k ); if ( not kthNode ) break ; auto groupNext = kthNode -> next ; // we have the head and the kth node // so we should reverse it auto prev = groupNext ; auto current = prevEnd -> next ; while ( current != groupNext ) { auto temp = current -> next ; current -> next = prev ; prev = current ; current = temp ; } auto temp = prevEnd -> next ; prevEnd -> next = kthNode ; prevEnd = temp ; } return dummy -> next ; } };","title":"Linked List problems"},{"location":"LinkedLists/problems/#linked-list-problems","text":"Questions discussed Implement Linked list and write reverse() Problem Statement Middle of the Linked List Merge 2 sorted lists Delete Node in a Linked List Remove Nth Node From End of List Add Two Numbers Given as LinkedLists Intersection of Two Linked Lists Detect a cycle in linked list Palindrome Linked list Find the starting point of cycle in linked list Given the head of a linked list, rotate the list to the right by k places Copy List with Random Pointer Merge k Sorted Lists Reverse Nodes in k-Group","title":"Linked List problems"},{"location":"LinkedLists/problems/#implement-linked-list-and-write-reverse","text":"","title":"Implement Linked list and write reverse()"},{"location":"LinkedLists/problems/#problem-statement","text":"Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach","text":"Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space.","title":"Approach"},{"location":"LinkedLists/problems/#c-code-for-linked-list","text":"#include <iostream> #include <vector> using namespace std ; template < class T > class Node { public : T data ; Node < T >* next ; Node ( T value ) { data = value ; next = nullptr ; } }; template < class T > class LinkedList { private : int size ; public : Node < T >* head ; Node < T >* end ; LinkedList () { head = nullptr ; end = nullptr ; } ~ LinkedList () { // delete each and every node that is allocated while ( head ) { Node < T >* temp = head -> next ; delete ( head ); head = temp ; } } void push_front ( T value ) { Node < T >* newNode = new Node < T > ( value ); if ( not head and not end ) { head = newNode ; end = newNode ; } else { newNode -> next = head ; head = newNode ; } size ++ ; } void push_back ( T value ) { Node < T >* newNode = new Node < T > ( value ); if ( not head and not end ) { head = newNode ; end = newNode ; } else { end -> next = newNode ; end = newNode ; } } void out () const { Node < T >* traveller = head ; while ( traveller ) { cout << traveller -> data << \" \" ; traveller = traveller -> next ; } } T front () { return head -> data ; } T back () { return end -> data ; } };","title":"C++ Code for Linked List"},{"location":"LinkedLists/problems/#linkedlist_reverse-method","text":"We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } };","title":"linkedlist_reverse() method"},{"location":"LinkedLists/problems/#middle-of-the-linked-list","text":"","title":"Middle of the Linked List"},{"location":"LinkedLists/problems/#problem-statement_1","text":"Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_1","text":"Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; }","title":"Approach"},{"location":"LinkedLists/problems/#merge-2-sorted-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Merge 2 sorted lists"},{"location":"LinkedLists/problems/#problem-statement_2","text":"You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4]","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_2","text":"We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list.","title":"Approach"},{"location":"LinkedLists/problems/#code","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; }","title":" Code"},{"location":"LinkedLists/problems/#time-and-space-complexity","text":"Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation.","title":" Time and Space complexity"},{"location":"LinkedLists/problems/#implementing-this-problem-in-place","text":"","title":"Implementing this problem in-place"},{"location":"LinkedLists/problems/#step-wise-iteration-explainer","text":"","title":"Step wise iteration explainer"},{"location":"LinkedLists/problems/#iteration-1","text":"","title":"Iteration 1"},{"location":"LinkedLists/problems/#iteration-2","text":"","title":"Iteration 2"},{"location":"LinkedLists/problems/#iteration-3","text":"","title":"Iteration 3"},{"location":"LinkedLists/problems/#iteration-4","text":"","title":"Iteration 4"},{"location":"LinkedLists/problems/#iteration-5-and-so-on-and-the-last","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } };","title":"Iteration 5, and so on and the last"},{"location":"LinkedLists/problems/#delete-node-in-a-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Delete Node in a Linked List"},{"location":"LinkedLists/problems/#problem-statement_3","text":"Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.","title":"Problem Statement"},{"location":"LinkedLists/problems/#example","text":"Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.","title":"Example"},{"location":"LinkedLists/problems/#approach_3","text":"Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } };","title":"Approach"},{"location":"LinkedLists/problems/#remove-nth-node-from-end-of-list","text":"Given the head of a linked list, remove the nth node from the end of the list and return its head","title":"Remove Nth Node From End of List"},{"location":"LinkedLists/problems/#video-explaination","text":"","title":"Video Explaination"},{"location":"LinkedLists/problems/#example_1","text":"For elements \\([1, 2, 3, 4, 5]\\) , remove the second node from the last. This will return \\([1, 2, 3, 5]\\) . Similarly \\([1]\\) and \\(n = 1\\) will return \\([]\\) .","title":"Example"},{"location":"LinkedLists/problems/#constraints","text":"Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ The number of nodes in the list is \\(\\mathcal{N}\\) 1 <= \\(\\mathcal{N}\\) <= 30 0 <= (new ListNode())->val <= 100 1 <= n <= \\(\\mathcal{N}\\) (n is within the bounds).","title":"Constraints"},{"location":"LinkedLists/problems/#approach_4","text":"","title":"Approach"},{"location":"LinkedLists/problems/#implementation-with-two-pass","text":"Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; }","title":"Implementation with two pass"},{"location":"LinkedLists/problems/#implementation-with-one-pass-only","text":"With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last.","title":"Implementation with one pass only"},{"location":"LinkedLists/problems/#a-bit-modification","text":"We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following","title":"A bit modification"},{"location":"LinkedLists/problems/#edge-case","text":"There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; }","title":"Edge Case"},{"location":"LinkedLists/problems/#c-code","text":"ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; }","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_1","text":"For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#add-two-numbers-given-as-linkedlists","text":"Asked in Amazon, Microsoft, Facebook, Qualcomm.","title":"Add Two Numbers Given as LinkedLists"},{"location":"LinkedLists/problems/#elsewhere","text":"Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\)","title":"Elsewhere"},{"location":"LinkedLists/problems/#problem-statement_4","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","title":"Problem Statement"},{"location":"LinkedLists/problems/#testcase-examples","text":"\\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\)","title":"Testcase Examples"},{"location":"LinkedLists/problems/#approach_5","text":"Do normal addition from 1st standard and add digit by digit in a new linked list.","title":"Approach"},{"location":"LinkedLists/problems/#c-code_1","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; }","title":"C++ code"},{"location":"LinkedLists/problems/#c-code-for-leetcode-with-custom-definition-for-singly-linked-list","text":"Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } };","title":"C++ code for leetcode with custom definition for singly-linked list"},{"location":"LinkedLists/problems/#intersection-of-two-linked-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Intersection of Two Linked Lists"},{"location":"LinkedLists/problems/#problem-statement_5","text":"Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null .","title":"Problem Statement"},{"location":"LinkedLists/problems/#example_2","text":"For the following problem, head1 and head2 are given, find the marked blue intersection point.","title":"Example"},{"location":"LinkedLists/problems/#approach_6","text":"","title":"Approach"},{"location":"LinkedLists/problems/#brute-force-approach","text":"For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space.","title":"Brute Force approach"},{"location":"LinkedLists/problems/#using-hash-table","text":"As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point.","title":"Using Hash table"},{"location":"LinkedLists/problems/#c-code_2","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_2","text":"As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#linear-time-and-constant-space-approach","text":"Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean:","title":"Linear time and Constant Space Approach"},{"location":"LinkedLists/problems/#c-code-for-most-optimal-approach","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } };","title":"C++ Code for Most Optimal Approach"},{"location":"LinkedLists/problems/#time-and-space-complexity_3","text":"The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#detect-a-cycle-in-linked-list","text":"","title":"Detect a cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_6","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_7","text":"Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_3","text":"class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_4","text":"\\(O(N)\\) time and no extra space.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#palindrome-linked-list","text":"","title":"Palindrome Linked list"},{"location":"LinkedLists/problems/#problem-statement_7","text":"Given the head of a singly linked list, return true if it is a palindrome.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach-with-more-space","text":"First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false .","title":"Approach With More Space"},{"location":"LinkedLists/problems/#c-code_4","text":"class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#more-optimized-approach","text":"Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } };","title":"More optimized approach"},{"location":"LinkedLists/problems/#find-the-starting-point-of-cycle-in-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Find the starting point of cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_8","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list.","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_1","text":"The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory,","title":"Constraints"},{"location":"LinkedLists/problems/#linked-list-definition","text":"// Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} };","title":"Linked List definition"},{"location":"LinkedLists/problems/#approach-with-extra-space","text":"We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle.","title":"Approach with extra space"},{"location":"LinkedLists/problems/#pseudocode-for-this-apporach","text":"ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; }","title":"Pseudocode for this apporach"},{"location":"LinkedLists/problems/#time-and-space-complexity_5","text":"Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable.","title":"Time and Space complexity"},{"location":"LinkedLists/problems/#approach-with-no-extra-space","text":"First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet.","title":"Approach with no extra space"},{"location":"LinkedLists/problems/#video-for-intuition","text":"The following is a video explaining why this apporach works?","title":"Video for intuition"},{"location":"LinkedLists/problems/#c-code_5","text":"class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#given-the-head-of-a-linked-list-rotate-the-list-to-the-right-by-k-places","text":"Find the problem on Leetcode \\(\\to\\)","title":"Given the head of a linked list, rotate the list to the right by k places"},{"location":"LinkedLists/problems/#problem-statement_9","text":"Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1]","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_2","text":"The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\)","title":"Constraints:"},{"location":"LinkedLists/problems/#approach_8","text":"First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_6","text":"class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#another-approach","text":"We get hold of the last node and the size of the list, Rotating k times to the right means rotating \\(\\text{size} - k\\) times to the left, Once we have that, rotating left is as easy as the following Set markers on start and end of the list, Set new head as the head->next , Set end->next as the node previously at the start of the list, Set new end as this node, and Set new end->next as nullptr This is how we can easily rotate the list.","title":"Another Approach"},{"location":"LinkedLists/problems/#c-code_7","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : int sizeOf ( ListNode * head ) { int size = 0 ; while ( head ) { head = head -> next ; size ++ ; } return size ; } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( not head or not head -> next ) return head ; int size = sizeOf ( head ); // k times rotate to the right means size - k times rotate to left int rotations = size - ( k % size ); // set the end pointer ListNode * end = head ; while ( end -> next ) end = end -> next ; while ( rotations > 0 ) { ListNode * tempHead = head ; head = head -> next ; ListNode * tempEnd = end ; end -> next = tempHead ; tempHead -> next = nullptr ; end = tempHead ; rotations -- ; } return head ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#copy-list-with-random-pointer","text":"Find the Problem on leetcode \\(\\to\\)","title":"Copy List with Random Pointer"},{"location":"LinkedLists/problems/#problem-statement_10","text":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.","title":"Problem Statement"},{"location":"LinkedLists/problems/#c-node-definition","text":"class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } };","title":"C++ Node definition"},{"location":"LinkedLists/problems/#approach_9","text":"Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } };","title":"Approach"},{"location":"LinkedLists/problems/#time-and-memory-complexity","text":"We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.","title":"Time and Memory complexity"},{"location":"LinkedLists/problems/#merge-k-sorted-lists","text":"","title":"Merge k Sorted Lists"},{"location":"LinkedLists/problems/#problem-statement_11","text":"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.","title":"Problem Statement"},{"location":"LinkedLists/problems/#example_3","text":"Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1->4->5, 1->3->4, 2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Input: lists = [] Output: [] Input: lists = [[]] Output: []","title":"Example"},{"location":"LinkedLists/problems/#approach_10","text":"To merge \\(K\\) sorted list we'll use a subroutine merge \\(2\\) sorted list. Using that merge2list subroutine will merge like the merge sort algorithm, and the result will be a sorted list. To merge 2 sorted list you should watch the explaination here .","title":"Approach"},{"location":"LinkedLists/problems/#code_1","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : ListNode * merge2list ( ListNode * head1 , ListNode * head2 ) { if ( ! head1 ) return head2 ; if ( ! head2 ) return head1 ; ListNode * l1 ; ListNode * l2 ; if ( head1 -> val <= head2 -> val ) { l1 = head1 ; l2 = head2 ; } if ( head1 -> val > head2 -> val ) { l1 = head2 ; l2 = head1 ; } ListNode * dummy = new ListNode (); ListNode * temp = dummy ; while ( l1 and l2 ) { if ( l1 -> val < l2 -> val ) { temp -> next = l1 ; l1 = l1 -> next ; } else if ( l1 -> val >= l2 -> val ) { temp -> next = l2 ; l2 = l2 -> next ; } temp = temp -> next ; } if ( ! l1 ) temp -> next = l2 ; if ( ! l2 ) temp -> next = l1 ; return dummy -> next ; } public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { // call mergeSubRoutine on 2 lists // until mergeAll results to 1 list only if ( lists . size () == 0 ) return nullptr ; if ( lists . size () == 1 ) return lists [ 0 ]; while ( lists . size () > 1 ) { vector < ListNode *> temp ; for ( int i = 0 ; i < lists . size (); i += 2 ) { // take up 2 lists to merge ListNode * l1 = lists [ i ]; ListNode * l2 ; if ( i + 1 > lists . size () - 1 ) { l2 = nullptr ; } else { l2 = lists [ i + 1 ]; } temp . push_back ( merge2list ( l1 , l2 )); } // now in temp we have all the 2 merged lists // we should update the lists as the temp lists = temp ; } // at the end all are merged so we've only one list, so return it return lists [ 0 ]; } };","title":"Code"},{"location":"LinkedLists/problems/#reverse-nodes-in-k-group","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Reverse Nodes in k-Group"},{"location":"LinkedLists/problems/#problem-statement_12","text":"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.","title":"Problem Statement"},{"location":"LinkedLists/problems/#example_4","text":"Input: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5]","title":"Example"},{"location":"LinkedLists/problems/#approach_11","text":"We'll find the \\(k^{th}\\) node from the head of the list and then reverse it in-place, let's call it a group We'll then jump k places to reverse the next group, until we find the last group where there is remaining \\(\\geq 0 \\text{ and} \\leq k\\) elements. Then we stop there.","title":"Approach"},{"location":"LinkedLists/problems/#code_2","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private : ListNode * kth ( ListNode * head , int k ) { while ( head and k > 0 ) { head = head -> next ; k -- ; } return head ; } public : ListNode * reverseKGroup ( ListNode * head , int k ) { auto dummy = new ListNode ( 0 , head ); auto prevEnd = dummy ; while ( true ) { auto kthNode = kth ( prevEnd , k ); if ( not kthNode ) break ; auto groupNext = kthNode -> next ; // we have the head and the kth node // so we should reverse it auto prev = groupNext ; auto current = prevEnd -> next ; while ( current != groupNext ) { auto temp = current -> next ; current -> next = prev ; prev = current ; current = temp ; } auto temp = prevEnd -> next ; prevEnd -> next = kthNode ; prevEnd = temp ; } return dummy -> next ; } };","title":"Code"},{"location":"LinkedLists/stl-usage/","text":"Linked List STL operations Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure . Table of contents Linked List STL operations Table of contents std::list<typename> Operations Operation Modefiers Essential operations std::forward_list<typename> std::list<typename> supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted. Operations front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; } Operation Modefiers Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front() Essential operations merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; } std::forward_list<typename> front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"Linked List STL Usage"},{"location":"LinkedLists/stl-usage/#linked-list-stl-operations","text":"Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure .","title":"Linked List STL operations"},{"location":"LinkedLists/stl-usage/#table-of-contents","text":"Linked List STL operations Table of contents std::list<typename> Operations Operation Modefiers Essential operations std::forward_list<typename>","title":"Table of contents"},{"location":"LinkedLists/stl-usage/#stdlisttypename","text":"supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.","title":"std::list&lt;typename&gt;"},{"location":"LinkedLists/stl-usage/#operations","text":"front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; }","title":"Operations"},{"location":"LinkedLists/stl-usage/#operation-modefiers","text":"Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front()","title":"Operation Modefiers"},{"location":"LinkedLists/stl-usage/#essential-operations","text":"merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; }","title":"Essential operations"},{"location":"LinkedLists/stl-usage/#stdforward_listtypename","text":"front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"std::forward_list&lt;typename&gt;"},{"location":"arrays/array-problems/","text":"Problems on arrays Questions discussed Single Number Dutch National Flag Partitioning String Compression Problem Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock II Insert Interval Missing Number Majority Element Rotate Array How Many Numbers Are Smaller Than the Current Number Sort Array By Parity Replace Elements with Greatest Element on Right Side Sort colors Set matrix zeros Leaders in an array Count the number of inversions in an array Rotate Image Product of Array Except Self Two Sum II Input Array Is Sorted Container With Most Water Rain water trapping Two Sum IV Single Number Problem on Leetcode \\(\\to\\) Problem Statement Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Approach If the problem was given in a sorted array we can implement this binary search approach . But here the array is not sorted. We can use a dictionary but it'll take more space. Only other way of solving this problem is to use XOR operations. For each element in the array if we XOR them with each other we can find the odd one out. Code class Solution { public : int singleNumber ( vector < int >& nums ) { int start = nums . front (); for ( int i = 1 ; i < nums . size (); i ++ ) { start ^= nums [ i ]; } return start ; } }; Dutch National Flag Partitioning Problem Statement Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color. Solution Pattern Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an avarage \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Avarage running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time. String Compression Problem Problem Statement Implement a method to perform basic string compression, like \"aaaabbbcccaa\" \\(\\to\\) \"a4b3c3a2\" Approach Make a one key dictionary. Add and count the subsequent characters, for C++ you'd make a pair<int, int> and destroy it once a new character is seen, Once you find a new element then drop the key, add the contents to the builder string and count again. Code def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2' Time complexity This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string. Best Time to Buy and Sell Stock Problem on Leetcode \\(\\to\\) Problem Statement You are given an array prices where prices[i] is the price of a given stock on the \\(\\text{i}^{\\text{th}}\\) day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return \\(0\\) . Examples Example 1 Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2 Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Approach We start with the lowest profit possible which is \\(0\\) , We'll start the analysis from day \\(1\\) not from day \\(0\\) , We indicate the dip is the day \\(0^{th}\\) price. If we buy at that price then we analyse further. Now we analyze from day \\(1 ... N\\) For day \\(1\\) if we sell that stock the profit will be profSLT = prices[1] - dip at the lowest dip so far , we update the max profit by taking the std::max of previous maximum profit and todays profit. If todays price is lower than the last day's price, it is possible that we can get a better solution (profit) if not we already have stored the last best profit. We repeat this until we reach the last day. Code class Solution { public : int maxProfit ( vector < int >& prices ) { int mprof = 0 ; // maximum profit int dip = prices [ 0 ]; // should buy at lowest dip starting from day 1 for ( int i = 1 ; i < prices . size (); i ++ ) { // profit if sold today bought at the lowest dip so far; int profSLT = prices [ i ] - dip ; // if this is the maxprofit then update mprof = std :: max ( mprof , profSLT ); if ( prices [ i ] < dip ) dip = prices [ i ]; } return mprof ; } }; Best Time to Buy and Sell Stock II Problem on Leetcode \\(\\to\\) Problem Statement Similar to the previous problem, you are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. Approach Similar to the previous problem we'll continue to implement the logic but, if we see a dip later in the future, we'll sell off and buy at tomorrows dip to avoid any potential loss. Note Here profitInCurrentWindow in the code denotes the profit in the current window. An window is reset when we sell off the stock because there will be a dip in the next day. We start the window by buying the stock in the next dip. Code class Solution { public : int maxProfit ( vector < int >& prices ) { if ( prices . size () == 1 ) return 0 ; int totalProfit = 0 ; int dip = prices [ 0 ]; int profitInCurrentWindow = 0 ; // start from day 1 and local dip so far is day 0's price for ( int index = 1 ; index < prices . size (); index ++ ) { // today's price = prices[index] int price = prices [ index ]; // see if selling today entails profit? int profit = price - dip ; // what is the max profit possible in the current window profitInCurrentWindow = std :: max ( profitInCurrentWindow , profit ); // if it is profitable and tomorrow's price goes down don't hold, sell and exit // and reset the problem to next day and start again if ( profit > 0 and index < prices . size () - 1 ) { if ( prices [ index + 1 ] < prices [ index ]) { totalProfit = totalProfit + profitInCurrentWindow ; // also reset the dip to the index + 1 // for a new profit calculation for tomorrow dip = prices [ index + 1 ]; index ++ ; // we reset the entire problem and recalculate everything from the next index profitInCurrentWindow = 0 ; // reset the profit in the window } } if ( price < dip ) dip = price ; } totalProfit += profitInCurrentWindow ; // update the last profit window return totalProfit ; } }; Insert Interval Same Problem on Leetcode \\(\\to\\) Problem Statement You are given an array of non-overlapping intervals intervals where \\(\\text{intervals}[i] = [\\text{start}_i, \\text{end}_i]\\) represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval \\(\\text{newInterval} = [\\text{start}, \\text{end}]\\) that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Examples Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Missing Number Find the problem on Leetcode \\(\\to\\) Problem statement Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Approach There can be several approaches, one of which is sorting then find what's missing? There is also another approach where you sum up all the numbers (using \\(\\frac{n(n+1)}{2}\\) ) then subtract from elements present in the array. This is a \\(O(N)\\) and constant space solution. But using this is risky because if \\(n\\) is anywhere large enough to \\(\\text{INT_MAX}\\) then there is a high probability that \\(\\frac{n(n+1)}{2}\\) overflows. So it is not recommended to use this approach instead use the following one: There is another approach where you use XOR operations to find the missing elements. I have written all the code for all the approaches below. Here is no chance of integer overflow or anything. For XOR apporach you first have to find the XOR of elements from \\(\\{1 \\to n\\}\\) then find the XOR of elements present in the array. Now XOR between these two is the missing element so return it. Code Using sorting method class Solution { public : int missingNumber ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); int index = 0 ; for ( auto i : nums ) { if ( i != index ) return index ; index ++ ; } return index ; } }; Using sum and substraction method class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = n * ( n + 1 ) / 2 ; for ( int i : nums ) sum -= i ; return sum ; } }; Using XOR Method class Solution { public : int missingNumber ( vector < int >& nums ) { int l1 = 0 ; // contains xor of 1 to n int l2 = nums [ 0 ]; // contains xor of all the nums elements for ( int i = 0 ; i <= nums . size (); i ++ ) { l1 ^= i ; } for ( int j = 1 ; j < nums . size (); j ++ ) { l2 ^= nums [ j ]; } return l1 ^ l2 ; } }; Majority Element Problem on Leetcode \\(\\to\\) Problem Statement Given an array nums of size n, return the majority element. The majority element is the element that appears more than \\(\\lfloor\\frac{n}{2}\\rfloor\\) times. You may assume that the majority element always exists in the array. Approach One approach is to use a dictionary to implement a counter for each element. Then find what is \\(\\gt \\lfloor\\frac{n}{2}\\rfloor\\) , but it'll take extra \\(O(n)\\) space. So we need to find a new approach. There is an algorithm called boyer moore majority voting algorithm, using that we can easily find the majority element in the array. Boyer Moore Algorithm Boyer\u2013Moore majority vote algorithm can find the majority of a sequence of elements using linear time and constant space if exists. The returned result may not be the majority element (if not exists), so we have to do an additional check if the indicated element indeed the majority element. The algorithm goes like this: Initialize an element majority and a counter counter with counter = 0 For each element x of the input sequence: If counter = 0 , then assign majority as x and counter = 1 If you encounter next the same element as the majority element you increment the counter. Otherwise decrease the counter and no change to the majority element. at the end return the majority variable. It may be or may not be the majority element (if it doesn't exists) then we need check if that is the majority element with just a single pass. Example Let's run the algorithm on an example to see how this is working Running the algorithm on the example Iteration 1 to 4 Iteration 5 to 8 Iteration 9 and 10 At the very end the majority variable may or may not contains the majority element. We need check if that is the majority element with a single pass on the array to count up the number of occurrences of the element indicated in majority variable. Code class Solution { public : int majorityElement ( vector < int >& nums ) { int counter = 0 ; int majority = 0 ; for ( int i : nums ) { if ( counter == 0 ) { majority = i ; counter += 1 ; } else { if ( i == majority ) { counter ++ ; } else { counter -- ; } } } return majority ; // we assume that the majority element always exists in the array } }; Rotate Array Problem on Leetcode \\(\\to\\) Problem Statement Given an array, rotate the array to the right by k steps, where k is non-negative in constant space and linear time. Examples Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Several approaches with C++ code Not so much of an optimized approach, will fetch you a TLE. But for understanding it is a great apporach. We convert the k rotation problem into a subproblem of rotationOnce() for k times. We implement the rotationOnce() subroutine like this: See the last element, store it in last variable. then for element of index starting from \\(\\text{last} - 2\\) down to \\(0\\) swap it with the next element, to shift it by one, at last swap the first element ( \\(0^{th}\\) index element with the last variable). This is how you rotate by one element. Do this K times to solve the problem. Total time complexity is \\(O(kn)\\) , so we'll get TLE in the compiler. This is a polynomial in \\(n\\) and \\(k\\) . But \\(k\\) can be \\(2^n\\) so overall this is not efficient. We can reduce the number of subroutine calls down to \\(k \\text{mod} n\\) but if \\(n\\) is large enough and \\(k\\) is almost \\(n\\) then the problem of TLE again occurs. Here is a code using this approach class Solution { private : void rotateOnce ( vector < int >& nums ) { int last = nums . back (); int size = nums . size (); for ( int i = size -2 ; i >= 0 ; i -- ) { nums [ i + 1 ] = nums [ i ]; } nums [ 0 ] = last ; } public : void rotate ( vector < int >& nums , int k ) { int rotations = k % nums . size (); while ( rotations ) { rotateOnce ( nums ); rotations -- ; } } }; The code here will not run in a reasonable amount of time for a sufficiently large input size. So we have to design some better algorithms. Using Extra space (a faster algorithm in linear time) Instead of using the rotate once subroutine we can store all the last k elements in some temporary array, then instead of shifting one element once to the right and putting the last element to the front we can push those elements k step ahead put last k elements to the front of the array. This way the time complexity becomes linear time in \\(O(n + k)\\) . This does not give TLE. But this takes \\(O(k)\\) extra space. class Solution { public : void rotate ( vector < int >& nums , int k ) { k = k % nums . size (); int size = nums . size (); vector < int > temp ( nums . end () - k , nums . end ()); // for all the elements starting from // size - k - 1 down to 0 write it k space ahead for ( int i = size - k -1 ; i >= 0 ; i -- ) { nums [ i + k ] = nums [ i ]; } int start = 0 ; for ( auto t : temp ) { nums [ start ] = t ; start ++ ; } } }; Without extra space and linear time complexity in \\(n\\) There is a very ingenious solution to the problem. I'll explain this with diagrams and will give you an working C++ code. Approach The approach to get the solution goes like this: inplace reverse the array from last to \\(k\\) , then inplace reverse the array from start to size - k now reverse the whole array. Dry run on some example Example array Dry run on that example Code class Solution { private : void inplace_reverse ( vector < int >& nums , int start , int end ) { while ( start < end ) { int temp = nums [ start ]; nums [ start ] = nums [ end ]; nums [ end ] = temp ; start ++ ; end -- ; } } public : void rotate ( vector < int >& nums , int k ) { k = k % nums . size (); int size = nums . size (); inplace_reverse ( nums , size - k , size -1 ); inplace_reverse ( nums , 0 , size - k -1 ); inplace_reverse ( nums , 0 , size -1 ); } }; How Many Numbers Are Smaller Than the Current Number Problem on Leetcode \\(\\to\\) Problem Statement Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j 's such that j != i and nums[j] < nums[i] . Return the answer in an array. Approach The most straight forward approach is to implement this by sorting and binary searching the lower bound for each element in the array. First we sort the array. The amount of element that is lower than each element in the array is actually equal to the lowerbound on the sorted array. Using a non comparison based sorting algorithm we can reduce the time complexity even further down to \\(O(n)\\) . Code class Solution { private : int lower_bound ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start < end ) { if ( nums [ middle ] == target ) end = middle ; if ( nums [ middle ] < target ) start = middle + 1 ; if ( nums [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } return start ; } public : vector < int > smallerNumbersThanCurrent ( vector < int >& nums ) { vector < int > v ( nums . begin (), nums . end ()); vector < int > answers ; sort ( v . begin (), v . end ()); for ( int i : nums ) { int lb = lower_bound ( v , i ); answers . push_back ( lb ); } return answers ; } }; Sort Array By Parity Problem on Leetcode \\(\\to\\) Problem Statement Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Approach We'll use the in-place gathering algorithm to gather all the even numbers at the begining of the array. The in-place gathering algorithm is explained in the following video. It's a super useful gathering algorithm that gathers elements of an array based on some condition. In the video I have explained two different scenarios where this gathering algorithm can be used. Code class Solution { public : vector < int > sortArrayByParity ( vector < int >& nums ) { int even = 0 ; // gathering all the even integers for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] % 2 == 0 ) { int temp = nums [ i ]; nums [ i ] = nums [ even ]; nums [ even ] = temp ; even ++ ; } } return nums ; } }; Replace Elements with Greatest Element on Right Side Problem on Leetcode \\(\\to\\) Problem Statement Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array. Example Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Explanation: - index 0 --> the greatest element to the right of index 0 is index 1 (18). - index 1 --> the greatest element to the right of index 1 is index 4 (6). - index 2 --> the greatest element to the right of index 2 is index 4 (6). - index 3 --> the greatest element to the right of index 3 is index 4 (6). - index 4 --> the greatest element to the right of index 4 is index 5 (1). - index 5 --> there are no elements to the right of index 5, so we put -1. Approach One approach is to for each element find the maximum element from that element to the last of the aray, obviously this will take \\(O(n^2)\\) time which is not optimal. class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { vector < int > answer ; int _max = -1 ; for ( int i = 0 ; i < arr . size (); i ++ ) { if ( _max == arr [ i ]) _max = -1 ; // find the max from it's right for ( int j = i + 1 ; j < arr . size (); j ++ ) { _max = std :: max ( _max , arr [ j ]); } answer . push_back ( _max ); } return answer ; } }; Instead we'll use an ingenious way, we'll travel from the last to the begining of the array, first we'll make the maximum element to the right as \\(-1\\) , then we'll record the maximum element so far and go left to the beginning of the array. This will return the reverse of the intended result. At the end we'll reverese the elements in the array in-place. Code Extra space solution class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { vector < int > answer ; int _max = -1 ; answer . push_back ( _max ); _max = arr . back (); for ( int i = arr . size () - 2 ; i >= 0 ; i -- ) { answer . push_back ( _max ); _max = std :: max ( _max , arr [ i ]); } std :: reverse ( answer . begin (), answer . end ()); return answer ; } }; BUT the problem says we should use an inplace solution. So it is a but difficult to come up with an inplace solution but here we go, feel free to analyze this solution step by step to feel how it is working? class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int _max = -1 ; int back = arr . back (); for ( int i = arr . size () -1 ; i > 0 ; i -- ) { // update with the max we've seen so far arr [ i ] = _max ; // check if the current element is max or not? _max = std :: max ( back , _max ); // as we're updating `a[i]` we should hold the value // in `back` variable and go left to the array back = arr [ i - 1 ]; } arr [ 0 ] = _max ; return arr ; } }; Sort colors Problem on Leetcode \\(\\to\\) Problem Statement Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Approach This problem is the prime example where we should be using the in-place grouping algorithm. Using that we first group zeros with condition elements being less than \\(1\\) to the left of the array and then group 2's with condition elements being greater than \\(1\\) to the right of the array. All the ones would be sandwitched between 0s and 2s. This is how the array becomes sorted without the usage of sorting function. Code class Solution { public : void sortColors ( vector < int >& nums ) { int hinge = 1 ; // make hinge at 1 to group all < 1 and > 1 elements. int small = 0 ; // inplace grouping of zeros for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] < hinge ) { int temp = nums [ i ]; nums [ i ] = nums [ small ]; nums [ small ] = temp ; small ++ ; } } // inplace grouping of all 2s int larger = nums . size () - 1 ; for ( int j = nums . size () -1 ; j >= 0 ; j -- ) { if ( nums [ j ] > hinge ) { int temp = nums [ j ]; nums [ j ] = nums [ larger ]; nums [ larger ] = temp ; larger -- ; } } } }; Set matrix zeros Problem Statement Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. Example Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Approach Do stuffs Code class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { // setting 2 indicators // one for rows to be updated // one for columns to be updated vector < int > r ; vector < int > c ; for ( int i = 0 ; i < matrix . size (); i ++ ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); j ++ ) { if ( matrix [ i ][ j ] == 0 ) { r . push_back ( i ); c . push_back ( j ); } } } // set zeros for ( auto row : r ) { for ( int c = 0 ; c < matrix [ row ]. size (); c ++ ) matrix [ row ][ c ] = 0 ; } for ( auto col : c ) { for ( int r = 0 ; r < matrix . size (); r ++ ) matrix [ r ][ col ] = 0 ; } } }; Leaders in an array Problem on Coding Ninjas \\(\\to\\) Problem Statement Given a sequence of numbers. Find all leaders in sequence. An element is a leader if it is strictly greater than all the elements on its right side. Example The given sequence is [13, 14, 3, 8, 2] 13 Not a leader because on the right side 14 is greater than 13. 14 lt is a leader because no one greater element in the right side. 3 Not a leader because on the right side 8 are greater than 3. 8 It is a leader because no one greater element on the right side. 2 It is a leader because it is the rightmost element in a sequence. Hence there are 3 leaders in the above sequence which are 14, 8, 2. Approach We'll traverse the array from right to left, set the max as the last element push the last element on the answer, then go forward if we find any element that is greater than the current_max means it is a leader because it is greater than anything we've seen from its right, else just go backward without doing anything. At last in-place reverse the vector to get the result. Code void reverse_vector ( vector < int >& v ) { int start = 0 ; int end = v . size () - 1 ; while ( start < end ) { int temp = v [ start ]; v [ start ] = v [ end ]; v [ end ] = temp ; start ++ ; end -- ; } } vector < int > findLeaders ( vector < int > & elements , int n ) { // Write your code here. vector < int > leaders ; int current_max = elements . back (); leaders . push_back ( current_max ); for ( int i = elements . size () - 2 ; i >= 0 ; i -- ) { if ( elements [ i ] > current_max ) { current_max = elements [ i ]; leaders . push_back ( elements [ i ]); } } reverse_vector ( leaders ); return leaders ; } Time and memory complexity It takes total \\(O(N)\\) time and no extra space to run. Count the number of inversions in an array Find the problem on GeeksForGeeks \\(\\to\\) Problem Statement Given an array of integers. Find the Inversion Count in the array. Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum. Formally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j . Examples Input: N = 5, arr[] = {2, 4, 1, 3, 5} Output: 3 Explanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3). Input: N = 5 arr[] = {2, 3, 4, 5, 6} Output: 0 Explanation: As the sequence is already sorted so there is no inversion count. Input: N = 3, arr[] = {10, 10, 10} Output: 0 Explanation: As all the elements of array are same, so there is no inversion count. Constraints Expected Time Complexity: \\(O(n \\log n)\\) . Expected Auxiliary Space: \\(O(n)\\) Brute force Approach First we'll traverse from the end of the array to the first, for each element from \\(\\text{last} \\to \\text{first}\\) we'll check what is the number of elements that are greater than this element, these are the inversions. This will obviously take \\(O(n^2)\\) time complexity which will result in some TLE for larger testcases. Code for this approach class Solution { public : // arr[]: Input Array // N : Size of the Array arr[] // Function to count inversions in the array. long long int inversionCount ( long long arr [], long long N ) { // Your Code Here long long int inversions = 0 ; long long int start = 0 ; long long int end = N - 1 ; while ( end > start ) { for ( int t = end - 1 ; t >= 0 ; t -- ) { if ( arr [ t ] > arr [ end ]) { inversions ++ ; } } end -- ; } return inversions ; } }; Using this code passes 100 / 117 testcases in the gfg platform . So we need to optimize this further. A More optimized approach The following is a more optimized solution to find the number of inversions in the array, which takes a but lesser time so that we don't get any TLEs. The number of inversions is a measure of how unsorted the array really is. So using some sorting properties we must derive at the number of inversions. It is also should be noted that in a sorted array the number of inversions is \\(0\\) . We'll use merge sort to do this. During the merge sort we'll run some subroutine that'll calculate the number of inversions. This will take \\(O(n \\log n)\\) time which is faster than \\(O(n^2)\\) . So understanding the merge sort is a critical component solving this problem. Rotate Image Problem On Leetcode \\(\\to\\) Problem Statement You are given an \\(N \\times N\\) 2D matrix representing an image, rotate the image by \\(90\u00b0\\) degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Approach This is essentially equivalent to an in-place transpose of the matrix then inplace reversal of each row of the matrix. Code class Solution { private : void transposeSubroutine ( vector < vector < int >>& matrix ) { int end = matrix . size (); for ( int i = 0 ; i < end ; i ++ ) { for ( int j = i ; j < end ; j ++ ) { int temp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ j ][ i ]; matrix [ j ][ i ] = temp ; } } } void in_place_reversal ( vector < vector < int >>& matrix , int row ) { int start = 0 ; int end = matrix [ row ]. size () - 1 ; while ( start < end ) { int temp = matrix [ row ][ start ]; matrix [ row ][ start ] = matrix [ row ][ end ]; matrix [ row ][ end ] = temp ; start ++ ; end -- ; } } public : void rotate ( vector < vector < int >>& matrix ) { // rotating by 90* is essentially // computing the transpose of the matrix // then reversing all the arrays transposeSubroutine ( matrix ); // for each row do a inplace reversal for ( int i = 0 ; i < matrix . size (); i ++ ) { in_place_reversal ( matrix , i ); } } }; Product of Array Except Self Problem on Leetcode \\(\\to\\) Problem Statement Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i] . Example Input: nums = [1,2,3,4] Output: [24,12,8,6] Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Approach using division operator We can easily come up with a \\(O(n)\\) solution with \\(O(1)\\) memory complexity by just multiplying all the numbers of the array and divide them by the element at the current index. We should create provisions to handle Divide By Zero cases which you can see in the code below. Code using division operation class Solution { private : int findProductExceptIndex ( vector < int >& nums , int index ) { int product = 1 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i != index ) { product *= nums [ i ]; } } return product ; } public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > result ; int prod = 1 ; int zero_count = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { // to check if all are zero if ( nums [ i ] == 0 ) zero_count ++ ; // find the product of all prod *= nums [ i ]; } if ( zero_count == nums . size ()) { // if all are zero // directly return so no other computation is done vector < int > v ( zero_count , 0 ); return v ; } for ( int j = 0 ; j < nums . size (); j ++ ) { if ( prod == 0 ) { if ( nums [ j ] == 0 ) { // if this element is zero // then find the product except self // brutally result . push_back ( findProductExceptIndex ( nums , j )); } else { result . push_back ( 0 ); } } else { result . push_back ( prod / nums [ j ]); } } return result ; } }; Code for without the division approach class Solution { private : void reverse_vector ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; while ( start < end ) { int temp = nums [ start ]; nums [ start ] = nums [ end ]; nums [ end ] = temp ; start ++ ; end -- ; } } void prefixProd ( vector < int >& nums , vector < int >& prefix ) { int prod = 1 ; prefix . push_back ( 1 ); for ( auto i : nums ) { prefix . push_back ( prod * i ); prod = prefix . back (); } } void postfixProd ( vector < int >& nums , vector < int >& postfix ) { int prod = 1 ; for ( int i = nums . size () - 1 ; i >= 0 ; i -- ) { postfix . push_back ( prod * nums [ i ]); prod = postfix . back (); } // reverse subroutine at the end to get the actual answer reverse_vector ( postfix ); postfix . push_back ( 1 ); } public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > productExceptSelfOrder ; vector < int > prefix ; vector < int > postfix ; // build prefix and postfix products prefixProd ( nums , prefix ); postfixProd ( nums , postfix ); // now that we have both the prefix products and postfix products // it'll be easy to find the productExceptSelfOrder for ( int i = 0 ; i < postfix . size () - 1 ; i ++ ) { int preprod = prefix [ i ]; int postprod = postfix [ i + 1 ]; productExceptSelfOrder . push_back ( preprod * postprod ); } return productExceptSelfOrder ; } }; A Better in-place solution (most optimized) class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > answer ; int prod = 1 ; answer . push_back ( 1 ); for ( int i = 0 ; i < nums . size (); i ++ ) { answer . push_back ( prod * nums [ i ]); prod = answer . back (); } answer . pop_back (); // our answer now holds all the prefix // now instead of creating a new postfix array // just do the postfix in place prod = 1 ; for ( int j = nums . size () - 1 ; j >= 1 ; j -- ) { prod *= nums [ j ]; answer [ j - 1 ] *= prod ; } return answer ; } }; Two Sum II Input Array Is Sorted Find the Problem on Leetcode \\(\\to\\) Problem Statement Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where \\(1 \\le\\) index1 < index2 \\(\\leq\\) numbers.length . Return the indices of the two numbers, index1 and index2 , added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. The solution must use only constant extra space. Approach Our approach will use a two pointer solution. We'll put a pointer start at 0 and end at the end of the array. Next we'll see if sum < target , we must try to add some element greater than the array[start] so that our sum reaches target. As the array is already sorted in non-decreasing order we'll move start by 1 to increment the sum upto target, If sum > target means we overshoot the sum, so to reduce the sum down to target we'll decrement end by 1. Code class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int start = 0 ; int end = numbers . size () - 1 ; int sum = numbers [ start ] + numbers [ end ]; if ( sum == target ) { vector < int > v = { start + 1 , end + 1 }; return v ; } while ( sum != target and start < end ) { if ( sum == target ) break ; if ( sum < target ) { start ++ ; } if ( sum > target ) { end -- ; } sum = numbers [ start ] + numbers [ end ]; } vector < int > v = { start + 1 , end + 1 }; return v ; } }; Container With Most Water Find the problem on Leetcode \\(\\to\\) Problem Statement You are given an integer array height of length \\(n\\) . There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and ( i , height[i] ). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Approach [will be added soon] Code class Solution { public : int maxArea ( vector < int >& height ) { int start = 0 ; int end = height . size () - 1 ; int water = 0 ; while ( start < end ) { int h = std :: min ( height [ start ], height [ end ]); water = std :: max ( h * ( end - start ), water ); while ( start < end and height [ start ] <= h ) start ++ ; while ( start < end and height [ end ] <= h ) end -- ; } return water ; } }; Rain water trapping Same Problem on Leetcode \\(\\to\\) Problem Statement Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining. Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Explainer Rain Water Trapping Explainer Approach For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer Solution For each building find the maximum height on both left and right sides, then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system. Code class Solution { private : void _reverse ( vector < int > & v ) { int start = 0 ; int end = v . size () - 1 ; while ( start < end ) { int temp = v [ start ]; v [ start ] = v [ end ]; v [ end ] = temp ; start ++ ; end -- ; } } public : int trap ( vector < int >& height ) { // for each index find the maximum boundary to the left vector < int > left ; int currentMaxToLeft = 0 ; for ( auto i : height ) { if ( i > currentMaxToLeft ) { left . push_back ( currentMaxToLeft ); currentMaxToLeft = i ; } else { left . push_back ( currentMaxToLeft ); } } // for each index find the maximum boundary to the right vector < int > right ; int currentMaxToRight = 0 ; for ( int i = height . size () - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > currentMaxToRight ) { right . push_back ( currentMaxToRight ); currentMaxToRight = height [ i ]; } else { right . push_back ( currentMaxToRight ); } } _reverse ( right ); // reverse to sortout the order // based on the left max and right max we find the minimum among this two // (lower bound), then find the water on top of the building. int water = 0 ; for ( int i = 0 ; i < height . size () - 1 ; i ++ ) { // limiting height = min of left max and right max int limiter = std :: min ( left [ i ], right [ i ]); int waterOnTheBuilding = limiter - height [ i ]; if ( waterOnTheBuilding > 0 ) water += waterOnTheBuilding ; } return water ; } }; Two Sum IV Problem Statement Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Approach We've previously solved the problem Two sum II where the input is sorted. Using 2 pointer approach we easily solved the problem, similar to that here if we do an inorder traversal we'll also get a sorted array, So the approach works like that, we first traverse in-order then use a 2 pointer approach to solve the 2 sum problem. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : vector < int > inOrder ; void build ( TreeNode * root ) { if ( root ) { build ( root -> left ); inOrder . push_back ( root -> val ); build ( root -> right ); } } public : bool findTarget ( TreeNode * root , int k ) { build ( root ); // now 2 Sum II on the sorted list inOrder int start = 0 ; int end = inOrder . size () - 1 ; int sum = inOrder [ start ] + inOrder [ end ]; while ( start < end ) { if ( sum < k ) { start ++ ; } else if ( sum > k ) { end -- ; } else if ( sum == k ) { return true ; } sum = inOrder [ start ] + inOrder [ end ]; } return false ; } };","title":"Array Problems"},{"location":"arrays/array-problems/#problems-on-arrays","text":"Questions discussed Single Number Dutch National Flag Partitioning String Compression Problem Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock II Insert Interval Missing Number Majority Element Rotate Array How Many Numbers Are Smaller Than the Current Number Sort Array By Parity Replace Elements with Greatest Element on Right Side Sort colors Set matrix zeros Leaders in an array Count the number of inversions in an array Rotate Image Product of Array Except Self Two Sum II Input Array Is Sorted Container With Most Water Rain water trapping Two Sum IV","title":"Problems on arrays"},{"location":"arrays/array-problems/#single-number","text":"Problem on Leetcode \\(\\to\\)","title":"Single Number"},{"location":"arrays/array-problems/#problem-statement","text":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach","text":"If the problem was given in a sorted array we can implement this binary search approach . But here the array is not sorted. We can use a dictionary but it'll take more space. Only other way of solving this problem is to use XOR operations. For each element in the array if we XOR them with each other we can find the odd one out.","title":"Approach"},{"location":"arrays/array-problems/#code","text":"class Solution { public : int singleNumber ( vector < int >& nums ) { int start = nums . front (); for ( int i = 1 ; i < nums . size (); i ++ ) { start ^= nums [ i ]; } return start ; } };","title":"Code"},{"location":"arrays/array-problems/#dutch-national-flag-partitioning","text":"","title":"Dutch National Flag Partitioning"},{"location":"arrays/array-problems/#problem-statement_1","text":"Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color.","title":"Problem Statement"},{"location":"arrays/array-problems/#solution-pattern","text":"Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an avarage \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Avarage running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time.","title":"Solution Pattern"},{"location":"arrays/array-problems/#string-compression-problem","text":"","title":"String Compression Problem"},{"location":"arrays/array-problems/#problem-statement_2","text":"Implement a method to perform basic string compression, like \"aaaabbbcccaa\" \\(\\to\\) \"a4b3c3a2\"","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_1","text":"Make a one key dictionary. Add and count the subsequent characters, for C++ you'd make a pair<int, int> and destroy it once a new character is seen, Once you find a new element then drop the key, add the contents to the builder string and count again.","title":"Approach"},{"location":"arrays/array-problems/#code_1","text":"def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2'","title":"Code"},{"location":"arrays/array-problems/#time-complexity","text":"This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string.","title":"Time complexity"},{"location":"arrays/array-problems/#best-time-to-buy-and-sell-stock","text":"Problem on Leetcode \\(\\to\\)","title":"Best Time to Buy and Sell Stock"},{"location":"arrays/array-problems/#problem-statement_3","text":"You are given an array prices where prices[i] is the price of a given stock on the \\(\\text{i}^{\\text{th}}\\) day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return \\(0\\) .","title":"Problem Statement"},{"location":"arrays/array-problems/#examples","text":"","title":"Examples"},{"location":"arrays/array-problems/#example-1","text":"Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.","title":"Example 1"},{"location":"arrays/array-problems/#example-2","text":"Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0.","title":"Example 2"},{"location":"arrays/array-problems/#approach_2","text":"We start with the lowest profit possible which is \\(0\\) , We'll start the analysis from day \\(1\\) not from day \\(0\\) , We indicate the dip is the day \\(0^{th}\\) price. If we buy at that price then we analyse further. Now we analyze from day \\(1 ... N\\) For day \\(1\\) if we sell that stock the profit will be profSLT = prices[1] - dip at the lowest dip so far , we update the max profit by taking the std::max of previous maximum profit and todays profit. If todays price is lower than the last day's price, it is possible that we can get a better solution (profit) if not we already have stored the last best profit. We repeat this until we reach the last day.","title":"Approach"},{"location":"arrays/array-problems/#code_2","text":"class Solution { public : int maxProfit ( vector < int >& prices ) { int mprof = 0 ; // maximum profit int dip = prices [ 0 ]; // should buy at lowest dip starting from day 1 for ( int i = 1 ; i < prices . size (); i ++ ) { // profit if sold today bought at the lowest dip so far; int profSLT = prices [ i ] - dip ; // if this is the maxprofit then update mprof = std :: max ( mprof , profSLT ); if ( prices [ i ] < dip ) dip = prices [ i ]; } return mprof ; } };","title":"Code"},{"location":"arrays/array-problems/#best-time-to-buy-and-sell-stock-ii","text":"Problem on Leetcode \\(\\to\\)","title":"Best Time to Buy and Sell Stock II"},{"location":"arrays/array-problems/#problem-statement_4","text":"Similar to the previous problem, you are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_3","text":"Similar to the previous problem we'll continue to implement the logic but, if we see a dip later in the future, we'll sell off and buy at tomorrows dip to avoid any potential loss. Note Here profitInCurrentWindow in the code denotes the profit in the current window. An window is reset when we sell off the stock because there will be a dip in the next day. We start the window by buying the stock in the next dip.","title":"Approach"},{"location":"arrays/array-problems/#code_3","text":"class Solution { public : int maxProfit ( vector < int >& prices ) { if ( prices . size () == 1 ) return 0 ; int totalProfit = 0 ; int dip = prices [ 0 ]; int profitInCurrentWindow = 0 ; // start from day 1 and local dip so far is day 0's price for ( int index = 1 ; index < prices . size (); index ++ ) { // today's price = prices[index] int price = prices [ index ]; // see if selling today entails profit? int profit = price - dip ; // what is the max profit possible in the current window profitInCurrentWindow = std :: max ( profitInCurrentWindow , profit ); // if it is profitable and tomorrow's price goes down don't hold, sell and exit // and reset the problem to next day and start again if ( profit > 0 and index < prices . size () - 1 ) { if ( prices [ index + 1 ] < prices [ index ]) { totalProfit = totalProfit + profitInCurrentWindow ; // also reset the dip to the index + 1 // for a new profit calculation for tomorrow dip = prices [ index + 1 ]; index ++ ; // we reset the entire problem and recalculate everything from the next index profitInCurrentWindow = 0 ; // reset the profit in the window } } if ( price < dip ) dip = price ; } totalProfit += profitInCurrentWindow ; // update the last profit window return totalProfit ; } };","title":"Code"},{"location":"arrays/array-problems/#insert-interval","text":"Same Problem on Leetcode \\(\\to\\)","title":"Insert Interval"},{"location":"arrays/array-problems/#problem-statement_5","text":"You are given an array of non-overlapping intervals intervals where \\(\\text{intervals}[i] = [\\text{start}_i, \\text{end}_i]\\) represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval \\(\\text{newInterval} = [\\text{start}, \\text{end}]\\) that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion.","title":"Problem Statement"},{"location":"arrays/array-problems/#examples_1","text":"Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].","title":"Examples"},{"location":"arrays/array-problems/#missing-number","text":"Find the problem on Leetcode \\(\\to\\)","title":"Missing Number"},{"location":"arrays/array-problems/#problem-statement_6","text":"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","title":"Problem statement"},{"location":"arrays/array-problems/#example","text":"Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.","title":"Example"},{"location":"arrays/array-problems/#approach_4","text":"There can be several approaches, one of which is sorting then find what's missing? There is also another approach where you sum up all the numbers (using \\(\\frac{n(n+1)}{2}\\) ) then subtract from elements present in the array. This is a \\(O(N)\\) and constant space solution. But using this is risky because if \\(n\\) is anywhere large enough to \\(\\text{INT_MAX}\\) then there is a high probability that \\(\\frac{n(n+1)}{2}\\) overflows. So it is not recommended to use this approach instead use the following one: There is another approach where you use XOR operations to find the missing elements. I have written all the code for all the approaches below. Here is no chance of integer overflow or anything. For XOR apporach you first have to find the XOR of elements from \\(\\{1 \\to n\\}\\) then find the XOR of elements present in the array. Now XOR between these two is the missing element so return it.","title":"Approach"},{"location":"arrays/array-problems/#code_4","text":"","title":"Code"},{"location":"arrays/array-problems/#using-sorting-method","text":"class Solution { public : int missingNumber ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); int index = 0 ; for ( auto i : nums ) { if ( i != index ) return index ; index ++ ; } return index ; } };","title":"Using sorting method"},{"location":"arrays/array-problems/#using-sum-and-substraction-method","text":"class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = n * ( n + 1 ) / 2 ; for ( int i : nums ) sum -= i ; return sum ; } };","title":"Using sum and substraction method"},{"location":"arrays/array-problems/#using-xor-method","text":"class Solution { public : int missingNumber ( vector < int >& nums ) { int l1 = 0 ; // contains xor of 1 to n int l2 = nums [ 0 ]; // contains xor of all the nums elements for ( int i = 0 ; i <= nums . size (); i ++ ) { l1 ^= i ; } for ( int j = 1 ; j < nums . size (); j ++ ) { l2 ^= nums [ j ]; } return l1 ^ l2 ; } };","title":"Using XOR Method"},{"location":"arrays/array-problems/#majority-element","text":"Problem on Leetcode \\(\\to\\)","title":"Majority Element"},{"location":"arrays/array-problems/#problem-statement_7","text":"Given an array nums of size n, return the majority element. The majority element is the element that appears more than \\(\\lfloor\\frac{n}{2}\\rfloor\\) times. You may assume that the majority element always exists in the array.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_5","text":"One approach is to use a dictionary to implement a counter for each element. Then find what is \\(\\gt \\lfloor\\frac{n}{2}\\rfloor\\) , but it'll take extra \\(O(n)\\) space. So we need to find a new approach. There is an algorithm called boyer moore majority voting algorithm, using that we can easily find the majority element in the array.","title":"Approach"},{"location":"arrays/array-problems/#boyer-moore-algorithm","text":"Boyer\u2013Moore majority vote algorithm can find the majority of a sequence of elements using linear time and constant space if exists. The returned result may not be the majority element (if not exists), so we have to do an additional check if the indicated element indeed the majority element. The algorithm goes like this: Initialize an element majority and a counter counter with counter = 0 For each element x of the input sequence: If counter = 0 , then assign majority as x and counter = 1 If you encounter next the same element as the majority element you increment the counter. Otherwise decrease the counter and no change to the majority element. at the end return the majority variable. It may be or may not be the majority element (if it doesn't exists) then we need check if that is the majority element with just a single pass.","title":"Boyer Moore Algorithm"},{"location":"arrays/array-problems/#example_1","text":"Let's run the algorithm on an example to see how this is working","title":"Example"},{"location":"arrays/array-problems/#running-the-algorithm-on-the-example","text":"","title":"Running the algorithm on the example"},{"location":"arrays/array-problems/#iteration-1-to-4","text":"","title":"Iteration 1 to 4"},{"location":"arrays/array-problems/#iteration-5-to-8","text":"","title":"Iteration 5 to 8"},{"location":"arrays/array-problems/#iteration-9-and-10","text":"At the very end the majority variable may or may not contains the majority element. We need check if that is the majority element with a single pass on the array to count up the number of occurrences of the element indicated in majority variable.","title":"Iteration 9 and 10"},{"location":"arrays/array-problems/#code_5","text":"class Solution { public : int majorityElement ( vector < int >& nums ) { int counter = 0 ; int majority = 0 ; for ( int i : nums ) { if ( counter == 0 ) { majority = i ; counter += 1 ; } else { if ( i == majority ) { counter ++ ; } else { counter -- ; } } } return majority ; // we assume that the majority element always exists in the array } };","title":"Code"},{"location":"arrays/array-problems/#rotate-array","text":"Problem on Leetcode \\(\\to\\)","title":"Rotate Array"},{"location":"arrays/array-problems/#problem-statement_8","text":"Given an array, rotate the array to the right by k steps, where k is non-negative in constant space and linear time.","title":"Problem Statement"},{"location":"arrays/array-problems/#examples_2","text":"Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]","title":"Examples"},{"location":"arrays/array-problems/#several-approaches-with-c-code","text":"Not so much of an optimized approach, will fetch you a TLE. But for understanding it is a great apporach. We convert the k rotation problem into a subproblem of rotationOnce() for k times. We implement the rotationOnce() subroutine like this: See the last element, store it in last variable. then for element of index starting from \\(\\text{last} - 2\\) down to \\(0\\) swap it with the next element, to shift it by one, at last swap the first element ( \\(0^{th}\\) index element with the last variable). This is how you rotate by one element. Do this K times to solve the problem. Total time complexity is \\(O(kn)\\) , so we'll get TLE in the compiler. This is a polynomial in \\(n\\) and \\(k\\) . But \\(k\\) can be \\(2^n\\) so overall this is not efficient. We can reduce the number of subroutine calls down to \\(k \\text{mod} n\\) but if \\(n\\) is large enough and \\(k\\) is almost \\(n\\) then the problem of TLE again occurs. Here is a code using this approach class Solution { private : void rotateOnce ( vector < int >& nums ) { int last = nums . back (); int size = nums . size (); for ( int i = size -2 ; i >= 0 ; i -- ) { nums [ i + 1 ] = nums [ i ]; } nums [ 0 ] = last ; } public : void rotate ( vector < int >& nums , int k ) { int rotations = k % nums . size (); while ( rotations ) { rotateOnce ( nums ); rotations -- ; } } }; The code here will not run in a reasonable amount of time for a sufficiently large input size. So we have to design some better algorithms.","title":"Several approaches with C++ code"},{"location":"arrays/array-problems/#using-extra-space-a-faster-algorithm-in-linear-time","text":"Instead of using the rotate once subroutine we can store all the last k elements in some temporary array, then instead of shifting one element once to the right and putting the last element to the front we can push those elements k step ahead put last k elements to the front of the array. This way the time complexity becomes linear time in \\(O(n + k)\\) . This does not give TLE. But this takes \\(O(k)\\) extra space. class Solution { public : void rotate ( vector < int >& nums , int k ) { k = k % nums . size (); int size = nums . size (); vector < int > temp ( nums . end () - k , nums . end ()); // for all the elements starting from // size - k - 1 down to 0 write it k space ahead for ( int i = size - k -1 ; i >= 0 ; i -- ) { nums [ i + k ] = nums [ i ]; } int start = 0 ; for ( auto t : temp ) { nums [ start ] = t ; start ++ ; } } };","title":"Using Extra space (a faster algorithm in linear time)"},{"location":"arrays/array-problems/#without-extra-space-and-linear-time-complexity-in-n","text":"There is a very ingenious solution to the problem. I'll explain this with diagrams and will give you an working C++ code.","title":"Without extra space and linear time complexity in \\(n\\)"},{"location":"arrays/array-problems/#approach_6","text":"The approach to get the solution goes like this: inplace reverse the array from last to \\(k\\) , then inplace reverse the array from start to size - k now reverse the whole array.","title":"Approach"},{"location":"arrays/array-problems/#dry-run-on-some-example","text":"Example array Dry run on that example","title":"Dry run on some example"},{"location":"arrays/array-problems/#code_6","text":"class Solution { private : void inplace_reverse ( vector < int >& nums , int start , int end ) { while ( start < end ) { int temp = nums [ start ]; nums [ start ] = nums [ end ]; nums [ end ] = temp ; start ++ ; end -- ; } } public : void rotate ( vector < int >& nums , int k ) { k = k % nums . size (); int size = nums . size (); inplace_reverse ( nums , size - k , size -1 ); inplace_reverse ( nums , 0 , size - k -1 ); inplace_reverse ( nums , 0 , size -1 ); } };","title":"Code"},{"location":"arrays/array-problems/#how-many-numbers-are-smaller-than-the-current-number","text":"Problem on Leetcode \\(\\to\\)","title":"How Many Numbers Are Smaller Than the Current Number"},{"location":"arrays/array-problems/#problem-statement_9","text":"Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j 's such that j != i and nums[j] < nums[i] . Return the answer in an array.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_7","text":"The most straight forward approach is to implement this by sorting and binary searching the lower bound for each element in the array. First we sort the array. The amount of element that is lower than each element in the array is actually equal to the lowerbound on the sorted array. Using a non comparison based sorting algorithm we can reduce the time complexity even further down to \\(O(n)\\) .","title":"Approach"},{"location":"arrays/array-problems/#code_7","text":"class Solution { private : int lower_bound ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start < end ) { if ( nums [ middle ] == target ) end = middle ; if ( nums [ middle ] < target ) start = middle + 1 ; if ( nums [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } return start ; } public : vector < int > smallerNumbersThanCurrent ( vector < int >& nums ) { vector < int > v ( nums . begin (), nums . end ()); vector < int > answers ; sort ( v . begin (), v . end ()); for ( int i : nums ) { int lb = lower_bound ( v , i ); answers . push_back ( lb ); } return answers ; } };","title":"Code"},{"location":"arrays/array-problems/#sort-array-by-parity","text":"Problem on Leetcode \\(\\to\\)","title":"Sort Array By Parity"},{"location":"arrays/array-problems/#problem-statement_10","text":"Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_8","text":"We'll use the in-place gathering algorithm to gather all the even numbers at the begining of the array. The in-place gathering algorithm is explained in the following video. It's a super useful gathering algorithm that gathers elements of an array based on some condition. In the video I have explained two different scenarios where this gathering algorithm can be used.","title":"Approach"},{"location":"arrays/array-problems/#code_8","text":"class Solution { public : vector < int > sortArrayByParity ( vector < int >& nums ) { int even = 0 ; // gathering all the even integers for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] % 2 == 0 ) { int temp = nums [ i ]; nums [ i ] = nums [ even ]; nums [ even ] = temp ; even ++ ; } } return nums ; } };","title":"Code"},{"location":"arrays/array-problems/#replace-elements-with-greatest-element-on-right-side","text":"Problem on Leetcode \\(\\to\\)","title":"Replace Elements with Greatest Element on Right Side"},{"location":"arrays/array-problems/#problem-statement_11","text":"Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_2","text":"Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Explanation: - index 0 --> the greatest element to the right of index 0 is index 1 (18). - index 1 --> the greatest element to the right of index 1 is index 4 (6). - index 2 --> the greatest element to the right of index 2 is index 4 (6). - index 3 --> the greatest element to the right of index 3 is index 4 (6). - index 4 --> the greatest element to the right of index 4 is index 5 (1). - index 5 --> there are no elements to the right of index 5, so we put -1.","title":"Example"},{"location":"arrays/array-problems/#approach_9","text":"One approach is to for each element find the maximum element from that element to the last of the aray, obviously this will take \\(O(n^2)\\) time which is not optimal. class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { vector < int > answer ; int _max = -1 ; for ( int i = 0 ; i < arr . size (); i ++ ) { if ( _max == arr [ i ]) _max = -1 ; // find the max from it's right for ( int j = i + 1 ; j < arr . size (); j ++ ) { _max = std :: max ( _max , arr [ j ]); } answer . push_back ( _max ); } return answer ; } }; Instead we'll use an ingenious way, we'll travel from the last to the begining of the array, first we'll make the maximum element to the right as \\(-1\\) , then we'll record the maximum element so far and go left to the beginning of the array. This will return the reverse of the intended result. At the end we'll reverese the elements in the array in-place.","title":"Approach"},{"location":"arrays/array-problems/#code_9","text":"Extra space solution class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { vector < int > answer ; int _max = -1 ; answer . push_back ( _max ); _max = arr . back (); for ( int i = arr . size () - 2 ; i >= 0 ; i -- ) { answer . push_back ( _max ); _max = std :: max ( _max , arr [ i ]); } std :: reverse ( answer . begin (), answer . end ()); return answer ; } }; BUT the problem says we should use an inplace solution. So it is a but difficult to come up with an inplace solution but here we go, feel free to analyze this solution step by step to feel how it is working? class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int _max = -1 ; int back = arr . back (); for ( int i = arr . size () -1 ; i > 0 ; i -- ) { // update with the max we've seen so far arr [ i ] = _max ; // check if the current element is max or not? _max = std :: max ( back , _max ); // as we're updating `a[i]` we should hold the value // in `back` variable and go left to the array back = arr [ i - 1 ]; } arr [ 0 ] = _max ; return arr ; } };","title":"Code"},{"location":"arrays/array-problems/#sort-colors","text":"Problem on Leetcode \\(\\to\\)","title":"Sort colors"},{"location":"arrays/array-problems/#problem-statement_12","text":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_10","text":"This problem is the prime example where we should be using the in-place grouping algorithm. Using that we first group zeros with condition elements being less than \\(1\\) to the left of the array and then group 2's with condition elements being greater than \\(1\\) to the right of the array. All the ones would be sandwitched between 0s and 2s. This is how the array becomes sorted without the usage of sorting function.","title":"Approach"},{"location":"arrays/array-problems/#code_10","text":"class Solution { public : void sortColors ( vector < int >& nums ) { int hinge = 1 ; // make hinge at 1 to group all < 1 and > 1 elements. int small = 0 ; // inplace grouping of zeros for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] < hinge ) { int temp = nums [ i ]; nums [ i ] = nums [ small ]; nums [ small ] = temp ; small ++ ; } } // inplace grouping of all 2s int larger = nums . size () - 1 ; for ( int j = nums . size () -1 ; j >= 0 ; j -- ) { if ( nums [ j ] > hinge ) { int temp = nums [ j ]; nums [ j ] = nums [ larger ]; nums [ larger ] = temp ; larger -- ; } } } };","title":"Code"},{"location":"arrays/array-problems/#set-matrix-zeros","text":"","title":"Set matrix zeros"},{"location":"arrays/array-problems/#problem-statement_13","text":"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_3","text":"Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]]","title":"Example"},{"location":"arrays/array-problems/#approach_11","text":"Do stuffs","title":"Approach"},{"location":"arrays/array-problems/#code_11","text":"class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { // setting 2 indicators // one for rows to be updated // one for columns to be updated vector < int > r ; vector < int > c ; for ( int i = 0 ; i < matrix . size (); i ++ ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); j ++ ) { if ( matrix [ i ][ j ] == 0 ) { r . push_back ( i ); c . push_back ( j ); } } } // set zeros for ( auto row : r ) { for ( int c = 0 ; c < matrix [ row ]. size (); c ++ ) matrix [ row ][ c ] = 0 ; } for ( auto col : c ) { for ( int r = 0 ; r < matrix . size (); r ++ ) matrix [ r ][ col ] = 0 ; } } };","title":"Code"},{"location":"arrays/array-problems/#leaders-in-an-array","text":"Problem on Coding Ninjas \\(\\to\\)","title":"Leaders in an array"},{"location":"arrays/array-problems/#problem-statement_14","text":"Given a sequence of numbers. Find all leaders in sequence. An element is a leader if it is strictly greater than all the elements on its right side.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_4","text":"The given sequence is [13, 14, 3, 8, 2] 13 Not a leader because on the right side 14 is greater than 13. 14 lt is a leader because no one greater element in the right side. 3 Not a leader because on the right side 8 are greater than 3. 8 It is a leader because no one greater element on the right side. 2 It is a leader because it is the rightmost element in a sequence. Hence there are 3 leaders in the above sequence which are 14, 8, 2.","title":"Example"},{"location":"arrays/array-problems/#approach_12","text":"We'll traverse the array from right to left, set the max as the last element push the last element on the answer, then go forward if we find any element that is greater than the current_max means it is a leader because it is greater than anything we've seen from its right, else just go backward without doing anything. At last in-place reverse the vector to get the result.","title":"Approach"},{"location":"arrays/array-problems/#code_12","text":"void reverse_vector ( vector < int >& v ) { int start = 0 ; int end = v . size () - 1 ; while ( start < end ) { int temp = v [ start ]; v [ start ] = v [ end ]; v [ end ] = temp ; start ++ ; end -- ; } } vector < int > findLeaders ( vector < int > & elements , int n ) { // Write your code here. vector < int > leaders ; int current_max = elements . back (); leaders . push_back ( current_max ); for ( int i = elements . size () - 2 ; i >= 0 ; i -- ) { if ( elements [ i ] > current_max ) { current_max = elements [ i ]; leaders . push_back ( elements [ i ]); } } reverse_vector ( leaders ); return leaders ; }","title":"Code"},{"location":"arrays/array-problems/#time-and-memory-complexity","text":"It takes total \\(O(N)\\) time and no extra space to run.","title":"Time and memory complexity"},{"location":"arrays/array-problems/#count-the-number-of-inversions-in-an-array","text":"Find the problem on GeeksForGeeks \\(\\to\\)","title":"Count the number of inversions in an array"},{"location":"arrays/array-problems/#problem-statement_15","text":"Given an array of integers. Find the Inversion Count in the array. Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum. Formally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j .","title":"Problem Statement"},{"location":"arrays/array-problems/#examples_3","text":"Input: N = 5, arr[] = {2, 4, 1, 3, 5} Output: 3 Explanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3). Input: N = 5 arr[] = {2, 3, 4, 5, 6} Output: 0 Explanation: As the sequence is already sorted so there is no inversion count. Input: N = 3, arr[] = {10, 10, 10} Output: 0 Explanation: As all the elements of array are same, so there is no inversion count.","title":"Examples"},{"location":"arrays/array-problems/#constraints","text":"Expected Time Complexity: \\(O(n \\log n)\\) . Expected Auxiliary Space: \\(O(n)\\)","title":"Constraints"},{"location":"arrays/array-problems/#brute-force-approach","text":"First we'll traverse from the end of the array to the first, for each element from \\(\\text{last} \\to \\text{first}\\) we'll check what is the number of elements that are greater than this element, these are the inversions. This will obviously take \\(O(n^2)\\) time complexity which will result in some TLE for larger testcases.","title":"Brute force Approach"},{"location":"arrays/array-problems/#code-for-this-approach","text":"class Solution { public : // arr[]: Input Array // N : Size of the Array arr[] // Function to count inversions in the array. long long int inversionCount ( long long arr [], long long N ) { // Your Code Here long long int inversions = 0 ; long long int start = 0 ; long long int end = N - 1 ; while ( end > start ) { for ( int t = end - 1 ; t >= 0 ; t -- ) { if ( arr [ t ] > arr [ end ]) { inversions ++ ; } } end -- ; } return inversions ; } }; Using this code passes 100 / 117 testcases in the gfg platform . So we need to optimize this further.","title":"Code for this approach"},{"location":"arrays/array-problems/#a-more-optimized-approach","text":"The following is a more optimized solution to find the number of inversions in the array, which takes a but lesser time so that we don't get any TLEs. The number of inversions is a measure of how unsorted the array really is. So using some sorting properties we must derive at the number of inversions. It is also should be noted that in a sorted array the number of inversions is \\(0\\) . We'll use merge sort to do this. During the merge sort we'll run some subroutine that'll calculate the number of inversions. This will take \\(O(n \\log n)\\) time which is faster than \\(O(n^2)\\) . So understanding the merge sort is a critical component solving this problem.","title":"A More optimized approach"},{"location":"arrays/array-problems/#rotate-image","text":"Problem On Leetcode \\(\\to\\)","title":"Rotate Image"},{"location":"arrays/array-problems/#problem-statement_16","text":"You are given an \\(N \\times N\\) 2D matrix representing an image, rotate the image by \\(90\u00b0\\) degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_13","text":"This is essentially equivalent to an in-place transpose of the matrix then inplace reversal of each row of the matrix.","title":"Approach"},{"location":"arrays/array-problems/#code_13","text":"class Solution { private : void transposeSubroutine ( vector < vector < int >>& matrix ) { int end = matrix . size (); for ( int i = 0 ; i < end ; i ++ ) { for ( int j = i ; j < end ; j ++ ) { int temp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ j ][ i ]; matrix [ j ][ i ] = temp ; } } } void in_place_reversal ( vector < vector < int >>& matrix , int row ) { int start = 0 ; int end = matrix [ row ]. size () - 1 ; while ( start < end ) { int temp = matrix [ row ][ start ]; matrix [ row ][ start ] = matrix [ row ][ end ]; matrix [ row ][ end ] = temp ; start ++ ; end -- ; } } public : void rotate ( vector < vector < int >>& matrix ) { // rotating by 90* is essentially // computing the transpose of the matrix // then reversing all the arrays transposeSubroutine ( matrix ); // for each row do a inplace reversal for ( int i = 0 ; i < matrix . size (); i ++ ) { in_place_reversal ( matrix , i ); } } };","title":"Code"},{"location":"arrays/array-problems/#product-of-array-except-self","text":"Problem on Leetcode \\(\\to\\)","title":"Product of Array Except Self"},{"location":"arrays/array-problems/#problem-statement_17","text":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i] .","title":"Problem Statement"},{"location":"arrays/array-problems/#example_5","text":"Input: nums = [1,2,3,4] Output: [24,12,8,6] Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]","title":"Example"},{"location":"arrays/array-problems/#approach-using-division-operator","text":"We can easily come up with a \\(O(n)\\) solution with \\(O(1)\\) memory complexity by just multiplying all the numbers of the array and divide them by the element at the current index. We should create provisions to handle Divide By Zero cases which you can see in the code below.","title":"Approach using division operator"},{"location":"arrays/array-problems/#code-using-division-operation","text":"class Solution { private : int findProductExceptIndex ( vector < int >& nums , int index ) { int product = 1 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i != index ) { product *= nums [ i ]; } } return product ; } public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > result ; int prod = 1 ; int zero_count = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { // to check if all are zero if ( nums [ i ] == 0 ) zero_count ++ ; // find the product of all prod *= nums [ i ]; } if ( zero_count == nums . size ()) { // if all are zero // directly return so no other computation is done vector < int > v ( zero_count , 0 ); return v ; } for ( int j = 0 ; j < nums . size (); j ++ ) { if ( prod == 0 ) { if ( nums [ j ] == 0 ) { // if this element is zero // then find the product except self // brutally result . push_back ( findProductExceptIndex ( nums , j )); } else { result . push_back ( 0 ); } } else { result . push_back ( prod / nums [ j ]); } } return result ; } };","title":"Code using division operation"},{"location":"arrays/array-problems/#code-for-without-the-division-approach","text":"class Solution { private : void reverse_vector ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; while ( start < end ) { int temp = nums [ start ]; nums [ start ] = nums [ end ]; nums [ end ] = temp ; start ++ ; end -- ; } } void prefixProd ( vector < int >& nums , vector < int >& prefix ) { int prod = 1 ; prefix . push_back ( 1 ); for ( auto i : nums ) { prefix . push_back ( prod * i ); prod = prefix . back (); } } void postfixProd ( vector < int >& nums , vector < int >& postfix ) { int prod = 1 ; for ( int i = nums . size () - 1 ; i >= 0 ; i -- ) { postfix . push_back ( prod * nums [ i ]); prod = postfix . back (); } // reverse subroutine at the end to get the actual answer reverse_vector ( postfix ); postfix . push_back ( 1 ); } public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > productExceptSelfOrder ; vector < int > prefix ; vector < int > postfix ; // build prefix and postfix products prefixProd ( nums , prefix ); postfixProd ( nums , postfix ); // now that we have both the prefix products and postfix products // it'll be easy to find the productExceptSelfOrder for ( int i = 0 ; i < postfix . size () - 1 ; i ++ ) { int preprod = prefix [ i ]; int postprod = postfix [ i + 1 ]; productExceptSelfOrder . push_back ( preprod * postprod ); } return productExceptSelfOrder ; } };","title":"Code for without the division approach"},{"location":"arrays/array-problems/#a-better-in-place-solution-most-optimized","text":"class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > answer ; int prod = 1 ; answer . push_back ( 1 ); for ( int i = 0 ; i < nums . size (); i ++ ) { answer . push_back ( prod * nums [ i ]); prod = answer . back (); } answer . pop_back (); // our answer now holds all the prefix // now instead of creating a new postfix array // just do the postfix in place prod = 1 ; for ( int j = nums . size () - 1 ; j >= 1 ; j -- ) { prod *= nums [ j ]; answer [ j - 1 ] *= prod ; } return answer ; } };","title":"A Better in-place solution (most optimized)"},{"location":"arrays/array-problems/#two-sum-ii-input-array-is-sorted","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Two Sum II Input Array Is Sorted"},{"location":"arrays/array-problems/#problem-statement_18","text":"Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where \\(1 \\le\\) index1 < index2 \\(\\leq\\) numbers.length . Return the indices of the two numbers, index1 and index2 , added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. The solution must use only constant extra space.","title":"Problem Statement"},{"location":"arrays/array-problems/#approach_14","text":"Our approach will use a two pointer solution. We'll put a pointer start at 0 and end at the end of the array. Next we'll see if sum < target , we must try to add some element greater than the array[start] so that our sum reaches target. As the array is already sorted in non-decreasing order we'll move start by 1 to increment the sum upto target, If sum > target means we overshoot the sum, so to reduce the sum down to target we'll decrement end by 1.","title":"Approach"},{"location":"arrays/array-problems/#code_14","text":"class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int start = 0 ; int end = numbers . size () - 1 ; int sum = numbers [ start ] + numbers [ end ]; if ( sum == target ) { vector < int > v = { start + 1 , end + 1 }; return v ; } while ( sum != target and start < end ) { if ( sum == target ) break ; if ( sum < target ) { start ++ ; } if ( sum > target ) { end -- ; } sum = numbers [ start ] + numbers [ end ]; } vector < int > v = { start + 1 , end + 1 }; return v ; } };","title":"Code"},{"location":"arrays/array-problems/#container-with-most-water","text":"Find the problem on Leetcode \\(\\to\\)","title":"Container With Most Water"},{"location":"arrays/array-problems/#problem-statement_19","text":"You are given an integer array height of length \\(n\\) . There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and ( i , height[i] ). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_6","text":"Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.","title":"Example"},{"location":"arrays/array-problems/#approach_15","text":"[will be added soon]","title":"Approach"},{"location":"arrays/array-problems/#code_15","text":"class Solution { public : int maxArea ( vector < int >& height ) { int start = 0 ; int end = height . size () - 1 ; int water = 0 ; while ( start < end ) { int h = std :: min ( height [ start ], height [ end ]); water = std :: max ( h * ( end - start ), water ); while ( start < end and height [ start ] <= h ) start ++ ; while ( start < end and height [ end ] <= h ) end -- ; } return water ; } };","title":"Code"},{"location":"arrays/array-problems/#rain-water-trapping","text":"Same Problem on Leetcode \\(\\to\\)","title":"Rain water trapping"},{"location":"arrays/array-problems/#problem-statement_20","text":"Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_7","text":"Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.","title":"Example"},{"location":"arrays/array-problems/#explainer","text":"Rain Water Trapping Explainer","title":"Explainer"},{"location":"arrays/array-problems/#approach_16","text":"For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer","title":"Approach"},{"location":"arrays/array-problems/#solution","text":"For each building find the maximum height on both left and right sides, then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system.","title":"Solution"},{"location":"arrays/array-problems/#code_16","text":"class Solution { private : void _reverse ( vector < int > & v ) { int start = 0 ; int end = v . size () - 1 ; while ( start < end ) { int temp = v [ start ]; v [ start ] = v [ end ]; v [ end ] = temp ; start ++ ; end -- ; } } public : int trap ( vector < int >& height ) { // for each index find the maximum boundary to the left vector < int > left ; int currentMaxToLeft = 0 ; for ( auto i : height ) { if ( i > currentMaxToLeft ) { left . push_back ( currentMaxToLeft ); currentMaxToLeft = i ; } else { left . push_back ( currentMaxToLeft ); } } // for each index find the maximum boundary to the right vector < int > right ; int currentMaxToRight = 0 ; for ( int i = height . size () - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > currentMaxToRight ) { right . push_back ( currentMaxToRight ); currentMaxToRight = height [ i ]; } else { right . push_back ( currentMaxToRight ); } } _reverse ( right ); // reverse to sortout the order // based on the left max and right max we find the minimum among this two // (lower bound), then find the water on top of the building. int water = 0 ; for ( int i = 0 ; i < height . size () - 1 ; i ++ ) { // limiting height = min of left max and right max int limiter = std :: min ( left [ i ], right [ i ]); int waterOnTheBuilding = limiter - height [ i ]; if ( waterOnTheBuilding > 0 ) water += waterOnTheBuilding ; } return water ; } };","title":"Code"},{"location":"arrays/array-problems/#two-sum-iv","text":"","title":"Two Sum IV"},{"location":"arrays/array-problems/#problem-statement_21","text":"Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.","title":"Problem Statement"},{"location":"arrays/array-problems/#example_8","text":"Input: root = [5,3,6,2,4,null,7], k = 9 Output: true","title":"Example"},{"location":"arrays/array-problems/#approach_17","text":"We've previously solved the problem Two sum II where the input is sorted. Using 2 pointer approach we easily solved the problem, similar to that here if we do an inorder traversal we'll also get a sorted array, So the approach works like that, we first traverse in-order then use a 2 pointer approach to solve the 2 sum problem.","title":"Approach"},{"location":"arrays/array-problems/#code_17","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : vector < int > inOrder ; void build ( TreeNode * root ) { if ( root ) { build ( root -> left ); inOrder . push_back ( root -> val ); build ( root -> right ); } } public : bool findTarget ( TreeNode * root , int k ) { build ( root ); // now 2 Sum II on the sorted list inOrder int start = 0 ; int end = inOrder . size () - 1 ; int sum = inOrder [ start ] + inOrder [ end ]; while ( start < end ) { if ( sum < k ) { start ++ ; } else if ( sum > k ) { end -- ; } else if ( sum == k ) { return true ; } sum = inOrder [ start ] + inOrder [ end ]; } return false ; } };","title":"Code"},{"location":"arrays/arrays/","tags":["introduction","Python"],"text":"Arrays Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array. Example problem Problem Statement Problems Your input is an array of integers, and you have to reorder its entries so that the even entries appear first. Solution We can solve the problem with \\(O(N)\\) space trivially. But to solve the problem with constant space we have to reuse space inside the given array. Algorithm Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from \\(0 \\to (N-1)\\) to \\(0 \\to (N-2)\\) If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from \\(0 \\to(N-1)\\) to \\(1 \\to (N-1)\\) Repeat until pointers pointing start of the array crosses pointers pointing end of the array. Python Code [Python 3.9 and above] def even_odd_separation ( array : list [ int ]): start : int , end : int = 0 , len ( array ) - 1 # Don't stop until start crosses end while start < end : if array [ start ] % 2 == 0 : # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else : # Number infront of the array is odd array [ start ], array [ end ] = array [ end ], array [ start ] end -= 1 Time and space complexity The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . Note Test PASSED (1001/1001): (7 ms) Avarage running time: (22 us) Median running time: (7 us) Things to remember before solving Array Questions GENERIC RECOMMENDATIONS Array problems often have simple brute force solutions that use \\(O(n)\\) space, but there are subtler solutions that use the array itself to reduce space complexity to \\(O(1)\\) , Filling an array from the front is slow, so see if it's possible to write values from the back, with append() in python and push_back() in C++ method, Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case \\(O(N)\\) , beacuse all the elements to the right have to swapped one step left, PYTHON SPECIFIC RECOMMENDATIONS A.reverse() is inplace reversal of array, reversed(A) returns an iterator, del A[i] removes the i th element, A[::-1] reverses the array, Try using more of the list comprehension methods. One toy problem Note Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Examples Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Solution Approach Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element. Code def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Intro to Arrays"},{"location":"arrays/arrays/#arrays","text":"Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array.","title":"Arrays"},{"location":"arrays/arrays/#example-problem","text":"","title":"Example problem"},{"location":"arrays/arrays/#problem-statement","text":"Problems Your input is an array of integers, and you have to reorder its entries so that the even entries appear first.","title":"Problem Statement"},{"location":"arrays/arrays/#solution","text":"We can solve the problem with \\(O(N)\\) space trivially. But to solve the problem with constant space we have to reuse space inside the given array.","title":"Solution"},{"location":"arrays/arrays/#algorithm","text":"Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from \\(0 \\to (N-1)\\) to \\(0 \\to (N-2)\\) If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from \\(0 \\to(N-1)\\) to \\(1 \\to (N-1)\\) Repeat until pointers pointing start of the array crosses pointers pointing end of the array.","title":"Algorithm"},{"location":"arrays/arrays/#python-code-python-39-and-above","text":"def even_odd_separation ( array : list [ int ]): start : int , end : int = 0 , len ( array ) - 1 # Don't stop until start crosses end while start < end : if array [ start ] % 2 == 0 : # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else : # Number infront of the array is odd array [ start ], array [ end ] = array [ end ], array [ start ] end -= 1","title":"Python Code [Python 3.9 and above]"},{"location":"arrays/arrays/#time-and-space-complexity","text":"The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . Note Test PASSED (1001/1001): (7 ms) Avarage running time: (22 us) Median running time: (7 us)","title":"Time and space complexity"},{"location":"arrays/arrays/#things-to-remember-before-solving-array-questions","text":"GENERIC RECOMMENDATIONS Array problems often have simple brute force solutions that use \\(O(n)\\) space, but there are subtler solutions that use the array itself to reduce space complexity to \\(O(1)\\) , Filling an array from the front is slow, so see if it's possible to write values from the back, with append() in python and push_back() in C++ method, Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case \\(O(N)\\) , beacuse all the elements to the right have to swapped one step left, PYTHON SPECIFIC RECOMMENDATIONS A.reverse() is inplace reversal of array, reversed(A) returns an iterator, del A[i] removes the i th element, A[::-1] reverses the array, Try using more of the list comprehension methods.","title":"Things to remember before solving Array Questions"},{"location":"arrays/arrays/#one-toy-problem","text":"Note Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","title":"One toy problem"},{"location":"arrays/arrays/#examples","text":"Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.","title":"Examples"},{"location":"arrays/arrays/#solution_1","text":"","title":"Solution"},{"location":"arrays/arrays/#approach","text":"Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element.","title":"Approach"},{"location":"arrays/arrays/#code","text":"def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Code"},{"location":"arrays/sliding-window/","text":"Sliding Windows Problem Introduction Linked list or arrays find something among all contigious sub array of some given size. Example problem Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8] Brute force apprach A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8] Problems with this apporach Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs Optimized approach with while loop def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8] Maximum Sum subarray of size K Problem Statement Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 . Examples Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4]. Approach [Naive on back of the envelope approach] def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7 Time complexity Only one pass of the array so the time complexity is \\(O(N)\\) Smallest subarray with a given sum Problem statement Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists. Examples Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6]. Brute force approach Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3 Time complexity \\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\) Better Optimized approach First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ... Longest Substring with K Distinct Characters Problem statement Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Sliding window problems"},{"location":"arrays/sliding-window/#sliding-windows-problem-introduction","text":"Linked list or arrays find something among all contigious sub array of some given size.","title":"Sliding Windows Problem Introduction"},{"location":"arrays/sliding-window/#example-problem","text":"Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Example problem"},{"location":"arrays/sliding-window/#brute-force-apprach","text":"A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Brute force apprach"},{"location":"arrays/sliding-window/#problems-with-this-apporach","text":"Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs","title":"Problems with this apporach"},{"location":"arrays/sliding-window/#optimized-approach-with-while-loop","text":"def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Optimized approach with while loop"},{"location":"arrays/sliding-window/#maximum-sum-subarray-of-size-k","text":"","title":"Maximum Sum subarray of size K"},{"location":"arrays/sliding-window/#problem-statement","text":"Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 .","title":"Problem Statement"},{"location":"arrays/sliding-window/#examples","text":"Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4].","title":"Examples"},{"location":"arrays/sliding-window/#approach-naive-on-back-of-the-envelope-approach","text":"def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7","title":"Approach [Naive on back of the envelope approach]"},{"location":"arrays/sliding-window/#time-complexity","text":"Only one pass of the array so the time complexity is \\(O(N)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#smallest-subarray-with-a-given-sum","text":"","title":"Smallest subarray with a given sum"},{"location":"arrays/sliding-window/#problem-statement_1","text":"Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists.","title":"Problem statement"},{"location":"arrays/sliding-window/#examples_1","text":"Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6].","title":"Examples"},{"location":"arrays/sliding-window/#brute-force-approach","text":"Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3","title":"Brute force approach"},{"location":"arrays/sliding-window/#time-complexity_1","text":"\\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#better-optimized-approach","text":"First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ...","title":"Better Optimized approach"},{"location":"arrays/sliding-window/#longest-substring-with-k-distinct-characters","text":"","title":"Longest Substring with K Distinct Characters"},{"location":"arrays/sliding-window/#problem-statement_2","text":"Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Problem statement"},{"location":"binary-search/intro/","tags":["Medium","Binary Search","One day to complete"],"text":"Binary Search Introductions Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\) Toy problem to start: Find Ceil Problem Statement Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only. Example Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10 Approach This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. int ceil ( vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return v [ middle ]; } } // If the element is not found, then the while loop's start and end pointer crosses // each other and the start pointer points to the smallest element larger than the // target element. return v [ start ]; } def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start <= end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 9\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.25\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.7\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.1\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3.27\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3\\) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3 Find out the Nth Root of a given element. Problem Statement For a given N and a number K, find \\(\\sqrt[N]{K}\\) . Approach It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294) Median of Row Wise Sorted Matrix Problem Statement We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd. Example Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5 Constraints Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd. Apporach Naive Approach Iterate over all the elements, and then sort them, then return the middle element. Time Complexity for this naive apporach \\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) . Space Complexity \\(O(NM)\\) Extra space is required. More optimized apporach","title":"Basics and introduction"},{"location":"binary-search/intro/#binary-search-introductions","text":"Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\)","title":" Binary Search Introductions"},{"location":"binary-search/intro/#toy-problem-to-start-find-ceil","text":"","title":"Toy problem to start: Find Ceil"},{"location":"binary-search/intro/#problem-statement","text":"Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only.","title":"Problem Statement"},{"location":"binary-search/intro/#example","text":"Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10","title":"Example"},{"location":"binary-search/intro/#approach","text":"This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. int ceil ( vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return v [ middle ]; } } // If the element is not found, then the while loop's start and end pointer crosses // each other and the start pointer points to the smallest element larger than the // target element. return v [ start ]; } def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start <= end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 9\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.25\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.7\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.1\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3.27\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3\\) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3","title":"Approach"},{"location":"binary-search/intro/#find-out-the-nth-root-of-a-given-element","text":"","title":"Find out the Nth Root of a given element."},{"location":"binary-search/intro/#problem-statement_1","text":"For a given N and a number K, find \\(\\sqrt[N]{K}\\) .","title":"Problem Statement"},{"location":"binary-search/intro/#approach_1","text":"It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294)","title":"Approach"},{"location":"binary-search/intro/#median-of-row-wise-sorted-matrix","text":"","title":"Median of Row Wise Sorted Matrix"},{"location":"binary-search/intro/#problem-statement_2","text":"We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd.","title":"Problem Statement"},{"location":"binary-search/intro/#example_1","text":"Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5","title":"Example"},{"location":"binary-search/intro/#constraints","text":"Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd.","title":"Constraints"},{"location":"binary-search/intro/#apporach","text":"","title":"Apporach"},{"location":"binary-search/intro/#naive-approach","text":"Iterate over all the elements, and then sort them, then return the middle element.","title":"Naive Approach"},{"location":"binary-search/intro/#time-complexity-for-this-naive-apporach","text":"\\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) .","title":"Time Complexity for this naive apporach"},{"location":"binary-search/intro/#space-complexity","text":"\\(O(NM)\\) Extra space is required.","title":"Space Complexity"},{"location":"binary-search/intro/#more-optimized-apporach","text":"","title":"More optimized apporach"},{"location":"binary-search/problems/","text":"Binary Search problems Binary search problems are really useful because they run in sublinear time. We'll be solving the following problems in order to master this Questions discussed Binary Search implementation in C++ Binary Search on Reverse Sorted Array Order agnostic search First and Last occurrence of an Element Count of an Element in a Sorted Array Number of Times a Sorted array is Rotated Find an Element in a Rotated Sorted Array Search Insert Position Single Element in a Sorted Array Minimum Difference Element in a Sorted Array Search in a sorted 2D matrix Search in a sorted matrix but not inter-row-wise sorted Search for Range Koko Eating Bananas Time Based Key-Value Store Next alphabetical element Find position of an element in an Infinite Sorted Array Index of First 1 in a Binary Sorted Infinite Array Binary Search on Answer Concept Peak Element Find maximum element in Bitonic Array Search An Element in Bitonic Array Allocate minimum number of pages Binary Search implementation in C++ Binary search is really easy to implement. Main goal is to divide the search space into 2 partitions ( bi ) and then based on the criteria search only in one partition. Expected time complexity Expected time complexity is \\(O(\\log N)\\) where N is the number of elements in the array. Code implementation // Return the index of the element in the array // using binary search int binary_search ( std :: vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = ( end + start ) / 2 ; int index = -1 ; // return -1 if not found while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return middle ; } middle = ( end + start ) / 2 ; } return index ; } Binary Search on Reverse Sorted Array We've seen the binary search algorithm for a sorted array, but if the array is reverse sorted then we can easily modify the binary search algorithm here else if (v[middle] > target) { start = middle + 1; } because the target element is lower and the array is reverse sorted so the required element should be at the end partition of the array. So a little modification of the binary search algorithm is sufficient to solve the problem. Order agnostic search If the array is sorted but we don't know the order of the elements whether it is ascending or descending? Then what we can do is the following Approach See if the array size is 1 or not then we return. If the array size is more than 1, then find if \\(\\text{A[0]} > \\text{A[1]}\\) or not? If it is then the array is reverse sorted. If that is not the case then the array is sorted in ascending order. We run the previous or previous to previous algorithm accordingly. First and Last occurrence of an Element In a sorted array if we have more than one element we may want to know what is the first occurrence of some element (assuming they exists). Approach We can use linear search but there is no fun in that. Instead we use a binary search, but how we'll do this? Let's employ a binary search subroutine, now this will find any occurrence of the target element, Now if this is not the first occurrence of the target element we will need to search the left subsection of the array, and in case we didn't find any we record this occurence as the first occurrence of the target element so far, Now we search for the target element again in the left subsection of the array by modifying end = middle - 1 Code int firstOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int first = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search first = middle ; end = middle - 1 ; } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return first ; } For finding the last occurence Similarly we can find the last occurence of an element in the sorted array by modifying the previous problem slightly, by first finding the element with binary search, then instead of finding the element in the left side [for first occurence] we search the right sub array for the last occurence of the element. int lastOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int last = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search last = middle ; start = middle + 1 ; // look in the right subarray for the last occurrence } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return last ; } Count of an Element in a Sorted Array Similar problem on Leetcode \\(\\to\\) This is a very simple problem, we can find the first occurrence of an element [index] and last occurence of an element and subtract. This will return the number of times the element was found in the array. Expected Time complexity \\(O(\\text{lg} N)\\) for finding the first occurrence and \\(O(\\text{lg} N)\\) for finding the last occurrence. Total of \\(O(\\text{lg} N)\\) . Number of Times a Sorted array is Rotated Problem Statement An asending sorted array \\(A[0 \\to N]\\) once rotated becomes \\(A[1 \\to N] + A[0]\\) . When it twice rotated becomes \\(A[2 \\to N] + A[0 \\to 1]\\) . When the array is rotated \\(k\\) times, the array becomes \\(A[K \\to N] + A[0 \\to K - 1]\\) Brute Force Approach Using a linear search if we find for some \\(i\\) \\(A[i] > A[i+1]\\) , that \\(i\\) is the index of the rotation starting point. Subtract \\(i\\) from length of the array to find how much rotation took place. One more thing we can observe is that the \\((\\text{size - index of the minimum element})\\) is the # of rotations done on the sorted array. Both of these solution is \\(O(N)\\) so not efficient enough. More optimized approach We cannot afford to search for the minimum element in the entire array, this will cost \\(O(N)\\) time. However if we reduce the size of the search space we can reduce the time complexity of the algorithm. This apporach works like this: First check the middle \\(i\\) , if the value is smaller than both the element to its side \\(i - 1\\) and \\(i + 1\\) , then it is the point of the minimum element means this is the point of rotation. If this is not true then based on some idea we should reduce the size of the search space, otherwise its gonna be \\(O(N)\\) We do this very ingenious way, first we check if the middle element is smaller than the first element or not? If this is the case then the minimum element is present in the left side of the middle element. Else the element should be present in the right side of the middle element. Code class Solution { public : int findMin ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; int size = nums . size (); int middle = start + ( end - start ) / 2 ; while ( start < end ){ if ( nums [ middle ] > nums [ end ]) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return size - start + 1 ; } }; Find an Element in a Rotated Sorted Array Problem on Leetcode \\(\\to\\) Approach If we look at the previous problem, we'll see that the (rotation point): let's call that the pivot, the subarray before pivot is sorted and subarray after pivot is sorted as well. If we run 2 binary search on each of the subarrays we'll find the target element in \\(O(\\text{lg} N)\\) time. Code class Solution { private : int findRotationPoint ( vector < int > & nums ) { int start = 0 ; int end = nums . size () - 1 ; // base cases: if ( nums . size () <= 1 ) return 0 ; // zero or one element array do not have rotations if ( nums [ start ] < nums [ end ]) return 0 ; // no rotation at all int middle = start + ( end - start ) / 2 ; while ( start < end ) { if ( nums [ middle ] > nums [ end ]) { // means rotation point is right of mid start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } int binary_search ( vector < int > & nums , int start , int end , int target ) { int mid = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ mid ] == target ) return mid ; if ( nums [ mid ] < target ) start = mid + 1 ; if ( nums [ mid ] > target ) end = mid - 1 ; mid = start + ( end - start ) / 2 ; } return -1 ; } public : int search ( vector < int >& nums , int target ) { if ( nums . size () == 1 ) { if ( nums [ 0 ] == target ) return 0 ; else return -1 ; } int rotationPoint = findRotationPoint ( nums ); // the array is sorted from 0 -> rotationPoint - 1 // and rotationPoint -> nums.size() - 1 int left = binary_search ( nums , 0 , rotationPoint - 1 , target ); int right = binary_search ( nums , rotationPoint , nums . size () - 1 , target ); return std :: max ( left , right ); } }; Time Complexity To find the rotation point we make \\(O(\\lg N)\\) comparisons and to do binary searchs on both the left and right takes \\(O(\\lg N)\\) time. So total time complexity is \\(O(\\lg N)\\) . Search Insert Position Problem on Leetcode \\(\\to\\) Warning Finding Floor and Ceil of an element in a Sorted Array This is a very important idea we need to understand before you attempt this question. We need to run the binary search algorithm and see where the start and end stops after the execution. Do it yourself, and put it in the comments below. Do a dry run on the binary search algorithm and see what are the start and end points to after the execution finishes. I'll add a video for this later . Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run with \\(O(\\lg n)\\) complexity. Approach We can employ the normal binary search algorithm, and instead of returning -1 if we don't find the target number, we'll carefully look what all the pointers are pointing towards at the end of the binary search algorithm. If we look carefully we'll find that at the end of the binary search if there is no element present in the array, the pointer \\(\\text{start}\\) and \\(\\text{end} - 1\\) points to the insertion point for that element. Careful Dry run with an example Code class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] > target ) { end = middle - 1 ; } else if ( nums [ middle ] < target ) { start = middle + 1 ; } middle = start + ( end - start ) / 2 ; } // send back start or end - 1 instead of -1. return start ; } }; Single Element in a Sorted Array Problem on Leetcode \\(\\to\\) Problem Statement You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in \\(O(\\lg n)\\) time and \\(O(1)\\) space. Approach As the solution is required to be run in \\(O(1)\\) space and \\(O(\\lg n)\\) time it means we have to use binary search. Now we run the default binary search algorithm with some modification. We go to the middle element, now question arises based on what should we divide the array and only solve on one of those two part? If you look closely at the array, you will notice that for each pair in the left side of the odd one out <int, int> the index is like this <even, odd> and for each pairs in the right side of the odd one out the index is like this <odd, even> . We identify how the indexes are aranged and we jump to solve a smaller subproblem. Code class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { // if the size is 1 then it is the odd one out if ( nums . size () == 1 ) return nums [ 0 ]; // boundary cases: if ( nums [ 0 ] != nums [ 1 ]) return nums [ 0 ]; if ( nums [ nums . size () - 1 ] != nums [ nums . size () - 2 ]) return nums [ nums . size () - 1 ]; int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { int atMid = nums [ middle ]; if ( atMid != nums [ middle - 1 ] and atMid != nums [ middle + 1 ]) { // case where the middle element is the odd one out return atMid ; } // check if the odd one out is the left or right sub part // case 1: // [1, 1, ..., 2, 2, ...] // | middle if ( nums [ middle ] == nums [ middle + 1 ]) { // now check if middle is even and middle + 1 is odd? // if this is true then odd one out is in the right subarray if ( middle % 2 == 0 ) { start = middle + 1 ; } else { end = middle - 1 ; } } // case 2: // [1, 1, ..., 2, 2, ...] // | middle if ( nums [ middle ] == nums [ middle - 1 ]) { // now check if middle is odd and middle - 1 is even? if ( middle % 2 != 0 ) { start = middle + 1 ; } else { end = middle - 1 ; } } middle = start + ( end - start ) / 2 ; } return -1 ; } }; Minimum Difference Element in a Sorted Array Problem Statement Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given \u2018key\u2019. Examples Input: [4, 6, 10], key = 7 Output: 6 Explanation: The difference between the key '7' and '6' is minimum than any other number in the array. Input: [4, 6, 10], key = 4 Output: 4 Input: [1, 3, 8, 10, 15], key = 12 Output: 10 Input: [4, 6, 10], key = 17 Output: 10 Approach If the element is present in the array, we should return it. If not present, then We should check the ceil and floor of the element from the array. Floor is the end pointer when the binary search is finished and ceil would be end + 1 pointer because the array is sorted. Next we should check what is lower difference between floor and target or ceil or target, which ever is lower that is closer to target. C++ Code Solution int minDiffElement ( vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( v [ middle ] == target ) return target ; if ( v [ middle ] < target ) start = middle + 1 ; if ( v [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } // lowerbound = at index end int diFFWithLowerBound = std :: abs ( target - v [ end ]); int diFFWithUpperBound = std :: abs ( v [ end + 1 ] - target ); if ( diFFWithLowerBound > diFFWithUpperBound ) return v [ end + 1 ]; if ( diFFWithLowerBound < diFFWithUpperBound ) return v [ end ]; return -1 ; // both are same distant } Time and space complexity No extra space is required, so \\(O(1)\\) space and total of \\(O(\\lg n)\\) time is required for binary search. Search in a sorted 2D matrix Similar Problem on Leetcode \\(\\to\\) Problem Statement Write an efficient algorithm that searches for a value target in an \\(M \\times N\\) integer matrix matrix . This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Also can be termed as inter-row-wise sorted . Example Matrix : \\(M_A = \\begin{bmatrix} 1 & 3 & 5 & 7 \\\\ 10 & 11 & 16 & 20 \\\\ 23 & 30 & 34 & 60 \\end{bmatrix}\\) Input = MA and target = 3 Output: true Approach First you start a probe for the row in which the data may be present, then search column wise. Total time taken in this approach is \\(O(\\log_2 \\text{Rows}) + O(\\log_2 \\text{Columns})\\) . Check out the following code to see how the edge cases are handled. Code class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { // base cases int rows = matrix . size (); int cols = matrix [ 0 ]. size (); // only one element in the matrix if ( rows == 1 and cols == 1 ) return matrix [ 0 ][ 0 ] == target ; // matrix data out of bounds if ( target < matrix [ 0 ][ 0 ] or target > matrix [ rows -1 ][ cols -1 ]) return false ; // start a row probe to find in which row the data may be there? int start = 0 ; int end = matrix . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ middle ][ 0 ] == target ) return true ; if ( matrix [ middle ][ 0 ] > target ) end = middle - 1 ; if ( matrix [ middle ][ 0 ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } // start is the lower bound on the row ID int rowID = end ; cout << rowID << endl ; // now we should start a column probe start = 0 ; end = matrix [ 0 ]. size () - 1 ; middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ rowID ][ middle ] == target ) return true ; if ( matrix [ rowID ][ middle ] > target ) end = middle - 1 ; if ( matrix [ rowID ][ middle ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } return false ; } }; Search in a sorted matrix but not inter-row-wise sorted Find the problem on Leetcode \\(\\to\\) Problem Statement The problem statement is almost identical similar but the rule first integer of each row is greater than the last integer of the previous row does NOT apply here. Example Matrix : \\(M_B = \\begin{bmatrix} 1 & 3 & 5 & 7 \\\\ 2 & 4 & 64 & 20 \\\\ 3 & 5 & 134 & 60 \\end{bmatrix}\\) Input = MB and target = 3 Output: true Approaches We can do a row wise binary search to find the element, that'll take \\(O(\\text{|rows|} \\lg \\text{|cols|})\\) time to complete. Otherwise we can also implement a linear time algorithm to find the element. This will be much faster than the log approach. Here we'll do the followings, first we'll start from the first row and last column of the matrix then if we find the element is \\(\\geq\\) than the target means it'll be available only at a lower row than the current row. Here target is 16 and 15 is at the first row and last column of the matrix. So we should go down by one row. At the second row we see 19 that is greater than the target \\(16\\) so we should go left by one column because \\(16\\) can not be present below \\(19\\) in the last column. This is how we find the element. Code CODE WITH BINARY SEARCH class Solution { private : bool rowWiseSearch ( vector < vector < int >>& matrix , int row , int target ) { int start = 0 ; int end = matrix [ row ]. size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ row ][ middle ] == target ) return true ; if ( matrix [ row ][ middle ] > target ) end = middle - 1 ; if ( matrix [ row ][ middle ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } return false ; } public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int rows = matrix . size (); for ( int i = 0 ; i < rows ; i ++ ) { bool found = rowWiseSearch ( matrix , i , target ); if ( found == true ) return true ; } return false ; } }; CODE WITH MATRIX-LINEAR SEARCH class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { // base case: 1x1 matrix if ( matrix . size () == 1 ) { if ( matrix [ 0 ]. size () == 1 ) return matrix [ 0 ][ 0 ] == target ; } // base case: numbers out of bounds if ( target < matrix [ 0 ][ 0 ] or target > matrix [ matrix . size () - 1 ][ matrix [ 0 ]. size () - 1 ]) { return false ; } int rows = matrix . size (); int cols = matrix [ 0 ]. size (); int i = rows - 1 ; int j = 0 ; while ( i >= 0 and j < cols ) { if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) { j ++ ; } else { i -- ; } } return false ; } }; Time Complexity The matrix linear search takes \\(O(\\text{|rows|} + \\text{|cols|})\\) time because at worst case we'll reach to last row and first column of the matrix. Search for Range Problem on Leetcode \\(\\to\\) Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return \\([-1, -1]\\) . We must write an algorithm with \\(O(\\log_2 n)\\) runtime complexity. Example Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1] Approach Two things we need to find here, these are the first occurrence of some repeating elements and last occurrence of some repeating elements. Before we do anything we should first search in \\(O(\\lg n)\\) whether the array contains the element or not, if not return \\([-1,-1]\\) . Otherwise the program could become complicated while searching for first occurrence and last occurrence also search if it's there or not. Better to separate the logic. So we should write 3 subroutines: firstOccurrence() and lastOccurrence() and a routine for binary_search() . We'll return \\([-1, -1]\\) if binary_search() returns false. To calculate the firstOccurrence() we modify the binary search subroutine itself. When we find the middle element greater than or equal to the target then instead of setting \\(\\text{end} = \\text{middle} - 1\\) we'll include the end as middle (set \\(\\text{end} = \\text{middle}\\) ). To calculate the lastOccurence() we'll write the exact same code as firstOccurence() (using symmetry). However there is a problem with the code. The program for lastOccurence() will not halt and loop forever in the following scenario: while ( start < end ) { ... } else { start = middle ; } ... } the code will fall into infinite loop when the arrangement becomes this We'll manually update the lastOccurrence in this case. Code class Solution { public : int firstOccurrence ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; // [1,2,3,4,4,4,7]; target = 4; // | | | // start. mid. end. // next step: [1,2,3,4] // | | // mid end // next step: [3,4] // | | // s,m end // next step: [4] // | start, end, middle while ( start < end ) { if ( nums [ middle ] < target ) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } int lastOccurrence ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start < end ) { // there is a condition when it loops forever // end = start + 1; // [k , j] // | | // m,s end // check for this if ( start == end - 1 ) { // check for a case where [2,2] and target is 2 if ( nums [ start ] == nums [ end ]) { return end ; } // manually escape this situation // there can be case [5, 7] and t=5 where it loops forever because start = middle if ( nums [ start ] == target ) { return start ; } else if ( nums [ end ] == target ){ // case for [2,3] and t=3 return end ; } } if ( nums [ middle ] > target ) { end = middle - 1 ; } else { start = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } bool binary_search ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ middle ] == target ) { return true ; } if ( nums [ middle ] < target ) start = middle + 1 ; if ( nums [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } return false ; } vector < int > searchRange ( vector < int >& nums , int target ) { if ( not binary_search ( nums , target )) { vector < int > answer = { -1 , -1 }; return answer ; } vector < int > answer ; int firstocc = firstOccurrence ( nums , target ); int lastocc = lastOccurrence ( nums , target ); answer . push_back ( firstocc ); answer . push_back ( lastocc ); return answer ; } }; Koko Eating Bananas Find the problem on Leetcode \\(\\to\\) Problem Statement Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. Examples Input: piles = [3,6,7,11], h = 8 Output: 4 Input: piles = [30,11,23,4,20], h = 5 Output: 30 Input: piles = [30,11,23,4,20], h = 6 Output: 23 Code class Solution { private : pair < bool , int > finishableCheck ( vector < int > & piles , int k , int h ) { // check finishability with k bananas per hour // and given h hours to play time // retruns finishable or not and finish time int eatableTime = 0 ; for ( auto l : piles ) { eatableTime += l / k + ( l % k == 0 ? 0 : 1 ); } pair < bool , int > p ; p . second = eatableTime ; if ( eatableTime > h ) { p . first = false ; return p ; } p . first = true ; return p ; } public : int minEatingSpeed ( vector < int >& piles , int h ) { if ( piles . size () == 1 ) { return ceil (( double ) piles [ 0 ] / ( double ) h ); } // [piles of banana] // [213 45 5 6 7 7 8] // total available time is h hours // banana eating speed = k // lowest possible value for k is 1 // eat at least min(piles[i]) banana per hour. int lo = 1 ; // and highest possible banana per hour // should be = piles[i] for i piles[i] is maximum int hi = piles [ 0 ]; for ( int i : piles ) { if ( i > hi ) hi = i ; } int middle = lo + ( hi - lo ) / 2 ; while ( lo < hi ) { // now check for middle if this satisfies the // eating banana pile every hour // and finishing before guards comes back cout << \"From \" << lo << \" to \" << hi << \": \" ; pair < bool , int > p = finishableCheck ( piles , middle , h ); if ( p . first == true ) hi = middle ; if ( p . first == false and p . second > h ) { lo = middle + 1 ; } cout << \" middle: \" << middle << \" p.first = \" << p . first << \" p.second = \" << p . second << endl ; middle = lo + ( hi - lo ) / 2 ; } return hi ; } }; Time Based Key-Value Store Find the problem on Leetcode \\(\\to\\) Problem Statement Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Task is to implement the TimeMap class, TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp . If there are multiple such values, it returns the value associated with the largest timestamp_prev . If there are no values, it returns \"\" . Example Input [\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"] [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]] Output [null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"] Explaination Explanation TimeMap timeMap = new TimeMap(); timeMap.set(\"foo\", \"bar\", 1); // store the key \"foo\" and value \"bar\" along with timestamp = 1. timeMap.get(\"foo\", 1); // return \"bar\" timeMap.get(\"foo\", 3); // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\". timeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4. timeMap.get(\"foo\", 4); // return \"bar2\" timeMap.get(\"foo\", 5); // return \"bar2\" Approach #1 We'll use a time-based map implementation. For each timestamp we'll record all the {key, value} pairs coming in. And return when asked. If the timestamp is not found then we'll see what is the last timestamp for which this key was recorded, we'll return that. To find the last timestamp for which this key was recorded we need to do a linear decrement of the timestamp and check if the key is present or not for every time stamps. Else we can change the design of the map and get a better upper bound on the time complexity. As the times are always in sorted order (time is always increasing), we maybe able to use binary search. For this particular design following is the code. Hashtable design timestamp unordered_map<Key, Value> 1 <\"outlaw\", \"1673\"> 4 <\"outlaw\", 33> Code for Approach #1 class TimeMap { private : unordered_map < int , unordered_map < string , string >> mp ; public : TimeMap () {} void set ( string key , string value , int timestamp ) { mp [ timestamp ][ key ] = value ; } string get ( string key , int timestamp ) { // if there is no timestamp for key \"key\" if ( mp . find ( timestamp ) == mp . end ()) { while ( timestamp ){ // go in reverse order of timestamp to find the key if exists before or not? // return the last if ( mp [ timestamp ]. find ( key ) != mp [ timestamp ]. end ()) { return mp [ timestamp ][ key ]; } timestamp -- ; } } return mp [ timestamp ][ key ]; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj->set(key,value,timestamp); * string param_2 = obj->get(key,timestamp); */ Approach #2 The previous design was a bit easier to understand but had a flaw that if we don't find element in the map for some timestamp then we'd have to linearly decrease the timestamps and check for the key, else we'll use a better design. For each key we'll, maintain a vector<pair<string, int>> value & time pair. Then if there exists any key and don't exists the asked timestamp we can give back the binary search lower bound from the array. Hashtable new design Key pair<Value, TimeStamp> outlaw <\"1673\", 1>, <\"33\", 4> -- -- Now with this design of the system we can do a simple binary search on the lower bound of the timestamp in \\(O(\\lg N)\\) time. Code for Approach #2 class TimeMap { private : // hashtable design // unordered_map<key, vector<pair<value, timestamp>>> unordered_map < string , vector < pair < string , int >>> map ; public : TimeMap () {} void set ( string key , string value , int timestamp ) { if ( map . find ( key ) == map . end ()) { // there doesn't exists a key, first time the key has come up // so add this vector < pair < string , int >> v = {{ value , timestamp }}; map . insert ({ key , v }); } else { // means key is inserted at a before timestamp than now // this becomes naturally sorted with the timestamps map [ key ]. push_back ({ value , timestamp }); } } string get ( string key , int timestamp ) { // we assume key is already present before making a query // we also have a time stamp // so we'll do a binary search on the timestamp to get the result at the given time stamp // else we'll return the lower bound on the timestamp int start = 0 ; int end = map [ key ]. size () - 1 ; // basecase // query is at the timestamp far before first key to be registered int middle = start + ( end - start ) / 2 ; // O(lg n) compare while ( start <= end ) { if ( map [ key ][ middle ]. second == timestamp ) return map [ key ][ middle ]. first ; if ( map [ key ][ middle ]. second > timestamp ) end = middle - 1 ; if ( map [ key ][ middle ]. second < timestamp ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } if ( end == - 1 ) return \"\" ; return map [ key ][ end ]. first ; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj->set(key,value,timestamp); * string param_2 = obj->get(key,timestamp); */ Next alphabetical element Find position of an element in an Infinite Sorted Array Index of First 1 in a Binary Sorted Infinite Array Binary Search on Answer Concept Peak Element Find maximum element in Bitonic Array Search An Element in Bitonic Array Allocate minimum number of pages","title":"Binary search problems"},{"location":"binary-search/problems/#binary-search-problems","text":"Binary search problems are really useful because they run in sublinear time. We'll be solving the following problems in order to master this Questions discussed Binary Search implementation in C++ Binary Search on Reverse Sorted Array Order agnostic search First and Last occurrence of an Element Count of an Element in a Sorted Array Number of Times a Sorted array is Rotated Find an Element in a Rotated Sorted Array Search Insert Position Single Element in a Sorted Array Minimum Difference Element in a Sorted Array Search in a sorted 2D matrix Search in a sorted matrix but not inter-row-wise sorted Search for Range Koko Eating Bananas Time Based Key-Value Store Next alphabetical element Find position of an element in an Infinite Sorted Array Index of First 1 in a Binary Sorted Infinite Array Binary Search on Answer Concept Peak Element Find maximum element in Bitonic Array Search An Element in Bitonic Array Allocate minimum number of pages","title":" Binary Search problems"},{"location":"binary-search/problems/#binary-search-implementation-in-c","text":"Binary search is really easy to implement. Main goal is to divide the search space into 2 partitions ( bi ) and then based on the criteria search only in one partition.","title":"Binary Search implementation in C++"},{"location":"binary-search/problems/#expected-time-complexity","text":"Expected time complexity is \\(O(\\log N)\\) where N is the number of elements in the array.","title":"Expected time complexity"},{"location":"binary-search/problems/#code-implementation","text":"// Return the index of the element in the array // using binary search int binary_search ( std :: vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = ( end + start ) / 2 ; int index = -1 ; // return -1 if not found while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return middle ; } middle = ( end + start ) / 2 ; } return index ; }","title":"Code implementation"},{"location":"binary-search/problems/#binary-search-on-reverse-sorted-array","text":"We've seen the binary search algorithm for a sorted array, but if the array is reverse sorted then we can easily modify the binary search algorithm here else if (v[middle] > target) { start = middle + 1; } because the target element is lower and the array is reverse sorted so the required element should be at the end partition of the array. So a little modification of the binary search algorithm is sufficient to solve the problem.","title":"Binary Search on Reverse Sorted Array"},{"location":"binary-search/problems/#order-agnostic-search","text":"If the array is sorted but we don't know the order of the elements whether it is ascending or descending? Then what we can do is the following","title":"Order agnostic search"},{"location":"binary-search/problems/#approach","text":"See if the array size is 1 or not then we return. If the array size is more than 1, then find if \\(\\text{A[0]} > \\text{A[1]}\\) or not? If it is then the array is reverse sorted. If that is not the case then the array is sorted in ascending order. We run the previous or previous to previous algorithm accordingly.","title":"Approach"},{"location":"binary-search/problems/#first-and-last-occurrence-of-an-element","text":"In a sorted array if we have more than one element we may want to know what is the first occurrence of some element (assuming they exists).","title":"First and Last occurrence of an Element"},{"location":"binary-search/problems/#approach_1","text":"We can use linear search but there is no fun in that. Instead we use a binary search, but how we'll do this? Let's employ a binary search subroutine, now this will find any occurrence of the target element, Now if this is not the first occurrence of the target element we will need to search the left subsection of the array, and in case we didn't find any we record this occurence as the first occurrence of the target element so far, Now we search for the target element again in the left subsection of the array by modifying end = middle - 1","title":"Approach"},{"location":"binary-search/problems/#code","text":"int firstOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int first = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search first = middle ; end = middle - 1 ; } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return first ; } For finding the last occurence Similarly we can find the last occurence of an element in the sorted array by modifying the previous problem slightly, by first finding the element with binary search, then instead of finding the element in the left side [for first occurence] we search the right sub array for the last occurence of the element. int lastOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int last = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search last = middle ; start = middle + 1 ; // look in the right subarray for the last occurrence } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return last ; }","title":"Code"},{"location":"binary-search/problems/#count-of-an-element-in-a-sorted-array","text":"Similar problem on Leetcode \\(\\to\\) This is a very simple problem, we can find the first occurrence of an element [index] and last occurence of an element and subtract. This will return the number of times the element was found in the array.","title":"Count of an Element in a Sorted Array"},{"location":"binary-search/problems/#expected-time-complexity_1","text":"\\(O(\\text{lg} N)\\) for finding the first occurrence and \\(O(\\text{lg} N)\\) for finding the last occurrence. Total of \\(O(\\text{lg} N)\\) .","title":"Expected Time complexity"},{"location":"binary-search/problems/#number-of-times-a-sorted-array-is-rotated","text":"","title":"Number of Times a Sorted array is Rotated"},{"location":"binary-search/problems/#problem-statement","text":"An asending sorted array \\(A[0 \\to N]\\) once rotated becomes \\(A[1 \\to N] + A[0]\\) . When it twice rotated becomes \\(A[2 \\to N] + A[0 \\to 1]\\) . When the array is rotated \\(k\\) times, the array becomes \\(A[K \\to N] + A[0 \\to K - 1]\\)","title":"Problem Statement"},{"location":"binary-search/problems/#brute-force-approach","text":"Using a linear search if we find for some \\(i\\) \\(A[i] > A[i+1]\\) , that \\(i\\) is the index of the rotation starting point. Subtract \\(i\\) from length of the array to find how much rotation took place. One more thing we can observe is that the \\((\\text{size - index of the minimum element})\\) is the # of rotations done on the sorted array. Both of these solution is \\(O(N)\\) so not efficient enough.","title":"Brute Force Approach"},{"location":"binary-search/problems/#more-optimized-approach","text":"We cannot afford to search for the minimum element in the entire array, this will cost \\(O(N)\\) time. However if we reduce the size of the search space we can reduce the time complexity of the algorithm. This apporach works like this: First check the middle \\(i\\) , if the value is smaller than both the element to its side \\(i - 1\\) and \\(i + 1\\) , then it is the point of the minimum element means this is the point of rotation. If this is not true then based on some idea we should reduce the size of the search space, otherwise its gonna be \\(O(N)\\) We do this very ingenious way, first we check if the middle element is smaller than the first element or not? If this is the case then the minimum element is present in the left side of the middle element. Else the element should be present in the right side of the middle element.","title":"More optimized approach"},{"location":"binary-search/problems/#code_1","text":"class Solution { public : int findMin ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; int size = nums . size (); int middle = start + ( end - start ) / 2 ; while ( start < end ){ if ( nums [ middle ] > nums [ end ]) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return size - start + 1 ; } };","title":"Code"},{"location":"binary-search/problems/#find-an-element-in-a-rotated-sorted-array","text":"Problem on Leetcode \\(\\to\\)","title":"Find an Element in a Rotated Sorted Array"},{"location":"binary-search/problems/#approach_2","text":"If we look at the previous problem, we'll see that the (rotation point): let's call that the pivot, the subarray before pivot is sorted and subarray after pivot is sorted as well. If we run 2 binary search on each of the subarrays we'll find the target element in \\(O(\\text{lg} N)\\) time.","title":"Approach"},{"location":"binary-search/problems/#code_2","text":"class Solution { private : int findRotationPoint ( vector < int > & nums ) { int start = 0 ; int end = nums . size () - 1 ; // base cases: if ( nums . size () <= 1 ) return 0 ; // zero or one element array do not have rotations if ( nums [ start ] < nums [ end ]) return 0 ; // no rotation at all int middle = start + ( end - start ) / 2 ; while ( start < end ) { if ( nums [ middle ] > nums [ end ]) { // means rotation point is right of mid start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } int binary_search ( vector < int > & nums , int start , int end , int target ) { int mid = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ mid ] == target ) return mid ; if ( nums [ mid ] < target ) start = mid + 1 ; if ( nums [ mid ] > target ) end = mid - 1 ; mid = start + ( end - start ) / 2 ; } return -1 ; } public : int search ( vector < int >& nums , int target ) { if ( nums . size () == 1 ) { if ( nums [ 0 ] == target ) return 0 ; else return -1 ; } int rotationPoint = findRotationPoint ( nums ); // the array is sorted from 0 -> rotationPoint - 1 // and rotationPoint -> nums.size() - 1 int left = binary_search ( nums , 0 , rotationPoint - 1 , target ); int right = binary_search ( nums , rotationPoint , nums . size () - 1 , target ); return std :: max ( left , right ); } };","title":"Code"},{"location":"binary-search/problems/#time-complexity","text":"To find the rotation point we make \\(O(\\lg N)\\) comparisons and to do binary searchs on both the left and right takes \\(O(\\lg N)\\) time. So total time complexity is \\(O(\\lg N)\\) .","title":"Time Complexity"},{"location":"binary-search/problems/#search-insert-position","text":"Problem on Leetcode \\(\\to\\) Warning","title":"Search Insert Position"},{"location":"binary-search/problems/#finding-floor-and-ceil-of-an-element-in-a-sorted-array","text":"This is a very important idea we need to understand before you attempt this question. We need to run the binary search algorithm and see where the start and end stops after the execution. Do it yourself, and put it in the comments below. Do a dry run on the binary search algorithm and see what are the start and end points to after the execution finishes. I'll add a video for this later . Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run with \\(O(\\lg n)\\) complexity.","title":"Finding Floor and Ceil of an element in a Sorted Array"},{"location":"binary-search/problems/#approach_3","text":"We can employ the normal binary search algorithm, and instead of returning -1 if we don't find the target number, we'll carefully look what all the pointers are pointing towards at the end of the binary search algorithm. If we look carefully we'll find that at the end of the binary search if there is no element present in the array, the pointer \\(\\text{start}\\) and \\(\\text{end} - 1\\) points to the insertion point for that element.","title":"Approach"},{"location":"binary-search/problems/#careful-dry-run-with-an-example","text":"","title":"Careful Dry run with an example"},{"location":"binary-search/problems/#code_3","text":"class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] > target ) { end = middle - 1 ; } else if ( nums [ middle ] < target ) { start = middle + 1 ; } middle = start + ( end - start ) / 2 ; } // send back start or end - 1 instead of -1. return start ; } };","title":"Code"},{"location":"binary-search/problems/#single-element-in-a-sorted-array","text":"Problem on Leetcode \\(\\to\\)","title":"Single Element in a Sorted Array"},{"location":"binary-search/problems/#problem-statement_1","text":"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in \\(O(\\lg n)\\) time and \\(O(1)\\) space.","title":"Problem Statement"},{"location":"binary-search/problems/#approach_4","text":"As the solution is required to be run in \\(O(1)\\) space and \\(O(\\lg n)\\) time it means we have to use binary search. Now we run the default binary search algorithm with some modification. We go to the middle element, now question arises based on what should we divide the array and only solve on one of those two part? If you look closely at the array, you will notice that for each pair in the left side of the odd one out <int, int> the index is like this <even, odd> and for each pairs in the right side of the odd one out the index is like this <odd, even> . We identify how the indexes are aranged and we jump to solve a smaller subproblem.","title":"Approach"},{"location":"binary-search/problems/#code_4","text":"class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { // if the size is 1 then it is the odd one out if ( nums . size () == 1 ) return nums [ 0 ]; // boundary cases: if ( nums [ 0 ] != nums [ 1 ]) return nums [ 0 ]; if ( nums [ nums . size () - 1 ] != nums [ nums . size () - 2 ]) return nums [ nums . size () - 1 ]; int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { int atMid = nums [ middle ]; if ( atMid != nums [ middle - 1 ] and atMid != nums [ middle + 1 ]) { // case where the middle element is the odd one out return atMid ; } // check if the odd one out is the left or right sub part // case 1: // [1, 1, ..., 2, 2, ...] // | middle if ( nums [ middle ] == nums [ middle + 1 ]) { // now check if middle is even and middle + 1 is odd? // if this is true then odd one out is in the right subarray if ( middle % 2 == 0 ) { start = middle + 1 ; } else { end = middle - 1 ; } } // case 2: // [1, 1, ..., 2, 2, ...] // | middle if ( nums [ middle ] == nums [ middle - 1 ]) { // now check if middle is odd and middle - 1 is even? if ( middle % 2 != 0 ) { start = middle + 1 ; } else { end = middle - 1 ; } } middle = start + ( end - start ) / 2 ; } return -1 ; } };","title":"Code"},{"location":"binary-search/problems/#minimum-difference-element-in-a-sorted-array","text":"","title":"Minimum Difference Element in a Sorted Array"},{"location":"binary-search/problems/#problem-statement_2","text":"Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given \u2018key\u2019.","title":"Problem Statement"},{"location":"binary-search/problems/#examples","text":"Input: [4, 6, 10], key = 7 Output: 6 Explanation: The difference between the key '7' and '6' is minimum than any other number in the array. Input: [4, 6, 10], key = 4 Output: 4 Input: [1, 3, 8, 10, 15], key = 12 Output: 10 Input: [4, 6, 10], key = 17 Output: 10","title":"Examples"},{"location":"binary-search/problems/#approach_5","text":"If the element is present in the array, we should return it. If not present, then We should check the ceil and floor of the element from the array. Floor is the end pointer when the binary search is finished and ceil would be end + 1 pointer because the array is sorted. Next we should check what is lower difference between floor and target or ceil or target, which ever is lower that is closer to target.","title":"Approach"},{"location":"binary-search/problems/#c-code-solution","text":"int minDiffElement ( vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( v [ middle ] == target ) return target ; if ( v [ middle ] < target ) start = middle + 1 ; if ( v [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } // lowerbound = at index end int diFFWithLowerBound = std :: abs ( target - v [ end ]); int diFFWithUpperBound = std :: abs ( v [ end + 1 ] - target ); if ( diFFWithLowerBound > diFFWithUpperBound ) return v [ end + 1 ]; if ( diFFWithLowerBound < diFFWithUpperBound ) return v [ end ]; return -1 ; // both are same distant }","title":"C++ Code Solution"},{"location":"binary-search/problems/#time-and-space-complexity","text":"No extra space is required, so \\(O(1)\\) space and total of \\(O(\\lg n)\\) time is required for binary search.","title":"Time and space complexity"},{"location":"binary-search/problems/#search-in-a-sorted-2d-matrix","text":"Similar Problem on Leetcode \\(\\to\\)","title":"Search in a sorted 2D matrix"},{"location":"binary-search/problems/#problem-statement_3","text":"Write an efficient algorithm that searches for a value target in an \\(M \\times N\\) integer matrix matrix . This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Also can be termed as inter-row-wise sorted .","title":"Problem Statement"},{"location":"binary-search/problems/#example","text":"Matrix : \\(M_A = \\begin{bmatrix} 1 & 3 & 5 & 7 \\\\ 10 & 11 & 16 & 20 \\\\ 23 & 30 & 34 & 60 \\end{bmatrix}\\) Input = MA and target = 3 Output: true","title":"Example"},{"location":"binary-search/problems/#approach_6","text":"First you start a probe for the row in which the data may be present, then search column wise. Total time taken in this approach is \\(O(\\log_2 \\text{Rows}) + O(\\log_2 \\text{Columns})\\) . Check out the following code to see how the edge cases are handled.","title":"Approach"},{"location":"binary-search/problems/#code_5","text":"class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { // base cases int rows = matrix . size (); int cols = matrix [ 0 ]. size (); // only one element in the matrix if ( rows == 1 and cols == 1 ) return matrix [ 0 ][ 0 ] == target ; // matrix data out of bounds if ( target < matrix [ 0 ][ 0 ] or target > matrix [ rows -1 ][ cols -1 ]) return false ; // start a row probe to find in which row the data may be there? int start = 0 ; int end = matrix . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ middle ][ 0 ] == target ) return true ; if ( matrix [ middle ][ 0 ] > target ) end = middle - 1 ; if ( matrix [ middle ][ 0 ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } // start is the lower bound on the row ID int rowID = end ; cout << rowID << endl ; // now we should start a column probe start = 0 ; end = matrix [ 0 ]. size () - 1 ; middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ rowID ][ middle ] == target ) return true ; if ( matrix [ rowID ][ middle ] > target ) end = middle - 1 ; if ( matrix [ rowID ][ middle ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } return false ; } };","title":"Code"},{"location":"binary-search/problems/#search-in-a-sorted-matrix-but-not-inter-row-wise-sorted","text":"Find the problem on Leetcode \\(\\to\\)","title":"Search in a sorted matrix but not inter-row-wise sorted"},{"location":"binary-search/problems/#problem-statement_4","text":"The problem statement is almost identical similar but the rule first integer of each row is greater than the last integer of the previous row does NOT apply here.","title":"Problem Statement"},{"location":"binary-search/problems/#example_1","text":"Matrix : \\(M_B = \\begin{bmatrix} 1 & 3 & 5 & 7 \\\\ 2 & 4 & 64 & 20 \\\\ 3 & 5 & 134 & 60 \\end{bmatrix}\\) Input = MB and target = 3 Output: true","title":"Example"},{"location":"binary-search/problems/#approaches","text":"We can do a row wise binary search to find the element, that'll take \\(O(\\text{|rows|} \\lg \\text{|cols|})\\) time to complete. Otherwise we can also implement a linear time algorithm to find the element. This will be much faster than the log approach. Here we'll do the followings, first we'll start from the first row and last column of the matrix then if we find the element is \\(\\geq\\) than the target means it'll be available only at a lower row than the current row. Here target is 16 and 15 is at the first row and last column of the matrix. So we should go down by one row. At the second row we see 19 that is greater than the target \\(16\\) so we should go left by one column because \\(16\\) can not be present below \\(19\\) in the last column. This is how we find the element.","title":"Approaches"},{"location":"binary-search/problems/#code_6","text":"","title":"Code"},{"location":"binary-search/problems/#code-with-binary-search","text":"class Solution { private : bool rowWiseSearch ( vector < vector < int >>& matrix , int row , int target ) { int start = 0 ; int end = matrix [ row ]. size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( matrix [ row ][ middle ] == target ) return true ; if ( matrix [ row ][ middle ] > target ) end = middle - 1 ; if ( matrix [ row ][ middle ] < target ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } return false ; } public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int rows = matrix . size (); for ( int i = 0 ; i < rows ; i ++ ) { bool found = rowWiseSearch ( matrix , i , target ); if ( found == true ) return true ; } return false ; } };","title":"CODE WITH BINARY SEARCH"},{"location":"binary-search/problems/#code-with-matrix-linear-search","text":"class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { // base case: 1x1 matrix if ( matrix . size () == 1 ) { if ( matrix [ 0 ]. size () == 1 ) return matrix [ 0 ][ 0 ] == target ; } // base case: numbers out of bounds if ( target < matrix [ 0 ][ 0 ] or target > matrix [ matrix . size () - 1 ][ matrix [ 0 ]. size () - 1 ]) { return false ; } int rows = matrix . size (); int cols = matrix [ 0 ]. size (); int i = rows - 1 ; int j = 0 ; while ( i >= 0 and j < cols ) { if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) { j ++ ; } else { i -- ; } } return false ; } };","title":"CODE WITH MATRIX-LINEAR SEARCH"},{"location":"binary-search/problems/#time-complexity_1","text":"The matrix linear search takes \\(O(\\text{|rows|} + \\text{|cols|})\\) time because at worst case we'll reach to last row and first column of the matrix.","title":"Time Complexity"},{"location":"binary-search/problems/#search-for-range","text":"Problem on Leetcode \\(\\to\\) Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return \\([-1, -1]\\) . We must write an algorithm with \\(O(\\log_2 n)\\) runtime complexity.","title":"Search for Range"},{"location":"binary-search/problems/#example_2","text":"Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1]","title":"Example"},{"location":"binary-search/problems/#approach_7","text":"Two things we need to find here, these are the first occurrence of some repeating elements and last occurrence of some repeating elements. Before we do anything we should first search in \\(O(\\lg n)\\) whether the array contains the element or not, if not return \\([-1,-1]\\) . Otherwise the program could become complicated while searching for first occurrence and last occurrence also search if it's there or not. Better to separate the logic. So we should write 3 subroutines: firstOccurrence() and lastOccurrence() and a routine for binary_search() . We'll return \\([-1, -1]\\) if binary_search() returns false. To calculate the firstOccurrence() we modify the binary search subroutine itself. When we find the middle element greater than or equal to the target then instead of setting \\(\\text{end} = \\text{middle} - 1\\) we'll include the end as middle (set \\(\\text{end} = \\text{middle}\\) ). To calculate the lastOccurence() we'll write the exact same code as firstOccurence() (using symmetry). However there is a problem with the code. The program for lastOccurence() will not halt and loop forever in the following scenario: while ( start < end ) { ... } else { start = middle ; } ... } the code will fall into infinite loop when the arrangement becomes this We'll manually update the lastOccurrence in this case.","title":"Approach"},{"location":"binary-search/problems/#code_7","text":"class Solution { public : int firstOccurrence ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; // [1,2,3,4,4,4,7]; target = 4; // | | | // start. mid. end. // next step: [1,2,3,4] // | | // mid end // next step: [3,4] // | | // s,m end // next step: [4] // | start, end, middle while ( start < end ) { if ( nums [ middle ] < target ) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } int lastOccurrence ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start < end ) { // there is a condition when it loops forever // end = start + 1; // [k , j] // | | // m,s end // check for this if ( start == end - 1 ) { // check for a case where [2,2] and target is 2 if ( nums [ start ] == nums [ end ]) { return end ; } // manually escape this situation // there can be case [5, 7] and t=5 where it loops forever because start = middle if ( nums [ start ] == target ) { return start ; } else if ( nums [ end ] == target ){ // case for [2,3] and t=3 return end ; } } if ( nums [ middle ] > target ) { end = middle - 1 ; } else { start = middle ; } middle = start + ( end - start ) / 2 ; } return start ; } bool binary_search ( vector < int > & nums , int target ) { int start = 0 ; int end = nums . size () - 1 ; int middle = start + ( end - start ) / 2 ; while ( start <= end ) { if ( nums [ middle ] == target ) { return true ; } if ( nums [ middle ] < target ) start = middle + 1 ; if ( nums [ middle ] > target ) end = middle - 1 ; middle = start + ( end - start ) / 2 ; } return false ; } vector < int > searchRange ( vector < int >& nums , int target ) { if ( not binary_search ( nums , target )) { vector < int > answer = { -1 , -1 }; return answer ; } vector < int > answer ; int firstocc = firstOccurrence ( nums , target ); int lastocc = lastOccurrence ( nums , target ); answer . push_back ( firstocc ); answer . push_back ( lastocc ); return answer ; } };","title":"Code"},{"location":"binary-search/problems/#koko-eating-bananas","text":"Find the problem on Leetcode \\(\\to\\)","title":"Koko Eating Bananas"},{"location":"binary-search/problems/#problem-statement_5","text":"Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.","title":"Problem Statement"},{"location":"binary-search/problems/#examples_1","text":"Input: piles = [3,6,7,11], h = 8 Output: 4 Input: piles = [30,11,23,4,20], h = 5 Output: 30 Input: piles = [30,11,23,4,20], h = 6 Output: 23","title":"Examples"},{"location":"binary-search/problems/#code_8","text":"class Solution { private : pair < bool , int > finishableCheck ( vector < int > & piles , int k , int h ) { // check finishability with k bananas per hour // and given h hours to play time // retruns finishable or not and finish time int eatableTime = 0 ; for ( auto l : piles ) { eatableTime += l / k + ( l % k == 0 ? 0 : 1 ); } pair < bool , int > p ; p . second = eatableTime ; if ( eatableTime > h ) { p . first = false ; return p ; } p . first = true ; return p ; } public : int minEatingSpeed ( vector < int >& piles , int h ) { if ( piles . size () == 1 ) { return ceil (( double ) piles [ 0 ] / ( double ) h ); } // [piles of banana] // [213 45 5 6 7 7 8] // total available time is h hours // banana eating speed = k // lowest possible value for k is 1 // eat at least min(piles[i]) banana per hour. int lo = 1 ; // and highest possible banana per hour // should be = piles[i] for i piles[i] is maximum int hi = piles [ 0 ]; for ( int i : piles ) { if ( i > hi ) hi = i ; } int middle = lo + ( hi - lo ) / 2 ; while ( lo < hi ) { // now check for middle if this satisfies the // eating banana pile every hour // and finishing before guards comes back cout << \"From \" << lo << \" to \" << hi << \": \" ; pair < bool , int > p = finishableCheck ( piles , middle , h ); if ( p . first == true ) hi = middle ; if ( p . first == false and p . second > h ) { lo = middle + 1 ; } cout << \" middle: \" << middle << \" p.first = \" << p . first << \" p.second = \" << p . second << endl ; middle = lo + ( hi - lo ) / 2 ; } return hi ; } };","title":"Code"},{"location":"binary-search/problems/#time-based-key-value-store","text":"Find the problem on Leetcode \\(\\to\\)","title":"Time Based Key-Value Store"},{"location":"binary-search/problems/#problem-statement_6","text":"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Task is to implement the TimeMap class, TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp . If there are multiple such values, it returns the value associated with the largest timestamp_prev . If there are no values, it returns \"\" .","title":"Problem Statement"},{"location":"binary-search/problems/#example_3","text":"Input [\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"] [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]] Output [null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"] Explaination Explanation TimeMap timeMap = new TimeMap(); timeMap.set(\"foo\", \"bar\", 1); // store the key \"foo\" and value \"bar\" along with timestamp = 1. timeMap.get(\"foo\", 1); // return \"bar\" timeMap.get(\"foo\", 3); // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\". timeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4. timeMap.get(\"foo\", 4); // return \"bar2\" timeMap.get(\"foo\", 5); // return \"bar2\"","title":"Example"},{"location":"binary-search/problems/#approach-1","text":"We'll use a time-based map implementation. For each timestamp we'll record all the {key, value} pairs coming in. And return when asked. If the timestamp is not found then we'll see what is the last timestamp for which this key was recorded, we'll return that. To find the last timestamp for which this key was recorded we need to do a linear decrement of the timestamp and check if the key is present or not for every time stamps. Else we can change the design of the map and get a better upper bound on the time complexity. As the times are always in sorted order (time is always increasing), we maybe able to use binary search. For this particular design following is the code. Hashtable design timestamp unordered_map<Key, Value> 1 <\"outlaw\", \"1673\"> 4 <\"outlaw\", 33>","title":"Approach #1"},{"location":"binary-search/problems/#code-for-approach-1","text":"class TimeMap { private : unordered_map < int , unordered_map < string , string >> mp ; public : TimeMap () {} void set ( string key , string value , int timestamp ) { mp [ timestamp ][ key ] = value ; } string get ( string key , int timestamp ) { // if there is no timestamp for key \"key\" if ( mp . find ( timestamp ) == mp . end ()) { while ( timestamp ){ // go in reverse order of timestamp to find the key if exists before or not? // return the last if ( mp [ timestamp ]. find ( key ) != mp [ timestamp ]. end ()) { return mp [ timestamp ][ key ]; } timestamp -- ; } } return mp [ timestamp ][ key ]; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj->set(key,value,timestamp); * string param_2 = obj->get(key,timestamp); */","title":"Code for Approach #1"},{"location":"binary-search/problems/#approach-2","text":"The previous design was a bit easier to understand but had a flaw that if we don't find element in the map for some timestamp then we'd have to linearly decrease the timestamps and check for the key, else we'll use a better design. For each key we'll, maintain a vector<pair<string, int>> value & time pair. Then if there exists any key and don't exists the asked timestamp we can give back the binary search lower bound from the array. Hashtable new design Key pair<Value, TimeStamp> outlaw <\"1673\", 1>, <\"33\", 4> -- -- Now with this design of the system we can do a simple binary search on the lower bound of the timestamp in \\(O(\\lg N)\\) time.","title":"Approach #2"},{"location":"binary-search/problems/#code-for-approach-2","text":"class TimeMap { private : // hashtable design // unordered_map<key, vector<pair<value, timestamp>>> unordered_map < string , vector < pair < string , int >>> map ; public : TimeMap () {} void set ( string key , string value , int timestamp ) { if ( map . find ( key ) == map . end ()) { // there doesn't exists a key, first time the key has come up // so add this vector < pair < string , int >> v = {{ value , timestamp }}; map . insert ({ key , v }); } else { // means key is inserted at a before timestamp than now // this becomes naturally sorted with the timestamps map [ key ]. push_back ({ value , timestamp }); } } string get ( string key , int timestamp ) { // we assume key is already present before making a query // we also have a time stamp // so we'll do a binary search on the timestamp to get the result at the given time stamp // else we'll return the lower bound on the timestamp int start = 0 ; int end = map [ key ]. size () - 1 ; // basecase // query is at the timestamp far before first key to be registered int middle = start + ( end - start ) / 2 ; // O(lg n) compare while ( start <= end ) { if ( map [ key ][ middle ]. second == timestamp ) return map [ key ][ middle ]. first ; if ( map [ key ][ middle ]. second > timestamp ) end = middle - 1 ; if ( map [ key ][ middle ]. second < timestamp ) start = middle + 1 ; middle = start + ( end - start ) / 2 ; } if ( end == - 1 ) return \"\" ; return map [ key ][ end ]. first ; } }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj->set(key,value,timestamp); * string param_2 = obj->get(key,timestamp); */","title":"Code for Approach #2"},{"location":"binary-search/problems/#next-alphabetical-element","text":"","title":"Next alphabetical element"},{"location":"binary-search/problems/#find-position-of-an-element-in-an-infinite-sorted-array","text":"","title":"Find position of an element in an Infinite Sorted Array"},{"location":"binary-search/problems/#index-of-first-1-in-a-binary-sorted-infinite-array","text":"","title":"Index of First 1 in a Binary Sorted Infinite Array"},{"location":"binary-search/problems/#binary-search-on-answer-concept","text":"","title":"Binary Search on Answer Concept"},{"location":"binary-search/problems/#peak-element","text":"","title":"Peak Element"},{"location":"binary-search/problems/#find-maximum-element-in-bitonic-array","text":"","title":"Find maximum element in Bitonic Array"},{"location":"binary-search/problems/#search-an-element-in-bitonic-array","text":"","title":"Search An Element in Bitonic Array"},{"location":"binary-search/problems/#allocate-minimum-number-of-pages","text":"","title":"Allocate minimum number of pages"},{"location":"dp/knapsack/","text":"Knapsack Pattern These problems discussed below conforms to one knapsack pattern. Using solutions to the knapsack problem and a little modification you'll be able to solve almost all of the following problems. We'll discuss this as we explain the code and the apporach to these problems. Subset Sum Equal sum partition Count of subset sum Minimum subset sum difference Target Sum Count the number of subsets with given difference","title":"Knapsack Pattern"},{"location":"dp/knapsack/#knapsack-pattern","text":"These problems discussed below conforms to one knapsack pattern. Using solutions to the knapsack problem and a little modification you'll be able to solve almost all of the following problems. We'll discuss this as we explain the code and the apporach to these problems.","title":" Knapsack Pattern"},{"location":"dp/knapsack/#subset-sum","text":"","title":"Subset Sum"},{"location":"dp/knapsack/#equal-sum-partition","text":"","title":"Equal sum partition"},{"location":"dp/knapsack/#count-of-subset-sum","text":"","title":"Count of subset sum"},{"location":"dp/knapsack/#minimum-subset-sum-difference","text":"","title":"Minimum subset sum difference"},{"location":"dp/knapsack/#target-sum","text":"","title":"Target Sum"},{"location":"dp/knapsack/#count-the-number-of-subsets-with-given-difference","text":"","title":"Count the number of subsets with given difference"},{"location":"dp/problems/","text":"Dynamic programming There is a famous quote saying that \" those who don't remember the past are condemned to repeat it \". This quote very much synchronizes with the meaning of dynamic programming. What in dynamic programming you do is you calculate and remember the calculation, if and when the same calculation is encountered again, instead of recomputing it you fetch the data this reducing computing time. There are several problems where you are required to calculate something multiple times and if you cache the data then you can avoid computation multiple times. Let's see some of the problems where you need to cache some result to avoid multiple computations. Table of Contents Climbing Stairs Frog Jump House Robber Climbing Stairs Find the Problem on Leetcode \\(\\to\\) Problem Statement You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Approach We are told that we can only reach to the top with once step or 2 step in the staircase. The number ways we can reach to the top is exactly the number of ways we can reach to the \\(n -1^{th}\\) step \\(+\\) number of ways we can reach to the \\(n -2^{nd}\\) step. So we quickly write a recursive function and will only compute if not aready computed. Code class Solution { private : unordered_map < int , int > mp ; public : int climbStairs ( int n ) { if ( n <= 2 ) return n ; if ( mp . find ( n ) == mp . end ()) { int ways = climbStairs ( n -2 ) + climbStairs ( n -1 ); mp . insert ({ n , ways }); } return mp [ n ]; } }; Frog Jump Find the Problem on Codestudio Problem Statement There is a frog on the 1st step of an \\(N\\) stairs long staircase. The frog wants to reach the \\(N^{th}\\) stair. HEIGHT[] is the height of the (i+1)th stair.If Frog jumps from ith to jth stair, the energy lost in the jump is given by HEIGHT[i-1] - HEIGHT[j-1] . In the Frog is on ith staircase, he can jump either to \\((i+1)^{th}\\) stair or to \\((i+2)^{th}\\) stair. Your task is to find the minimum total energy used by the frog to reach from 1st stair to \\(N^{th}\\) stair. Approach We'll be using normal Dynamic Programming approach. We'll manually hard code the cost of moving for 0th (index which is 0) and 1st index (which is \\(\\text{heights[0] - heights[1]}\\) ). Then for each \\(i\\) we'll see the result for \\(i-1\\) and \\(i-2\\) and select the step that uses less energy. We update the energy lost at step \\(i\\) then go to step \\(i+1\\) . We don't have to store the \\([0 \\to i]\\) step costs because we are using only \\(i-1\\) and \\(i-2\\) values at any given \\(i\\) . So a \\(2\\) element array or a pair<int, int> is enough. Code #include <unordered_map> int frogJump ( int n , vector < int > & heights ) { // Write your code here. int energy_lost = 0 ; pair < int , int > store ; store . first = 0 ; store . second = std :: abs ( heights [ 1 ] - heights [ 0 ]); for ( int i = 2 ; i < n ; i ++ ) { int oneStepCost = store . second + std :: abs ( heights [ i ] - heights [ i -1 ]); int twoStepCost = store . first + std :: abs ( heights [ i ] - heights [ i -2 ]); int energyLostNow = std :: min ( oneStepCost , twoStepCost ); store . first = store . second ; store . second = energyLostNow ; } return store . second ; } House Robber Find the problem on Leetcode \\(\\to\\) Problem Statement You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Examples Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Approach We'll be using a DP apporach to solve this problem, the main objective is to come up with some recursive solution standing at the \\(i^{th}\\) location. So let's build an intuition around that, For location \\(i = 0\\) you only can rob the \\(0^{th}\\) house, and standing at the \\(1^{st}\\) house you can either rob the \\(0^{th}\\) house and skip the \\(1^{st}\\) house or skip the \\(0^{th}\\) house and rob the \\(1^{st}\\) house whichever gives more profit. So we'll do the following, we'll indicate for index \\(i -1\\) a map m which will show what could have been the maximum profit we could make till \\(i-1\\) index. Depending upon the choice at index \\(i\\) we'll update the maximum profit we can make till this location \\(i\\) . What are the decisions you need to make before you can make a move at location \\(i\\) ? The question can be answered by looking at the \\(i-1^{th}\\) location see what is the maximum you can make till \\(i-1\\) . Then you either skip this location and make a move at the next location or make a move at this location and skip the next location. Take whatever maximizes the profit. So profit till \\(0\\) will be nums[0] profits till \\(1\\) will be std::max(nums[0], nums[1]) Profits at location \\(2\\) will be the following Either you take the profit from the \\(0^{th}\\) index and rob the \\(2^{nd}\\) location or you take the profit till the \\(1^{st}\\) location and skip the second location. \\(\\forall x \\in [0, \\text{nums.size})\\) we'll see what is maximum between the following two profits[i-1] and profits[i-2] + nums[i] . We'll take the maximum and put in the profits map or array. Code class Solution { private : int max_profit = INT_MIN ; public : int rob ( vector < int >& nums ) { if ( nums . size () == 1 ) return nums [ 0 ]; if ( nums . size () == 2 ) return std :: max ( nums [ 0 ], nums [ 1 ]); pair < int , int > profits ; profits . first = nums [ 0 ]; profits . second = std :: max ( nums [ 0 ], nums [ 1 ]); for ( int i = 2 ; i < nums . size (); i ++ ) { int max_profit_possible = std :: max ( profits . first + nums [ i ], profits . second ); max_profit = std :: max ( max_profit , max_profit_possible ); profits . first = profits . second ; profits . second = max_profit ; } return profits . second ; } };","title":"Problems"},{"location":"dp/problems/#dynamic-programming","text":"There is a famous quote saying that \" those who don't remember the past are condemned to repeat it \". This quote very much synchronizes with the meaning of dynamic programming. What in dynamic programming you do is you calculate and remember the calculation, if and when the same calculation is encountered again, instead of recomputing it you fetch the data this reducing computing time. There are several problems where you are required to calculate something multiple times and if you cache the data then you can avoid computation multiple times. Let's see some of the problems where you need to cache some result to avoid multiple computations. Table of Contents Climbing Stairs Frog Jump House Robber","title":" Dynamic programming"},{"location":"dp/problems/#climbing-stairs","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Climbing Stairs"},{"location":"dp/problems/#problem-statement","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","title":"Problem Statement"},{"location":"dp/problems/#example","text":"Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step","title":"Example"},{"location":"dp/problems/#approach","text":"We are told that we can only reach to the top with once step or 2 step in the staircase. The number ways we can reach to the top is exactly the number of ways we can reach to the \\(n -1^{th}\\) step \\(+\\) number of ways we can reach to the \\(n -2^{nd}\\) step. So we quickly write a recursive function and will only compute if not aready computed.","title":"Approach"},{"location":"dp/problems/#code","text":"class Solution { private : unordered_map < int , int > mp ; public : int climbStairs ( int n ) { if ( n <= 2 ) return n ; if ( mp . find ( n ) == mp . end ()) { int ways = climbStairs ( n -2 ) + climbStairs ( n -1 ); mp . insert ({ n , ways }); } return mp [ n ]; } };","title":"Code"},{"location":"dp/problems/#frog-jump","text":"Find the Problem on Codestudio","title":"Frog Jump"},{"location":"dp/problems/#problem-statement_1","text":"There is a frog on the 1st step of an \\(N\\) stairs long staircase. The frog wants to reach the \\(N^{th}\\) stair. HEIGHT[] is the height of the (i+1)th stair.If Frog jumps from ith to jth stair, the energy lost in the jump is given by HEIGHT[i-1] - HEIGHT[j-1] . In the Frog is on ith staircase, he can jump either to \\((i+1)^{th}\\) stair or to \\((i+2)^{th}\\) stair. Your task is to find the minimum total energy used by the frog to reach from 1st stair to \\(N^{th}\\) stair.","title":"Problem Statement"},{"location":"dp/problems/#approach_1","text":"We'll be using normal Dynamic Programming approach. We'll manually hard code the cost of moving for 0th (index which is 0) and 1st index (which is \\(\\text{heights[0] - heights[1]}\\) ). Then for each \\(i\\) we'll see the result for \\(i-1\\) and \\(i-2\\) and select the step that uses less energy. We update the energy lost at step \\(i\\) then go to step \\(i+1\\) . We don't have to store the \\([0 \\to i]\\) step costs because we are using only \\(i-1\\) and \\(i-2\\) values at any given \\(i\\) . So a \\(2\\) element array or a pair<int, int> is enough.","title":"Approach"},{"location":"dp/problems/#code_1","text":"#include <unordered_map> int frogJump ( int n , vector < int > & heights ) { // Write your code here. int energy_lost = 0 ; pair < int , int > store ; store . first = 0 ; store . second = std :: abs ( heights [ 1 ] - heights [ 0 ]); for ( int i = 2 ; i < n ; i ++ ) { int oneStepCost = store . second + std :: abs ( heights [ i ] - heights [ i -1 ]); int twoStepCost = store . first + std :: abs ( heights [ i ] - heights [ i -2 ]); int energyLostNow = std :: min ( oneStepCost , twoStepCost ); store . first = store . second ; store . second = energyLostNow ; } return store . second ; }","title":"Code"},{"location":"dp/problems/#house-robber","text":"Find the problem on Leetcode \\(\\to\\)","title":"House Robber"},{"location":"dp/problems/#problem-statement_2","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","title":"Problem Statement"},{"location":"dp/problems/#examples","text":"Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.","title":"Examples"},{"location":"dp/problems/#approach_2","text":"We'll be using a DP apporach to solve this problem, the main objective is to come up with some recursive solution standing at the \\(i^{th}\\) location. So let's build an intuition around that, For location \\(i = 0\\) you only can rob the \\(0^{th}\\) house, and standing at the \\(1^{st}\\) house you can either rob the \\(0^{th}\\) house and skip the \\(1^{st}\\) house or skip the \\(0^{th}\\) house and rob the \\(1^{st}\\) house whichever gives more profit. So we'll do the following, we'll indicate for index \\(i -1\\) a map m which will show what could have been the maximum profit we could make till \\(i-1\\) index. Depending upon the choice at index \\(i\\) we'll update the maximum profit we can make till this location \\(i\\) . What are the decisions you need to make before you can make a move at location \\(i\\) ? The question can be answered by looking at the \\(i-1^{th}\\) location see what is the maximum you can make till \\(i-1\\) . Then you either skip this location and make a move at the next location or make a move at this location and skip the next location. Take whatever maximizes the profit. So profit till \\(0\\) will be nums[0] profits till \\(1\\) will be std::max(nums[0], nums[1]) Profits at location \\(2\\) will be the following Either you take the profit from the \\(0^{th}\\) index and rob the \\(2^{nd}\\) location or you take the profit till the \\(1^{st}\\) location and skip the second location. \\(\\forall x \\in [0, \\text{nums.size})\\) we'll see what is maximum between the following two profits[i-1] and profits[i-2] + nums[i] . We'll take the maximum and put in the profits map or array.","title":"Approach"},{"location":"dp/problems/#code_2","text":"class Solution { private : int max_profit = INT_MIN ; public : int rob ( vector < int >& nums ) { if ( nums . size () == 1 ) return nums [ 0 ]; if ( nums . size () == 2 ) return std :: max ( nums [ 0 ], nums [ 1 ]); pair < int , int > profits ; profits . first = nums [ 0 ]; profits . second = std :: max ( nums [ 0 ], nums [ 1 ]); for ( int i = 2 ; i < nums . size (); i ++ ) { int max_profit_possible = std :: max ( profits . first + nums [ i ], profits . second ); max_profit = std :: max ( max_profit , max_profit_possible ); profits . first = profits . second ; profits . second = max_profit ; } return profits . second ; } };","title":"Code"},{"location":"graph/bfs-dfs/","text":"Breath first and depth-first search BFS and DFS are two of the most common graph as well as tree traversal techniques that ever existed. You should always understand the basic understanding behind these traversals. Things to remember about BFS uses a queue and FIFO ordering is something that it uses. DFS uses recursion, and recursively goes in-depth until the element is found. Standard Graph implementation We'll use our standard implementation for graphs and will write BFS and DFS to work on that standard graph. The following graph implementation may not be the very best implementation that you'll find, but it is good enough and most importantly you'll be able to implement this in an interview setting. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; public : void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; Now on top of this custom graph [adjacency list] representation, we'll implement BFS and DFS the 2 most common algorithms in graphs and trees ever. BFS with standard graph Implementation follows the CLRS textbook for reference although is not a blind copy. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> #include <queue> vector < char > BFS ( Graph & g , char startFromVertex ){ // create a queue queue < char > q ; // result order for the bfs vector < char > bfstree ; // the graph as a map unordered_map < char , list < pair < char , int >>> graphView = g . view (); // visited map unordered_map < char , bool > visited ; for ( auto vertex : graphView ) visited [ vertex . first ] = false ; q . push ( startFromVertex ); // startFromVertex must be in graph g while ( ! q . empty ()){ char vert = q . front (); if ( visited [ vert ] == false ){ // if we did not visit this vertex please process bfstree . push_back ( vert ); auto neighbors = graphView [ vert ]; for ( auto neighbor : neighbors ){ q . push ( neighbor . first ); } visited [ vert ] = true ; } // now remove the vertex q . pop (); } return bfstree ; } DFS on standard Graph Implementation of DFS is recursive, it recursively goes into the graph then backtracks once there is nowhere to go. But in this implementation, I'll strictly avoid recursion because the graph is a little hard to grasp, and doing recursion on a graph may seem \\(\\text{BLACK MAGIC}\\) . Instead, I'll implement DFS using a stack data structure to mimic recursion. It's an iterative implementation that is much easier to grasp. vector < char > DFS ( Graph & g , char startFromVertex ){ vector < char > stack ; unordered_map < char , bool > visited ; vector < char > dfsOrder ; auto graphView = g . view (); // initialize all the visited == false for ( auto vertex : graphView ) visited [ vertex . first ] = false ; // push whatever with you are starting with stack . push_back ( startFromVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ // if this top of the stack is not visited then mark it // visited and push into the answer array [dfsOrder]. visited [ tos ] = true ; dfsOrder . push_back ( tos ); } for ( auto adj_list : graphView [ tos ]){ // look at the adj_list of tos vertex if ( visited [ adj_list . first ] == false ){ stack . push_back ( adj_list . first ); } } } return dfsOrder ; } Application of depth first search Find all the connected components of a graph Approach Using depth first search we can go in depth of a graph and for each connected components the DFS program will stop. We do this until we visit all the nodes in a graph. This way we'll find all the connected components of the graph. C++ Code #include <algorithm> #include <iostream> #include <vector> #include <unordered_map> #include <forward_list> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertices ){ for ( char vert : vertices ){ forward_list < char > neighbor ; adj_list . insert ({ vert , neighbor }); } } unordered_map < char , forward_list < char >> view (){ return adj_list ; } void add_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } }; vector < char > DFSOrder ( Graph & g , char startingVertex ){ unordered_map < char , bool > visited ; vector < char > stack ; vector < char > order ; auto view = g . view (); // mark all node to visited == false for ( auto y : view ) visited [ y . first ] = false ; stack . push_back ( startingVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ visited [ tos ] = true ; order . push_back ( tos ); } for ( auto nbr : view [ tos ]){ if ( visited [ nbr ] == false ){ stack . push_back ( nbr ); } } } return order ; } void connected_components ( Graph & g ){ unordered_map < char , bool > visited ; auto view = g . view (); // mark all node to visited == false // doesn't matter what is the value for each (key, value) pair in map; // we'll be deleting upon seeing a key that is visited. // we could have made a vector then the delete would become O(n); for ( auto y : view ) visited [ y . first ] = false ; // while( visited == all not true) // use dfs; int connected_component_number = 0 ; while ( ! visited . empty ()){ // take any random vertex that is not yet visited char startingVertex = visited . begin () -> first ; vector < char > dfs = DFSOrder ( g , startingVertex ); cout << \"Connected Component Number: \" << connected_component_number << \" -> \" ; // now remove all the visited in this call of dfs for ( char this_component_vertex : dfs ){ cout << this_component_vertex << \" \" ; visited . erase ( this_component_vertex ); } connected_component_number ++ ; cout << endl ; } } // DRIVER CODE int main (){ int number_of_vertices ; vector < char > v ; cin >> number_of_vertices ; while ( number_of_vertices ){ char vertex ; cin >> vertex ; v . push_back ( vertex ); number_of_vertices -- ; } Graph g = Graph ( v ); int number_of_edges ; cin >> number_of_edges ; while ( number_of_edges ){ char from , to ; cin >> from >> to ; g . add_edge ( from , to ); number_of_edges -- ; } auto view = g . view (); for ( auto vert : view ){ cout << vert . first << \" -> \" ; for ( auto nbr : vert . second ) cout << nbr << \" \" ; cout << endl ; } vector < char > dfs = DFSOrder ( g , 'a' ); cout << \"DFS ORDER Starting From 'a' -> \" ; for ( auto i : dfs ) cout << i << \" \" ; cout << endl ; connected_components ( g ); } Let's run the above program on a random graph Input Pattern 5 <- Number of vertices a b c <- all the vertices of the graph d e 3 <- number of edges a b <- Edges in between vertices, undirected edges b c c e Example Output e -> c d -> c -> e b a -> b b -> c a DFS ORDER Starting From 'a' -> a b c e Connected Component Number: 0 -> b a c e Connected Component Number: 1 -> d","title":"BFS and DFS"},{"location":"graph/bfs-dfs/#breath-first-and-depth-first-search","text":"BFS and DFS are two of the most common graph as well as tree traversal techniques that ever existed. You should always understand the basic understanding behind these traversals.","title":"Breath first and depth-first search"},{"location":"graph/bfs-dfs/#things-to-remember-about","text":"BFS uses a queue and FIFO ordering is something that it uses. DFS uses recursion, and recursively goes in-depth until the element is found.","title":"Things to remember about"},{"location":"graph/bfs-dfs/#standard-graph-implementation","text":"We'll use our standard implementation for graphs and will write BFS and DFS to work on that standard graph. The following graph implementation may not be the very best implementation that you'll find, but it is good enough and most importantly you'll be able to implement this in an interview setting. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; public : void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; Now on top of this custom graph [adjacency list] representation, we'll implement BFS and DFS the 2 most common algorithms in graphs and trees ever.","title":"Standard Graph implementation"},{"location":"graph/bfs-dfs/#bfs-with-standard-graph","text":"Implementation follows the CLRS textbook for reference although is not a blind copy. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> #include <queue> vector < char > BFS ( Graph & g , char startFromVertex ){ // create a queue queue < char > q ; // result order for the bfs vector < char > bfstree ; // the graph as a map unordered_map < char , list < pair < char , int >>> graphView = g . view (); // visited map unordered_map < char , bool > visited ; for ( auto vertex : graphView ) visited [ vertex . first ] = false ; q . push ( startFromVertex ); // startFromVertex must be in graph g while ( ! q . empty ()){ char vert = q . front (); if ( visited [ vert ] == false ){ // if we did not visit this vertex please process bfstree . push_back ( vert ); auto neighbors = graphView [ vert ]; for ( auto neighbor : neighbors ){ q . push ( neighbor . first ); } visited [ vert ] = true ; } // now remove the vertex q . pop (); } return bfstree ; }","title":"BFS with standard graph"},{"location":"graph/bfs-dfs/#dfs-on-standard-graph","text":"Implementation of DFS is recursive, it recursively goes into the graph then backtracks once there is nowhere to go. But in this implementation, I'll strictly avoid recursion because the graph is a little hard to grasp, and doing recursion on a graph may seem \\(\\text{BLACK MAGIC}\\) . Instead, I'll implement DFS using a stack data structure to mimic recursion. It's an iterative implementation that is much easier to grasp. vector < char > DFS ( Graph & g , char startFromVertex ){ vector < char > stack ; unordered_map < char , bool > visited ; vector < char > dfsOrder ; auto graphView = g . view (); // initialize all the visited == false for ( auto vertex : graphView ) visited [ vertex . first ] = false ; // push whatever with you are starting with stack . push_back ( startFromVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ // if this top of the stack is not visited then mark it // visited and push into the answer array [dfsOrder]. visited [ tos ] = true ; dfsOrder . push_back ( tos ); } for ( auto adj_list : graphView [ tos ]){ // look at the adj_list of tos vertex if ( visited [ adj_list . first ] == false ){ stack . push_back ( adj_list . first ); } } } return dfsOrder ; }","title":"DFS on standard Graph"},{"location":"graph/bfs-dfs/#application-of-depth-first-search","text":"","title":"Application of depth first search"},{"location":"graph/bfs-dfs/#find-all-the-connected-components-of-a-graph","text":"","title":"Find all the connected components of a graph"},{"location":"graph/bfs-dfs/#approach","text":"Using depth first search we can go in depth of a graph and for each connected components the DFS program will stop. We do this until we visit all the nodes in a graph. This way we'll find all the connected components of the graph.","title":"Approach"},{"location":"graph/bfs-dfs/#c-code","text":"#include <algorithm> #include <iostream> #include <vector> #include <unordered_map> #include <forward_list> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertices ){ for ( char vert : vertices ){ forward_list < char > neighbor ; adj_list . insert ({ vert , neighbor }); } } unordered_map < char , forward_list < char >> view (){ return adj_list ; } void add_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } }; vector < char > DFSOrder ( Graph & g , char startingVertex ){ unordered_map < char , bool > visited ; vector < char > stack ; vector < char > order ; auto view = g . view (); // mark all node to visited == false for ( auto y : view ) visited [ y . first ] = false ; stack . push_back ( startingVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ visited [ tos ] = true ; order . push_back ( tos ); } for ( auto nbr : view [ tos ]){ if ( visited [ nbr ] == false ){ stack . push_back ( nbr ); } } } return order ; } void connected_components ( Graph & g ){ unordered_map < char , bool > visited ; auto view = g . view (); // mark all node to visited == false // doesn't matter what is the value for each (key, value) pair in map; // we'll be deleting upon seeing a key that is visited. // we could have made a vector then the delete would become O(n); for ( auto y : view ) visited [ y . first ] = false ; // while( visited == all not true) // use dfs; int connected_component_number = 0 ; while ( ! visited . empty ()){ // take any random vertex that is not yet visited char startingVertex = visited . begin () -> first ; vector < char > dfs = DFSOrder ( g , startingVertex ); cout << \"Connected Component Number: \" << connected_component_number << \" -> \" ; // now remove all the visited in this call of dfs for ( char this_component_vertex : dfs ){ cout << this_component_vertex << \" \" ; visited . erase ( this_component_vertex ); } connected_component_number ++ ; cout << endl ; } } // DRIVER CODE int main (){ int number_of_vertices ; vector < char > v ; cin >> number_of_vertices ; while ( number_of_vertices ){ char vertex ; cin >> vertex ; v . push_back ( vertex ); number_of_vertices -- ; } Graph g = Graph ( v ); int number_of_edges ; cin >> number_of_edges ; while ( number_of_edges ){ char from , to ; cin >> from >> to ; g . add_edge ( from , to ); number_of_edges -- ; } auto view = g . view (); for ( auto vert : view ){ cout << vert . first << \" -> \" ; for ( auto nbr : vert . second ) cout << nbr << \" \" ; cout << endl ; } vector < char > dfs = DFSOrder ( g , 'a' ); cout << \"DFS ORDER Starting From 'a' -> \" ; for ( auto i : dfs ) cout << i << \" \" ; cout << endl ; connected_components ( g ); } Let's run the above program on a random graph","title":"C++ Code"},{"location":"graph/bfs-dfs/#input-pattern","text":"5 <- Number of vertices a b c <- all the vertices of the graph d e 3 <- number of edges a b <- Edges in between vertices, undirected edges b c c e","title":"Input Pattern"},{"location":"graph/bfs-dfs/#example-output","text":"e -> c d -> c -> e b a -> b b -> c a DFS ORDER Starting From 'a' -> a b c e Connected Component Number: 0 -> b a c e Connected Component Number: 1 -> d","title":"Example Output"},{"location":"graph/dsu/","text":"Disjoint Set Data Structure Table of Contents Na\u00efve implementation of DSU APIs to support Union by rank optimization Some Problems on Leetcode that uses Disjoint Set Structure Na\u00efve implementation of DSU One of the na\u00efve implementation for DSU is to use an array. Here for a Leetcode problem I've shown an implementation of DSU that do not use rank-path compression optimizations, just plain and simple implementation of DSU with array. APIs to support find(int i) to find the parent of some node i makeUnion(int i, int j) to create a union of two nodes i and j . The following is a simple implementation of DSU that implements the upper 2 APIs. class DSU { private : int size ; vector < int > dsuArray ; public : DSU ( int n ) { int size = n ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsuArray . push_back ( i ); } } vector < int > getArray () { return dsuArray ; } int find ( int n ) { return dsuArray [ n ]; } bool makeUnion ( int i , int j ) { int parent_i = find ( i ); int parent_j = find ( j ); if ( parent_i == parent_j ) return false ; // find all occurences of parent_j // set to parent_i to make the Union for ( int i = 1 ; i < dsuArray . size (); i ++ ) { if ( dsuArray [ i ] == parent_j ) { dsuArray [ i ] = parent_i ; } } return true ; } }; Union by rank optimization If you see the makeUnion() API we are setting the parents of parent_j to parent_i . Now if the number of elements in the group of j is higher then there is a chance to optimize the time complexity. We can update the parent_i to parent_j as number of times parent_i is to be updated is much lower. This is called union by rank optimization . In order to do this we need to have some data structure that'll indicate the size of every group everytime we do an union. Then we can take the smaller group and updated its parents instead of updating the parent of the larger group size. Some Problems on Leetcode that uses Disjoint Set Structure Redundant Connection Problem Statement In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n , and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input. Example Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output: [1,4] Approach We'll use a DSU to add the edges in the DSU until we get a cycle. When we get a cycle, we'll add it to the answer, this will be the edge that we need to return. Code class DSU { private : int size ; vector < int > dsuArray ; public : DSU ( int n ) { int size = n ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsuArray . push_back ( i ); } } vector < int > getArray () { return dsuArray ; } int find ( int n ) { return dsuArray [ n ]; } bool makeUnion ( int i , int j ) { int parent_i = find ( i ); int parent_j = find ( j ); if ( parent_i == parent_j ) return false ; // find all occurences of parent_j // set to parent_i to make the Union for ( int i = 1 ; i < dsuArray . size (); i ++ ) { if ( dsuArray [ i ] == parent_j ) { dsuArray [ i ] = parent_i ; } } return true ; } }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { int maxim = INT_MIN ; for ( auto j : edges ) { maxim = std :: max ( j [ 0 ], maxim ); maxim = std :: max ( j [ 1 ], maxim ); } // number of nodes = maxim now. // now we create a DSU DSU dsu = DSU ( maxim ); vector < int > answer ; for ( auto edgePair : edges ) { int first = edgePair [ 0 ]; int second = edgePair [ 1 ]; bool possible = dsu . makeUnion ( edgePair [ 0 ], edgePair [ 1 ]); if ( not possible ) { answer . push_back ( edgePair [ 0 ]); answer . push_back ( edgePair [ 1 ]); } } return answer ; } };","title":"Disjoint Set Implementation"},{"location":"graph/dsu/#disjoint-set-data-structure","text":"Table of Contents Na\u00efve implementation of DSU APIs to support Union by rank optimization Some Problems on Leetcode that uses Disjoint Set Structure","title":"Disjoint Set Data Structure"},{"location":"graph/dsu/#naive-implementation-of-dsu","text":"One of the na\u00efve implementation for DSU is to use an array. Here for a Leetcode problem I've shown an implementation of DSU that do not use rank-path compression optimizations, just plain and simple implementation of DSU with array.","title":"Na\u00efve implementation of DSU"},{"location":"graph/dsu/#apis-to-support","text":"find(int i) to find the parent of some node i makeUnion(int i, int j) to create a union of two nodes i and j . The following is a simple implementation of DSU that implements the upper 2 APIs. class DSU { private : int size ; vector < int > dsuArray ; public : DSU ( int n ) { int size = n ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsuArray . push_back ( i ); } } vector < int > getArray () { return dsuArray ; } int find ( int n ) { return dsuArray [ n ]; } bool makeUnion ( int i , int j ) { int parent_i = find ( i ); int parent_j = find ( j ); if ( parent_i == parent_j ) return false ; // find all occurences of parent_j // set to parent_i to make the Union for ( int i = 1 ; i < dsuArray . size (); i ++ ) { if ( dsuArray [ i ] == parent_j ) { dsuArray [ i ] = parent_i ; } } return true ; } };","title":"APIs to support"},{"location":"graph/dsu/#union-by-rank-optimization","text":"If you see the makeUnion() API we are setting the parents of parent_j to parent_i . Now if the number of elements in the group of j is higher then there is a chance to optimize the time complexity. We can update the parent_i to parent_j as number of times parent_i is to be updated is much lower. This is called union by rank optimization . In order to do this we need to have some data structure that'll indicate the size of every group everytime we do an union. Then we can take the smaller group and updated its parents instead of updating the parent of the larger group size.","title":"Union by rank optimization"},{"location":"graph/dsu/#some-problems-on-leetcode-that-uses-disjoint-set-structure","text":"","title":"Some Problems on Leetcode that uses Disjoint Set Structure"},{"location":"graph/dsu/#redundant-connection","text":"","title":"Redundant Connection"},{"location":"graph/dsu/#problem-statement","text":"In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n , and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.","title":"Problem Statement"},{"location":"graph/dsu/#example","text":"Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output: [1,4]","title":"Example"},{"location":"graph/dsu/#approach","text":"We'll use a DSU to add the edges in the DSU until we get a cycle. When we get a cycle, we'll add it to the answer, this will be the edge that we need to return.","title":"Approach"},{"location":"graph/dsu/#code","text":"class DSU { private : int size ; vector < int > dsuArray ; public : DSU ( int n ) { int size = n ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsuArray . push_back ( i ); } } vector < int > getArray () { return dsuArray ; } int find ( int n ) { return dsuArray [ n ]; } bool makeUnion ( int i , int j ) { int parent_i = find ( i ); int parent_j = find ( j ); if ( parent_i == parent_j ) return false ; // find all occurences of parent_j // set to parent_i to make the Union for ( int i = 1 ; i < dsuArray . size (); i ++ ) { if ( dsuArray [ i ] == parent_j ) { dsuArray [ i ] = parent_i ; } } return true ; } }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { int maxim = INT_MIN ; for ( auto j : edges ) { maxim = std :: max ( j [ 0 ], maxim ); maxim = std :: max ( j [ 1 ], maxim ); } // number of nodes = maxim now. // now we create a DSU DSU dsu = DSU ( maxim ); vector < int > answer ; for ( auto edgePair : edges ) { int first = edgePair [ 0 ]; int second = edgePair [ 1 ]; bool possible = dsu . makeUnion ( edgePair [ 0 ], edgePair [ 1 ]); if ( not possible ) { answer . push_back ( edgePair [ 0 ]); answer . push_back ( edgePair [ 1 ]); } } return answer ; } };","title":"Code"},{"location":"graph/problems/","text":"Graph standard problems Questions Discussed Number of Islands Clone Graph Max Area of Island Pacific Atlantic Water Flow Surrounded Regions All Paths From Source to Target Course Schedule Number of Islands Find the problem on leetcode \\(\\to\\) Problem Statement Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1 Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3 Approach We'll use a simple DFS apporach to find the number of islands. The appoach is to when we touch a landmass, we'll mark all the connected landmass as '0' using DFS and increase the number of islands. Then travel through the space, until we find another landmass. This way only new landmasses are considered in the number of islands. Here is a code sample that uses DFS to find the number of islands. Code class Solution { private : void dfs ( vector < vector < char >> & grid , int i , int j , int r , int c ) { if ( i < 0 || i >= r || j < 0 || j >= c || grid [ i ][ j ] == '0' ) { // if the dfs subroutine goes out of bounds, // or we find water during the traversal to find landmasses // we return return ; } // if we find a grid[i][j] == \"1\" means this is a part of // the island so we set this position as \"0\" so that we // don't revisit this again grid [ i ][ j ] = '0' ; // run recursive dfs on all directions dfs ( grid , i -1 , j , r , c ); dfs ( grid , i + 1 , j , r , c ); dfs ( grid , i , j -1 , r , c ); dfs ( grid , i , j + 1 , r , c ); } public : int numIslands ( vector < vector < char >>& grid ) { int islandCount = 0 ; int rows = grid . size (); int cols = grid [ 0 ]. size (); for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( grid [ i ][ j ] == '1' ) { dfs ( grid , i , j , rows , cols ); islandCount ++ ; } } } return islandCount ; } }; Clone Graph Find the Problem on Leetcode \\(\\to\\) Problem Statement Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Approach We'll create a unordered_map to store the mapping between new and old nodes in the graph. Then we'll run a BFS algorithm on the graph to find new nodes and connect them to their corrospoding neighbors. The following is a working code example for this apporach. Code /* // Definition for a Node. class Node { public: int val; vector<Node*> neighbors; Node() { val = 0; neighbors = vector<Node*>(); } Node(int _val) { val = _val; neighbors = vector<Node*>(); } Node(int _val, vector<Node*> _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public : Node * cloneGraph ( Node * node ) { if ( not node ) return nullptr ; unordered_map < Node * , Node *> map ; // create a node corrospoding to the starting node map [ node ] = new Node ( node -> val ); queue < Node *> q ; q . push ( node ); while ( ! q . empty ()) { Node * current = q . front (); q . pop (); // for all neighbor of current check if we visited that or not? // if we don't visit we enter it in the map for ( auto nbr : current -> neighbors ) { if ( map . find ( nbr ) == map . end ()) { map [ nbr ] = new Node ( nbr -> val ); q . push ( nbr ); } // add the newly created neighbor on the map[current] neighbors map [ current ] -> neighbors . push_back ( map [ nbr ]); } } return map [ node ]; } }; Max Area of Island You are given an \\(M \\times N\\) binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return \\(0\\) . Examples Input: Upper image as a 2-d grid Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Approach We'll modify the previous problem Number of Islands to count the size of the island during the DFS instead of just doing nothing. This way we can find the size of the Islands during the DFS, we'll keep track of the max-size we've seen so far. Code class Solution { private : int dfs ( vector < vector < int >>& grid , int i , int j , int r , int c ) { if ( i < 0 or j < 0 or i >= r or j >= c or grid [ i ][ j ] == 0 ) { return 0 ; } grid [ i ][ j ] = 0 ; return 1 + dfs ( grid , i + 1 , j , r , c ) + dfs ( grid , i -1 , j , r , c ) + dfs ( grid , i , j + 1 , r , c ) + dfs ( grid , i , j - 1 , r , c ); } public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { int maxSize = 0 ; int numberOfIsland = 0 ; int rows = grid . size (); int cols = grid [ 0 ]. size (); for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( grid [ i ][ j ] == 1 ) { int size = dfs ( grid , i , j , rows , cols ); maxSize = std :: max ( maxSize , size ); numberOfIsland ++ ; } } } if ( numberOfIsland == 0 ) return 0 ; return maxSize ; } }; Pacific Atlantic Water Flow Find the problem on Leetcode \\(\\to\\) Problem Statement There is an \\(m \\times n\\) rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an \\(m \\times n\\) integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate \\((r, c)\\) . The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell \\((r_i, c_i)\\) to both the Pacific and Atlantic oceans. Example Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] Input: heights = [[2,1],[1,2]] Output: [[0,0],[0,1],[1,0],[1,1]] Approach We'll use DFS to solve this problem with a reverse approach. First instead of searching from where the water can flow to ocean we'll check from ocean what is the reverse of the path through which the water is flowing. Naturally water flows from top height to bottom height, here we'll do the opposite where we'll check if the neighbors height is greater than the current height we'll travel (because we're searching the reverse of the waterflow's path), Now all columns of row \\(0\\) and all the rows of column \\(0\\) has the pacific water, we'll draw a DFS to find where the water can go using our customized DFS algorithm. Similarly we'll do this for the atlantic ocean. Now we'll check where the water from both can reach, we'll return that in the answers array. Code class Solution { private : vector < vector < int >> flowCoordinates ; void dfs ( vector < vector < int >>& heights , vector < vector < bool >> & visited , int i , int j , int r , int c ) { visited [ i ][ j ] = true ; if ( i > 0 and not visited [ i -1 ][ j ] and heights [ i ][ j ] <= heights [ i -1 ][ j ]) { dfs ( heights , visited , i -1 , j , r , c ); } if ( i < r -1 and not visited [ i + 1 ][ j ] and heights [ i ][ j ] <= heights [ i + 1 ][ j ]) { dfs ( heights , visited , i + 1 , j , r , c ); } if ( j > 0 and heights [ i ][ j ] <= heights [ i ][ j -1 ] and not visited [ i ][ j -1 ]) { dfs ( heights , visited , i , j -1 , r , c ); } if ( j < c -1 and heights [ i ][ j ] <= heights [ i ][ j + 1 ] and not visited [ i ][ j + 1 ]) { dfs ( heights , visited , i , j + 1 , r , c ); } } public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& heights ) { int rows = heights . size (); int cols = heights [ 0 ]. size (); vector < vector < bool >> pacific ( rows , vector < bool > ( cols )); vector < vector < bool >> atlantic ( rows , vector < bool > ( cols )); for ( int i = 0 ; i < rows ; i ++ ) { dfs ( heights , pacific , i , 0 , rows , cols ); dfs ( heights , atlantic , i , cols -1 , rows , cols ); } for ( int i = 0 ; i < cols ; i ++ ) { dfs ( heights , pacific , 0 , i , rows , cols ); dfs ( heights , atlantic , rows -1 , i , rows , cols ); } // now check for some (i, j) both pacific and altantic shows true for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( pacific [ i ][ j ] and atlantic [ i ][ j ]) { flowCoordinates . push_back ({ i , j }); } } } return flowCoordinates ; } }; Surrounded Regions Find the problem on Leetcode \\(\\to\\) Problem Statement Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Approach We'll use the approach from the previous problem. We'll do a quick reverse thinking, see we should not capture regions that are on the border so what we'll do is use a DFS to quickly capture the regions that surrounds the border with some other alphabet \"N\" let's say. These can be achieved by running DFS on the \"O\" at the row \\(0\\) , last row and column \\(0\\) and at the last column . So we'll run dfs at all the positions of \"O\" at the boundaries, then we'll capture all the regions that are left out \"not in the border\" . Then we'll convert the \"N\"s into \"O\"s. Code class Solution { private : void dfs ( vector < vector < char >>& board , int i , int j , int r , int c ) { board [ i ][ j ] = 'N' ; if ( i > 0 and board [ i -1 ][ j ] == 'O' ) { dfs ( board , i -1 , j , r , c ); } if ( i < r -1 and board [ i + 1 ][ j ] == 'O' ) { dfs ( board , i + 1 , j , r , c ); } if ( j > 0 and board [ i ][ j -1 ] == 'O' ) { dfs ( board , i , j -1 , r , c ); } if ( j < c -1 and board [ i ][ j + 1 ] == 'O' ) { dfs ( board , i , j + 1 , r , c ); } } public : void solve ( vector < vector < char >>& board ) { // capture everything except an unsurrounded region // if some O is there at the row 0, n-1 and col 0, n-1 // we'll not be able to capture it. // run a dfs on each of the area in row 0, n-1 and col 0, n-1 // to not capture it and marking it as N int rows = board . size (); int cols = board [ 0 ]. size (); // vector<vector<bool>> visited(rows, vector<bool>(cols)); // run dfs at all the positions of O at the boundaries // col wise for ( int i = 0 ; i < rows ; i ++ ) { // 0th column if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , i , 0 , rows , cols ); } // cols-1th column if ( board [ i ][ cols -1 ] == 'O' ) { dfs ( board , i , cols -1 , rows , cols ); } } // run row wise at col = 0 and rows-1 for ( int j = 1 ; j < cols -1 ; j ++ ) { // 1st row because 0,0 is already done if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , 0 , j , rows , cols ); } if ( board [ rows -1 ][ j ] == 'O' ) { dfs ( board , rows -1 , j , rows , cols ); } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( board [ i ][ j ] == 'O' ) board [ i ][ j ] = 'X' ; if ( board [ i ][ j ] == 'N' ) board [ i ][ j ] = 'O' ; } } } }; All Paths From Source to Target Find the Problem on Leetcode \\(\\to\\) Problem Statement Given a directed acyclic graph (DAG) of n nodes labeled from \\(0\\) to node \\(n - 1\\) , find all possible paths from node \\(0\\) to node \\(n - 1\\) and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j] ). Examples Input: graph = [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3. Input: graph = [[4,3,1],[3,2,4],[3],[4],[]] Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] Approach We'll do a DFS approach, instead of putting the path into the answer when we reach the last node to be reachable we'll put the path when we visit \\(n-1^{th}\\) node because in the question we are asked to find all path from node \\(0\\) to node \\(n - 1\\) . Our approach will find all the possible path via DFS recursions. In order to store the path information we'll add an array called lvl that is copied and shared to the next recursion level. So for each recursion calls we'll maintain a of the path visited so far called lvl that'll be passed to the next level. That is how we'll maintain the path information. At the end we'll return all the paths recorded during the recursion run. Code class Solution { private : set < vector < int >> s ; void dfs ( vector < vector < int >>& graph , vector < int > lvl , int index ) { if ( index > graph . size () - 1 ) return ; // stop dfs once there is no where to go if ( index == graph . size () - 1 ) { // return once reached the final destination // final destination is always the n-1 vertex according to the question lvl . push_back ( index ); // final destination added s . insert ( lvl ); // add this path to the answer set (set for uniqueness) return ; } lvl . push_back ( index ); for ( int i = 0 ; i < graph [ index ]. size (); i ++ ) { // no cycle so should not care about the already visited part int nbr = graph [ index ][ i ]; dfs ( graph , lvl , nbr ); } } public : vector < vector < int >> allPathsSourceTarget ( vector < vector < int >>& graph ) { vector < int > lvl ; dfs ( graph , lvl , 0 ); // add the final destination to all the paths vector < vector < int >> answer ; answer . assign ( s . begin (), s . end ()); return answer ; } }; Course Schedule Find the problem on Leetcode \\(\\to\\) Problem Statement There are a total of numCourses courses you have to take, labeled from \\(0\\) to \\(\\text{numCourses} - 1\\) . You are given an array prerequisites where prerequisites[i] = ( \\(a_i, b_i\\) ) indicates that you must take course \\(b_i\\) first if you want to take course \\(a_i\\) . For example, the pair ( \\(0,1\\) ) indicates that to take course \\(0\\) you have to first take course \\(1\\) . Return true if you can finish all courses. Otherwise, return false. Approach If you look carefully it is a problem of finding cycle in a graph or finding the topological sort of the graph. If the graph is a DAG then only all the courses can be completed. If there is a cycle in the graph then to take course \\(a\\) you have to take \\(b\\) and to take \\(b\\) you have to take \\(a\\) , which is not possible. So we have to find a cycle in the graph if we find a cycle then the course are not possible to complete. Now in order to find the cycle in the graph we can use DFS by coloring the vertices. Following is a efficient implementation of DFS and cycle finding algorithm along with a custom definition for graph and solution to the leetcode problem. Examples Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Code enum class Color { black , red , grey }; class Graph { private : vector < vector < int >> adj_list ; int graph_size ; bool has_cycle = false ; public : Graph ( int V ) { graph_size = V ; for ( int i = 0 ; i < V ; i ++ ) { vector < int > v ; adj_list . push_back ( v ); } } void add_edge ( int source , int destination ) { // directed edge only adj_list [ source ]. push_back ( destination ); } void dfsSubRoutine ( unordered_map < int , Color >& color , int nodeID ) { // do coloring of the edges // color grey means not visited // color red means visited and not fully explored // color black means visited and fully explored if ( color [ nodeID ] == Color :: red ) { has_cycle = true ; return ; } else if ( color [ nodeID ] == Color :: grey ){ color [ nodeID ] = Color :: red ; for ( int nbr : adj_list [ nodeID ]) { dfsSubRoutine ( color , nbr ); } } color [ nodeID ] = Color :: black ; return ; } bool hasCycle () { // run a DFS algorithm and check if there is a cycle or not? // check if some node is previously visited or not? // if some neighbor is neighbor previously visited // then return true; // means there is cycle unordered_map < int , Color > color ; for ( int i = 0 ; i < graph_size ; i ++ ) color [ i ] = Color :: grey ; for ( int i = 0 ; i < graph_size ; i ++ ) { // for all component of the graph run the subroutine if ( color [ i ] == Color :: grey ) dfsSubRoutine ( color , i ); } return has_cycle ; } }; class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { // courseID = {0 .. n-1} // preReq[i] = {to Take i, must have taken j} // na\u00efve cycle detection // if the graph is a DAG then only a solution is possible but otherwise // for any cycle if you have to take a then take b // if you have to take b then before you take a Graph g = Graph ( numCourses ); for ( auto courses : prerequisites ) { g . add_edge ( courses [ 1 ], courses [ 0 ]); } return not g . hasCycle (); } };","title":"Graph Problems"},{"location":"graph/problems/#graph-standard-problems","text":"Questions Discussed Number of Islands Clone Graph Max Area of Island Pacific Atlantic Water Flow Surrounded Regions All Paths From Source to Target Course Schedule","title":"Graph standard problems"},{"location":"graph/problems/#number-of-islands","text":"Find the problem on leetcode \\(\\to\\)","title":"Number of Islands"},{"location":"graph/problems/#problem-statement","text":"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.","title":"Problem Statement"},{"location":"graph/problems/#example","text":"Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1 Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3","title":"Example"},{"location":"graph/problems/#approach","text":"We'll use a simple DFS apporach to find the number of islands. The appoach is to when we touch a landmass, we'll mark all the connected landmass as '0' using DFS and increase the number of islands. Then travel through the space, until we find another landmass. This way only new landmasses are considered in the number of islands. Here is a code sample that uses DFS to find the number of islands.","title":"Approach"},{"location":"graph/problems/#code","text":"class Solution { private : void dfs ( vector < vector < char >> & grid , int i , int j , int r , int c ) { if ( i < 0 || i >= r || j < 0 || j >= c || grid [ i ][ j ] == '0' ) { // if the dfs subroutine goes out of bounds, // or we find water during the traversal to find landmasses // we return return ; } // if we find a grid[i][j] == \"1\" means this is a part of // the island so we set this position as \"0\" so that we // don't revisit this again grid [ i ][ j ] = '0' ; // run recursive dfs on all directions dfs ( grid , i -1 , j , r , c ); dfs ( grid , i + 1 , j , r , c ); dfs ( grid , i , j -1 , r , c ); dfs ( grid , i , j + 1 , r , c ); } public : int numIslands ( vector < vector < char >>& grid ) { int islandCount = 0 ; int rows = grid . size (); int cols = grid [ 0 ]. size (); for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( grid [ i ][ j ] == '1' ) { dfs ( grid , i , j , rows , cols ); islandCount ++ ; } } } return islandCount ; } };","title":"Code"},{"location":"graph/problems/#clone-graph","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Clone Graph"},{"location":"graph/problems/#problem-statement_1","text":"Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.","title":"Problem Statement"},{"location":"graph/problems/#approach_1","text":"We'll create a unordered_map to store the mapping between new and old nodes in the graph. Then we'll run a BFS algorithm on the graph to find new nodes and connect them to their corrospoding neighbors. The following is a working code example for this apporach.","title":"Approach"},{"location":"graph/problems/#code_1","text":"/* // Definition for a Node. class Node { public: int val; vector<Node*> neighbors; Node() { val = 0; neighbors = vector<Node*>(); } Node(int _val) { val = _val; neighbors = vector<Node*>(); } Node(int _val, vector<Node*> _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public : Node * cloneGraph ( Node * node ) { if ( not node ) return nullptr ; unordered_map < Node * , Node *> map ; // create a node corrospoding to the starting node map [ node ] = new Node ( node -> val ); queue < Node *> q ; q . push ( node ); while ( ! q . empty ()) { Node * current = q . front (); q . pop (); // for all neighbor of current check if we visited that or not? // if we don't visit we enter it in the map for ( auto nbr : current -> neighbors ) { if ( map . find ( nbr ) == map . end ()) { map [ nbr ] = new Node ( nbr -> val ); q . push ( nbr ); } // add the newly created neighbor on the map[current] neighbors map [ current ] -> neighbors . push_back ( map [ nbr ]); } } return map [ node ]; } };","title":"Code"},{"location":"graph/problems/#max-area-of-island","text":"You are given an \\(M \\times N\\) binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return \\(0\\) .","title":"Max Area of Island"},{"location":"graph/problems/#examples","text":"Input: Upper image as a 2-d grid Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0","title":"Examples"},{"location":"graph/problems/#approach_2","text":"We'll modify the previous problem Number of Islands to count the size of the island during the DFS instead of just doing nothing. This way we can find the size of the Islands during the DFS, we'll keep track of the max-size we've seen so far.","title":"Approach"},{"location":"graph/problems/#code_2","text":"class Solution { private : int dfs ( vector < vector < int >>& grid , int i , int j , int r , int c ) { if ( i < 0 or j < 0 or i >= r or j >= c or grid [ i ][ j ] == 0 ) { return 0 ; } grid [ i ][ j ] = 0 ; return 1 + dfs ( grid , i + 1 , j , r , c ) + dfs ( grid , i -1 , j , r , c ) + dfs ( grid , i , j + 1 , r , c ) + dfs ( grid , i , j - 1 , r , c ); } public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { int maxSize = 0 ; int numberOfIsland = 0 ; int rows = grid . size (); int cols = grid [ 0 ]. size (); for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( grid [ i ][ j ] == 1 ) { int size = dfs ( grid , i , j , rows , cols ); maxSize = std :: max ( maxSize , size ); numberOfIsland ++ ; } } } if ( numberOfIsland == 0 ) return 0 ; return maxSize ; } };","title":"Code"},{"location":"graph/problems/#pacific-atlantic-water-flow","text":"Find the problem on Leetcode \\(\\to\\)","title":"Pacific Atlantic Water Flow"},{"location":"graph/problems/#problem-statement_2","text":"There is an \\(m \\times n\\) rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an \\(m \\times n\\) integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate \\((r, c)\\) . The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell \\((r_i, c_i)\\) to both the Pacific and Atlantic oceans.","title":"Problem Statement"},{"location":"graph/problems/#example_1","text":"Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] Input: heights = [[2,1],[1,2]] Output: [[0,0],[0,1],[1,0],[1,1]]","title":"Example"},{"location":"graph/problems/#approach_3","text":"We'll use DFS to solve this problem with a reverse approach. First instead of searching from where the water can flow to ocean we'll check from ocean what is the reverse of the path through which the water is flowing. Naturally water flows from top height to bottom height, here we'll do the opposite where we'll check if the neighbors height is greater than the current height we'll travel (because we're searching the reverse of the waterflow's path), Now all columns of row \\(0\\) and all the rows of column \\(0\\) has the pacific water, we'll draw a DFS to find where the water can go using our customized DFS algorithm. Similarly we'll do this for the atlantic ocean. Now we'll check where the water from both can reach, we'll return that in the answers array.","title":"Approach"},{"location":"graph/problems/#code_3","text":"class Solution { private : vector < vector < int >> flowCoordinates ; void dfs ( vector < vector < int >>& heights , vector < vector < bool >> & visited , int i , int j , int r , int c ) { visited [ i ][ j ] = true ; if ( i > 0 and not visited [ i -1 ][ j ] and heights [ i ][ j ] <= heights [ i -1 ][ j ]) { dfs ( heights , visited , i -1 , j , r , c ); } if ( i < r -1 and not visited [ i + 1 ][ j ] and heights [ i ][ j ] <= heights [ i + 1 ][ j ]) { dfs ( heights , visited , i + 1 , j , r , c ); } if ( j > 0 and heights [ i ][ j ] <= heights [ i ][ j -1 ] and not visited [ i ][ j -1 ]) { dfs ( heights , visited , i , j -1 , r , c ); } if ( j < c -1 and heights [ i ][ j ] <= heights [ i ][ j + 1 ] and not visited [ i ][ j + 1 ]) { dfs ( heights , visited , i , j + 1 , r , c ); } } public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& heights ) { int rows = heights . size (); int cols = heights [ 0 ]. size (); vector < vector < bool >> pacific ( rows , vector < bool > ( cols )); vector < vector < bool >> atlantic ( rows , vector < bool > ( cols )); for ( int i = 0 ; i < rows ; i ++ ) { dfs ( heights , pacific , i , 0 , rows , cols ); dfs ( heights , atlantic , i , cols -1 , rows , cols ); } for ( int i = 0 ; i < cols ; i ++ ) { dfs ( heights , pacific , 0 , i , rows , cols ); dfs ( heights , atlantic , rows -1 , i , rows , cols ); } // now check for some (i, j) both pacific and altantic shows true for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( pacific [ i ][ j ] and atlantic [ i ][ j ]) { flowCoordinates . push_back ({ i , j }); } } } return flowCoordinates ; } };","title":"Code"},{"location":"graph/problems/#surrounded-regions","text":"Find the problem on Leetcode \\(\\to\\)","title":"Surrounded Regions"},{"location":"graph/problems/#problem-statement_3","text":"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.","title":"Problem Statement"},{"location":"graph/problems/#example_2","text":"Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.","title":"Example"},{"location":"graph/problems/#approach_4","text":"We'll use the approach from the previous problem. We'll do a quick reverse thinking, see we should not capture regions that are on the border so what we'll do is use a DFS to quickly capture the regions that surrounds the border with some other alphabet \"N\" let's say. These can be achieved by running DFS on the \"O\" at the row \\(0\\) , last row and column \\(0\\) and at the last column . So we'll run dfs at all the positions of \"O\" at the boundaries, then we'll capture all the regions that are left out \"not in the border\" . Then we'll convert the \"N\"s into \"O\"s.","title":"Approach"},{"location":"graph/problems/#code_4","text":"class Solution { private : void dfs ( vector < vector < char >>& board , int i , int j , int r , int c ) { board [ i ][ j ] = 'N' ; if ( i > 0 and board [ i -1 ][ j ] == 'O' ) { dfs ( board , i -1 , j , r , c ); } if ( i < r -1 and board [ i + 1 ][ j ] == 'O' ) { dfs ( board , i + 1 , j , r , c ); } if ( j > 0 and board [ i ][ j -1 ] == 'O' ) { dfs ( board , i , j -1 , r , c ); } if ( j < c -1 and board [ i ][ j + 1 ] == 'O' ) { dfs ( board , i , j + 1 , r , c ); } } public : void solve ( vector < vector < char >>& board ) { // capture everything except an unsurrounded region // if some O is there at the row 0, n-1 and col 0, n-1 // we'll not be able to capture it. // run a dfs on each of the area in row 0, n-1 and col 0, n-1 // to not capture it and marking it as N int rows = board . size (); int cols = board [ 0 ]. size (); // vector<vector<bool>> visited(rows, vector<bool>(cols)); // run dfs at all the positions of O at the boundaries // col wise for ( int i = 0 ; i < rows ; i ++ ) { // 0th column if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , i , 0 , rows , cols ); } // cols-1th column if ( board [ i ][ cols -1 ] == 'O' ) { dfs ( board , i , cols -1 , rows , cols ); } } // run row wise at col = 0 and rows-1 for ( int j = 1 ; j < cols -1 ; j ++ ) { // 1st row because 0,0 is already done if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , 0 , j , rows , cols ); } if ( board [ rows -1 ][ j ] == 'O' ) { dfs ( board , rows -1 , j , rows , cols ); } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( board [ i ][ j ] == 'O' ) board [ i ][ j ] = 'X' ; if ( board [ i ][ j ] == 'N' ) board [ i ][ j ] = 'O' ; } } } };","title":"Code"},{"location":"graph/problems/#all-paths-from-source-to-target","text":"Find the Problem on Leetcode \\(\\to\\)","title":"All Paths From Source to Target"},{"location":"graph/problems/#problem-statement_4","text":"Given a directed acyclic graph (DAG) of n nodes labeled from \\(0\\) to node \\(n - 1\\) , find all possible paths from node \\(0\\) to node \\(n - 1\\) and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j] ).","title":"Problem Statement"},{"location":"graph/problems/#examples_1","text":"Input: graph = [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3. Input: graph = [[4,3,1],[3,2,4],[3],[4],[]] Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]","title":"Examples"},{"location":"graph/problems/#approach_5","text":"We'll do a DFS approach, instead of putting the path into the answer when we reach the last node to be reachable we'll put the path when we visit \\(n-1^{th}\\) node because in the question we are asked to find all path from node \\(0\\) to node \\(n - 1\\) . Our approach will find all the possible path via DFS recursions. In order to store the path information we'll add an array called lvl that is copied and shared to the next recursion level. So for each recursion calls we'll maintain a of the path visited so far called lvl that'll be passed to the next level. That is how we'll maintain the path information. At the end we'll return all the paths recorded during the recursion run.","title":"Approach"},{"location":"graph/problems/#code_5","text":"class Solution { private : set < vector < int >> s ; void dfs ( vector < vector < int >>& graph , vector < int > lvl , int index ) { if ( index > graph . size () - 1 ) return ; // stop dfs once there is no where to go if ( index == graph . size () - 1 ) { // return once reached the final destination // final destination is always the n-1 vertex according to the question lvl . push_back ( index ); // final destination added s . insert ( lvl ); // add this path to the answer set (set for uniqueness) return ; } lvl . push_back ( index ); for ( int i = 0 ; i < graph [ index ]. size (); i ++ ) { // no cycle so should not care about the already visited part int nbr = graph [ index ][ i ]; dfs ( graph , lvl , nbr ); } } public : vector < vector < int >> allPathsSourceTarget ( vector < vector < int >>& graph ) { vector < int > lvl ; dfs ( graph , lvl , 0 ); // add the final destination to all the paths vector < vector < int >> answer ; answer . assign ( s . begin (), s . end ()); return answer ; } };","title":"Code"},{"location":"graph/problems/#course-schedule","text":"Find the problem on Leetcode \\(\\to\\)","title":"Course Schedule"},{"location":"graph/problems/#problem-statement_5","text":"There are a total of numCourses courses you have to take, labeled from \\(0\\) to \\(\\text{numCourses} - 1\\) . You are given an array prerequisites where prerequisites[i] = ( \\(a_i, b_i\\) ) indicates that you must take course \\(b_i\\) first if you want to take course \\(a_i\\) . For example, the pair ( \\(0,1\\) ) indicates that to take course \\(0\\) you have to first take course \\(1\\) . Return true if you can finish all courses. Otherwise, return false.","title":"Problem Statement"},{"location":"graph/problems/#approach_6","text":"If you look carefully it is a problem of finding cycle in a graph or finding the topological sort of the graph. If the graph is a DAG then only all the courses can be completed. If there is a cycle in the graph then to take course \\(a\\) you have to take \\(b\\) and to take \\(b\\) you have to take \\(a\\) , which is not possible. So we have to find a cycle in the graph if we find a cycle then the course are not possible to complete. Now in order to find the cycle in the graph we can use DFS by coloring the vertices. Following is a efficient implementation of DFS and cycle finding algorithm along with a custom definition for graph and solution to the leetcode problem.","title":"Approach"},{"location":"graph/problems/#examples_2","text":"Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.","title":"Examples"},{"location":"graph/problems/#code_6","text":"enum class Color { black , red , grey }; class Graph { private : vector < vector < int >> adj_list ; int graph_size ; bool has_cycle = false ; public : Graph ( int V ) { graph_size = V ; for ( int i = 0 ; i < V ; i ++ ) { vector < int > v ; adj_list . push_back ( v ); } } void add_edge ( int source , int destination ) { // directed edge only adj_list [ source ]. push_back ( destination ); } void dfsSubRoutine ( unordered_map < int , Color >& color , int nodeID ) { // do coloring of the edges // color grey means not visited // color red means visited and not fully explored // color black means visited and fully explored if ( color [ nodeID ] == Color :: red ) { has_cycle = true ; return ; } else if ( color [ nodeID ] == Color :: grey ){ color [ nodeID ] = Color :: red ; for ( int nbr : adj_list [ nodeID ]) { dfsSubRoutine ( color , nbr ); } } color [ nodeID ] = Color :: black ; return ; } bool hasCycle () { // run a DFS algorithm and check if there is a cycle or not? // check if some node is previously visited or not? // if some neighbor is neighbor previously visited // then return true; // means there is cycle unordered_map < int , Color > color ; for ( int i = 0 ; i < graph_size ; i ++ ) color [ i ] = Color :: grey ; for ( int i = 0 ; i < graph_size ; i ++ ) { // for all component of the graph run the subroutine if ( color [ i ] == Color :: grey ) dfsSubRoutine ( color , i ); } return has_cycle ; } }; class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { // courseID = {0 .. n-1} // preReq[i] = {to Take i, must have taken j} // na\u00efve cycle detection // if the graph is a DAG then only a solution is possible but otherwise // for any cycle if you have to take a then take b // if you have to take b then before you take a Graph g = Graph ( numCourses ); for ( auto courses : prerequisites ) { g . add_edge ( courses [ 1 ], courses [ 0 ]); } return not g . hasCycle (); } };","title":"Code"},{"location":"graph/standard-problems/","text":"More Graph Problems Cycle Detection in Undirected Graph Using simple traversal techniques we can detect cycles in undirected graphs. Here first we'll implement this using breath first search then we'll also show how to do this using depth first search. // UNDIRECTED GRAPH DEFINITION class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ) { for ( auto i : vertexSet ) { forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_edge ( char from , char to ) { // undirected graph adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } unordered_map < char , forward_list < char >> view () { return adj_list ; } }; Approach using breath first search The apporach is very simple, if during traversal if you find any one of the neighbor of some vertex previously visited other than the immediate parent/neighbor means there is a cycle. So put the vertex and it's immediate parent inside a Queue (to run BFS). bool CYCLE_DETECTABLE_SEARCH ( Graph & g , char startingVertex ) { // For BFS we need a queue and this queue has vertex and it's // immediate parent as a pair<char, char> queue < pair < char , char >> q ; unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; // for starting vertex parent = 'N' for NULL; q . push ({ startingVertex , 'N' }); visited [ startingVertex ] = true ; while ( ! q . empty ()) { pair < char , char > front = q . front (); q . pop (); char thisvertex = front . first ; char parent = front . second ; // for all the neighbors for thisvertex insert into queue // mark thisvertex as their immediate parents // if we see some visited vertex other than it's immediate neighbor/parent // return true for ( char nbr : graphView [ thisvertex ]) { if ( visited [ nbr ] == false ) { visited [ nbr ] = true ; q . push ({ nbr , thisvertex }); } else if ( visited [ nbr ] == true and nbr != parent ) { // this neighbor of the vertex is already visited // and this neighbor is not the immediate parent // meaning there must be a cycle. return true ; } } } return false ; } bool hasCycle ( Graph & g ) { // assuming multiple connected components are there unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; bool hasCycleForThisComponent ; for ( auto vertex : graphView ) { if ( ! visited [ vertex . first ]) { hasCycleForThisComponent = CYCLE_DETECTABLE_SEARCH ( g , vertex . first ); } if ( hasCycleForThisComponent ) { return true ; } } return false ; } Bipartite Graph Check Problem Statement Given a graph G find out if this is a bipartite graph? For a bipartite graph, the graph has 2 set of vertices, in each set vertices are not connected to each other. Approach Bi-partite graph is a 2 colorable graph, one approach could be if we check a graph if it's 2 colorable then it's bipartite. Bipartite is equivalent to 2-colorable. Here we'll traverse through the graph and color every vertex. Now if we find some vertex that takes other than the 2 color considered first we'll say it is not bipartite. Else if the entire graph is 2 colorable then we'll return true. Also we can approach this problem as this \\(\\to\\) any odd length cycle containing graph is not a bipartite graph. // Any 2 Colorable graph is a bipartite graph Approach is much simpler to go through. enum class Color { black , red , gray }; // gray is to indicate that the vertex is not visted yet bool isBipartite ( Graph & g ) { // set all the graph vertex color as gray auto graph = g . view (); unordered_map < char , Color > color ; for ( auto vertex : graph ) { color [ vertex . first ] = Color :: gray ; } // set a starting index where to start the journey char startingVertex = graph . begin () -> first ; // create a queue for bfs queue < char > q ; q . push ( startingVertex ); color [ startingVertex ] = Color :: red ; // run a bfs while ( ! q . empty ()) { char thisvertex = q . front (); q . pop (); for ( char nbr : graph [ thisvertex ]) { if ( color [ nbr ] == Color :: gray ) { // if not visited then only process if ( color [ thisvertex ] == Color :: red ) { color [ nbr ] = Color :: black ; } else if ( color [ thisvertex ] == Color :: black ) { color [ nbr ] = Color :: red ; } // push into the queue for bfs q . push ( nbr ); } else { // check for termination condition if ( color [ nbr ] == color [ thisvertex ]) { return false ; } } } } return true ; } Directed Graph Problems In this section the given graph has directed edges, below are some standard directed graph problems that is the building block for many other graph problems in general. Topological Sort Problem Cycle Detection Strongly connected components (Kosaraju's algorithm). Topological Sorting of a Directed graph Problem Statement Topological sorting for Directed Acyclic Graph is a linear ordering of vertices such that for every directed \\((u, v) \\in \\mathbf{V}\\) , \\(u\\) comes before \\(v\\) . In other words in order to reach \\(v\\) you must go through \\(u\\) . Approach In order to start our topological sorting we must indentify a node that has no dependencies. We'll start from one of such nodes. This can be automated with the algorithm or can be relied on the user to give as an input. In this implementation we'll assume no such event. User will only give the Graph G and we'll find some node to start on on our own. // Directed Graph Varient #include <iostream> #include <unordered_map> #include <forward_list> #include <vector> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ){ for ( auto i : vertexSet ){ forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_directed_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); } unordered_map < char , forward_list < char >> view (){ return adj_list ; } }; Minimum spanning tree problem Minimum Cost to Connect all the points we are given an array points representing integer coordinates of some points on a 2D-plane, where \\(\\text{points[i]} = (x_i,y_i)\\) . The cost of connecting two points \\((x_i,y_i)\\) and \\((x_j,y_j)\\) is the manhattan distance between them: \\(\\lvert x_i - x_j \\rvert + \\lvert y_i - y_j \\rvert\\) . Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.","title":"Graph Standard Problems"},{"location":"graph/standard-problems/#more-graph-problems","text":"","title":"More Graph Problems"},{"location":"graph/standard-problems/#cycle-detection-in-undirected-graph","text":"Using simple traversal techniques we can detect cycles in undirected graphs. Here first we'll implement this using breath first search then we'll also show how to do this using depth first search. // UNDIRECTED GRAPH DEFINITION class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ) { for ( auto i : vertexSet ) { forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_edge ( char from , char to ) { // undirected graph adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } unordered_map < char , forward_list < char >> view () { return adj_list ; } };","title":"Cycle Detection in Undirected Graph"},{"location":"graph/standard-problems/#approach-using-breath-first-search","text":"The apporach is very simple, if during traversal if you find any one of the neighbor of some vertex previously visited other than the immediate parent/neighbor means there is a cycle. So put the vertex and it's immediate parent inside a Queue (to run BFS). bool CYCLE_DETECTABLE_SEARCH ( Graph & g , char startingVertex ) { // For BFS we need a queue and this queue has vertex and it's // immediate parent as a pair<char, char> queue < pair < char , char >> q ; unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; // for starting vertex parent = 'N' for NULL; q . push ({ startingVertex , 'N' }); visited [ startingVertex ] = true ; while ( ! q . empty ()) { pair < char , char > front = q . front (); q . pop (); char thisvertex = front . first ; char parent = front . second ; // for all the neighbors for thisvertex insert into queue // mark thisvertex as their immediate parents // if we see some visited vertex other than it's immediate neighbor/parent // return true for ( char nbr : graphView [ thisvertex ]) { if ( visited [ nbr ] == false ) { visited [ nbr ] = true ; q . push ({ nbr , thisvertex }); } else if ( visited [ nbr ] == true and nbr != parent ) { // this neighbor of the vertex is already visited // and this neighbor is not the immediate parent // meaning there must be a cycle. return true ; } } } return false ; } bool hasCycle ( Graph & g ) { // assuming multiple connected components are there unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; bool hasCycleForThisComponent ; for ( auto vertex : graphView ) { if ( ! visited [ vertex . first ]) { hasCycleForThisComponent = CYCLE_DETECTABLE_SEARCH ( g , vertex . first ); } if ( hasCycleForThisComponent ) { return true ; } } return false ; }","title":"Approach using breath first search"},{"location":"graph/standard-problems/#bipartite-graph-check","text":"","title":"Bipartite Graph Check"},{"location":"graph/standard-problems/#problem-statement","text":"Given a graph G find out if this is a bipartite graph? For a bipartite graph, the graph has 2 set of vertices, in each set vertices are not connected to each other.","title":"Problem Statement"},{"location":"graph/standard-problems/#approach","text":"Bi-partite graph is a 2 colorable graph, one approach could be if we check a graph if it's 2 colorable then it's bipartite. Bipartite is equivalent to 2-colorable. Here we'll traverse through the graph and color every vertex. Now if we find some vertex that takes other than the 2 color considered first we'll say it is not bipartite. Else if the entire graph is 2 colorable then we'll return true. Also we can approach this problem as this \\(\\to\\) any odd length cycle containing graph is not a bipartite graph. // Any 2 Colorable graph is a bipartite graph Approach is much simpler to go through. enum class Color { black , red , gray }; // gray is to indicate that the vertex is not visted yet bool isBipartite ( Graph & g ) { // set all the graph vertex color as gray auto graph = g . view (); unordered_map < char , Color > color ; for ( auto vertex : graph ) { color [ vertex . first ] = Color :: gray ; } // set a starting index where to start the journey char startingVertex = graph . begin () -> first ; // create a queue for bfs queue < char > q ; q . push ( startingVertex ); color [ startingVertex ] = Color :: red ; // run a bfs while ( ! q . empty ()) { char thisvertex = q . front (); q . pop (); for ( char nbr : graph [ thisvertex ]) { if ( color [ nbr ] == Color :: gray ) { // if not visited then only process if ( color [ thisvertex ] == Color :: red ) { color [ nbr ] = Color :: black ; } else if ( color [ thisvertex ] == Color :: black ) { color [ nbr ] = Color :: red ; } // push into the queue for bfs q . push ( nbr ); } else { // check for termination condition if ( color [ nbr ] == color [ thisvertex ]) { return false ; } } } } return true ; }","title":"Approach"},{"location":"graph/standard-problems/#directed-graph-problems","text":"In this section the given graph has directed edges, below are some standard directed graph problems that is the building block for many other graph problems in general. Topological Sort Problem Cycle Detection Strongly connected components (Kosaraju's algorithm).","title":"Directed Graph Problems"},{"location":"graph/standard-problems/#topological-sorting-of-a-directed-graph","text":"","title":"Topological Sorting of a Directed graph"},{"location":"graph/standard-problems/#problem-statement_1","text":"Topological sorting for Directed Acyclic Graph is a linear ordering of vertices such that for every directed \\((u, v) \\in \\mathbf{V}\\) , \\(u\\) comes before \\(v\\) . In other words in order to reach \\(v\\) you must go through \\(u\\) .","title":"Problem Statement"},{"location":"graph/standard-problems/#approach_1","text":"In order to start our topological sorting we must indentify a node that has no dependencies. We'll start from one of such nodes. This can be automated with the algorithm or can be relied on the user to give as an input. In this implementation we'll assume no such event. User will only give the Graph G and we'll find some node to start on on our own. // Directed Graph Varient #include <iostream> #include <unordered_map> #include <forward_list> #include <vector> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ){ for ( auto i : vertexSet ){ forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_directed_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); } unordered_map < char , forward_list < char >> view (){ return adj_list ; } };","title":"Approach"},{"location":"graph/standard-problems/#minimum-spanning-tree-problem","text":"","title":"Minimum spanning tree problem"},{"location":"graph/standard-problems/#minimum-cost-to-connect-all-the-points","text":"we are given an array points representing integer coordinates of some points on a 2D-plane, where \\(\\text{points[i]} = (x_i,y_i)\\) . The cost of connecting two points \\((x_i,y_i)\\) and \\((x_j,y_j)\\) is the manhattan distance between them: \\(\\lvert x_i - x_j \\rvert + \\lvert y_i - y_j \\rvert\\) . Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.","title":"Minimum Cost to Connect all the points"},{"location":"graph/usage/","text":"Graphs The graph is one of the most common and important data structures. With C++ and STL I'll show you the best possible implementation for the graph that you'll be able to implement and analyze in your code at FAANG interviews within the time constraints. Graph Adjacency List vs Adjacency Matrix Most of cases the List representation is good enough, if the graph is sparse then it will take less space, and if the graph is dense you should use the adjacency matrix representation. In my opinion any graph with less than 70% of the all possible edges : \\(\\text{Count(E)} \\geq 0.7 * {n \\choose 2}\\) present can be considered to be implemented as adjacency list. C++ Graph representation #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; The following code shows how to make a graph and use it int main () { Graph g ; vector < char > v = { 'a' , 'b' , 'c' }; g . register_vertex ( v ); g . add_edge ( 'a' , 'c' , 32 ); g . add_edge ( 'a' , 'd' , 2 ); g . add_edge ( 'b' , 'd' , 12 ); g . add_edge ( 'b' , 'c' , 98 ); g . add_edge ( 'c' , 'a' , 1 ); unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } }","title":"Graph Usage"},{"location":"graph/usage/#graphs","text":"The graph is one of the most common and important data structures. With C++ and STL I'll show you the best possible implementation for the graph that you'll be able to implement and analyze in your code at FAANG interviews within the time constraints.","title":" Graphs"},{"location":"graph/usage/#graph-adjacency-list-vs-adjacency-matrix","text":"Most of cases the List representation is good enough, if the graph is sparse then it will take less space, and if the graph is dense you should use the adjacency matrix representation. In my opinion any graph with less than 70% of the all possible edges : \\(\\text{Count(E)} \\geq 0.7 * {n \\choose 2}\\) present can be considered to be implemented as adjacency list.","title":"Graph Adjacency List vs Adjacency Matrix"},{"location":"graph/usage/#c-graph-representation","text":"#include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; The following code shows how to make a graph and use it int main () { Graph g ; vector < char > v = { 'a' , 'b' , 'c' }; g . register_vertex ( v ); g . add_edge ( 'a' , 'c' , 32 ); g . add_edge ( 'a' , 'd' , 2 ); g . add_edge ( 'b' , 'd' , 12 ); g . add_edge ( 'b' , 'c' , 98 ); g . add_edge ( 'c' , 'a' , 1 ); unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } }","title":"C++  Graph representation"},{"location":"greedy/problems/","text":"Greedy Problems Greedy algorithms are algorithms that follows the problem-solving heuristic of making the locally optimal choice at each stage. You can not go back on your decisions once you've taken it. Let's solve some greedy problems Questions solved here Jump Game Jump Game II Jump Game Find the problem on Leetcode \\(\\to\\) Problem Statement You are given an integer array nums . You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Approach We'll approach the problem in a reversed order. So we'll start from the end of the array and see if it is possible to reach that place, if we find any place from where we can reach the last index in the next iteration we'll see, that we can reach that index? We'll try to see the updated position is possible or not? Code class Solution { public : bool canJump ( vector < int >& nums ) { int to_reach = nums . size () - 1 ; int index = nums . size () - 1 ; while ( index >= 0 ) { if ( nums [ index ] + index >= to_reach ) { to_reach = index ; } index -- ; } return to_reach == 0 ; } }; Jump Game II Find the problem on leetcode \\(\\to\\) Problem Statement Given similar to the last problem, an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Our goal is to reach the last index in the minimum number of jumps. We can assume that you can always reach the last index. Example Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Approach We'll do a simple BFS like approach here. We are at first at the first index of the array. We'll see upto where we can reach and save it as level 1. Similarly we'll see from level 1 upto where maximum we can jump to, we'll mark it as level 2. From each level we'll jump to the next level until we reach the last index or cross that. To hold the values of the levels we'll use a pair<int, int> whose first element is the lower bound of the current level and second is the upper bound of the current level. C++ Code class Solution { public : int jump ( vector < int >& nums ) { // base cases if ( nums . size () == 1 ) return 0 ; int jumpCounter = 0 ; pair < int , int > level = { 1 , nums [ 0 ]}; int index = 1 ; while ( level . second < nums . size () - 1 ) { // find if you can get out of this level, then find the max // distance you can get out of this level? // this level has bounds from level.first to level.second int maxJumpToTheOutSide = 0 ; for ( int i = 0 ; i <= level . second ; i ++ ) { maxJumpToTheOutSide = std :: max ( maxJumpToTheOutSide , ( nums [ i ] + i )); } // jump to that location now level . first = level . second + 1 ; level . second = maxJumpToTheOutSide ; index = level . first ; jumpCounter ++ ; } return jumpCounter + 1 ; } };","title":"Greedy Problems"},{"location":"greedy/problems/#greedy-problems","text":"Greedy algorithms are algorithms that follows the problem-solving heuristic of making the locally optimal choice at each stage. You can not go back on your decisions once you've taken it. Let's solve some greedy problems Questions solved here Jump Game Jump Game II","title":"Greedy Problems"},{"location":"greedy/problems/#jump-game","text":"Find the problem on Leetcode \\(\\to\\)","title":"Jump Game"},{"location":"greedy/problems/#problem-statement","text":"You are given an integer array nums . You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.","title":"Problem Statement"},{"location":"greedy/problems/#example","text":"Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.","title":"Example"},{"location":"greedy/problems/#approach","text":"We'll approach the problem in a reversed order. So we'll start from the end of the array and see if it is possible to reach that place, if we find any place from where we can reach the last index in the next iteration we'll see, that we can reach that index? We'll try to see the updated position is possible or not?","title":"Approach"},{"location":"greedy/problems/#code","text":"class Solution { public : bool canJump ( vector < int >& nums ) { int to_reach = nums . size () - 1 ; int index = nums . size () - 1 ; while ( index >= 0 ) { if ( nums [ index ] + index >= to_reach ) { to_reach = index ; } index -- ; } return to_reach == 0 ; } };","title":"Code"},{"location":"greedy/problems/#jump-game-ii","text":"Find the problem on leetcode \\(\\to\\)","title":"Jump Game II"},{"location":"greedy/problems/#problem-statement_1","text":"Given similar to the last problem, an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Our goal is to reach the last index in the minimum number of jumps. We can assume that you can always reach the last index.","title":"Problem Statement"},{"location":"greedy/problems/#example_1","text":"Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.","title":"Example"},{"location":"greedy/problems/#approach_1","text":"We'll do a simple BFS like approach here. We are at first at the first index of the array. We'll see upto where we can reach and save it as level 1. Similarly we'll see from level 1 upto where maximum we can jump to, we'll mark it as level 2. From each level we'll jump to the next level until we reach the last index or cross that. To hold the values of the levels we'll use a pair<int, int> whose first element is the lower bound of the current level and second is the upper bound of the current level.","title":"Approach"},{"location":"greedy/problems/#c-code","text":"class Solution { public : int jump ( vector < int >& nums ) { // base cases if ( nums . size () == 1 ) return 0 ; int jumpCounter = 0 ; pair < int , int > level = { 1 , nums [ 0 ]}; int index = 1 ; while ( level . second < nums . size () - 1 ) { // find if you can get out of this level, then find the max // distance you can get out of this level? // this level has bounds from level.first to level.second int maxJumpToTheOutSide = 0 ; for ( int i = 0 ; i <= level . second ; i ++ ) { maxJumpToTheOutSide = std :: max ( maxJumpToTheOutSide , ( nums [ i ] + i )); } // jump to that location now level . first = level . second + 1 ; level . second = maxJumpToTheOutSide ; index = level . first ; jumpCounter ++ ; } return jumpCounter + 1 ; } };","title":"C++ Code"},{"location":"hashing/problems/","text":"Hashing problems If some problem is not solvable without mental gymnastics, you can pretty much solve those with a hashtable or unordered_map<d_t, d_t> in C++. Let's solve some of the hashing problems which may not be straight forward. Find and Replace Pattern Problem Statement Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. Approach We can solve this problem with a hash table but the problem is one letter is mapped to only one letter. Let's take some examples see how this can cause some problems. Let's say we have a pattern abb and we want to match from [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"] . Now if we make an unordered map with abb to for each string mapping it will show us that mee is matching, aqq is matching and also ccc is matching. You can only check if a is mapped to only c or not, not the other way around. So the test case acc will fail our algorithm. So let's try to map the reverse way round. We'll map the string from the string array to the pattern string. Now the test case mee will have m->a mapping, e->b mapping and once more e->b mapping. Now let's take a look at the test case abc , a->a mapping then b->c mapping and then c->b mapping. So there is another error now. Once b is mapped to b then c can not be mapped to b. b can be only mapped to b. So we've looked at both directions and none of the seems to work, what if we have a bi directional char to char mapping so that we can match one letter to exactly one letter? So we need to implement a BiMap() class to solve the problem. Below is the implementation for BiMap . class BiMap { private : unordered_map < char , char > front ; unordered_map < char , char > back ; public : BiMap () {} void put ( char key , char value ) { front . insert ({ key , value }); back . insert ({ value , key }); } char checkFront ( char key ) { if ( front . find ( key ) == front . end ()) return '~' ; return front [ key ]; } char checkBack ( char value ) { if ( back . find ( value ) == back . end ()) return '~' ; return back [ value ]; } }; Now using that BiMap we'll solve the problem. class Solution { private : bool findMatching ( string word , string pattern ) { if ( word . size () != pattern . size ()) return false ; int index = 0 ; BiMap b = BiMap (); while ( index < pattern . size ()) { char charFromWord = word [ index ]; char charFromPattern = pattern [ index ]; // if bimap returns ~ means it is not in the bimap // if both front and back returns ~ that means this is a new character if ( b . checkFront ( charFromWord ) == '~' and b . checkBack ( charFromPattern ) == '~' ) b . put ( charFromWord , charFromPattern ); // else if checkFront and checkBack should return identical mapping // m->a and a->m // check if it is the same with the pattern? if ( b . checkFront ( charFromWord ) != charFromPattern ) { return false ; } if ( b . checkBack ( charFromPattern ) != charFromWord ) { return false ; } index ++ ; } return true ; } public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > v ; for ( string str : words ) { if ( findMatching ( str , pattern )) { v . push_back ( str ); } } return v ; } };","title":"Hashing"},{"location":"hashing/problems/#hashing-problems","text":"If some problem is not solvable without mental gymnastics, you can pretty much solve those with a hashtable or unordered_map<d_t, d_t> in C++. Let's solve some of the hashing problems which may not be straight forward.","title":"Hashing problems"},{"location":"hashing/problems/#find-and-replace-pattern","text":"","title":"Find and Replace Pattern"},{"location":"hashing/problems/#problem-statement","text":"Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.","title":"Problem Statement"},{"location":"hashing/problems/#approach","text":"We can solve this problem with a hash table but the problem is one letter is mapped to only one letter. Let's take some examples see how this can cause some problems. Let's say we have a pattern abb and we want to match from [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"] . Now if we make an unordered map with abb to for each string mapping it will show us that mee is matching, aqq is matching and also ccc is matching. You can only check if a is mapped to only c or not, not the other way around. So the test case acc will fail our algorithm. So let's try to map the reverse way round. We'll map the string from the string array to the pattern string. Now the test case mee will have m->a mapping, e->b mapping and once more e->b mapping. Now let's take a look at the test case abc , a->a mapping then b->c mapping and then c->b mapping. So there is another error now. Once b is mapped to b then c can not be mapped to b. b can be only mapped to b. So we've looked at both directions and none of the seems to work, what if we have a bi directional char to char mapping so that we can match one letter to exactly one letter? So we need to implement a BiMap() class to solve the problem. Below is the implementation for BiMap . class BiMap { private : unordered_map < char , char > front ; unordered_map < char , char > back ; public : BiMap () {} void put ( char key , char value ) { front . insert ({ key , value }); back . insert ({ value , key }); } char checkFront ( char key ) { if ( front . find ( key ) == front . end ()) return '~' ; return front [ key ]; } char checkBack ( char value ) { if ( back . find ( value ) == back . end ()) return '~' ; return back [ value ]; } }; Now using that BiMap we'll solve the problem. class Solution { private : bool findMatching ( string word , string pattern ) { if ( word . size () != pattern . size ()) return false ; int index = 0 ; BiMap b = BiMap (); while ( index < pattern . size ()) { char charFromWord = word [ index ]; char charFromPattern = pattern [ index ]; // if bimap returns ~ means it is not in the bimap // if both front and back returns ~ that means this is a new character if ( b . checkFront ( charFromWord ) == '~' and b . checkBack ( charFromPattern ) == '~' ) b . put ( charFromWord , charFromPattern ); // else if checkFront and checkBack should return identical mapping // m->a and a->m // check if it is the same with the pattern? if ( b . checkFront ( charFromWord ) != charFromPattern ) { return false ; } if ( b . checkBack ( charFromPattern ) != charFromWord ) { return false ; } index ++ ; } return true ; } public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > v ; for ( string str : words ) { if ( findMatching ( str , pattern )) { v . push_back ( str ); } } return v ; } };","title":"Approach"},{"location":"heaps/heap-pq/","text":"Priority Queues and Binary Heaps What are these priority queues? A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm. Identification You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq. STL Usage A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap]. Functions to remember top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container. Recommended use of heaps instead of using STL Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code Things to look out before you start First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time. Heap Build Subroutines There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap. C++ Code #include <iostream> #include <vector> using std :: cout ; using std :: endl ; /** * Interface: MaxHeapify of std::vector vector, and the violation is at atIndex * Only solves a single violation * This is for maintaining the heap property */ void maxHeapify ( std :: vector < int > * vector , int atIndex ){ int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } /** * Build heap procedure. Runs in O(N) time in-place. * Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the * tree and runs MAX-HEAPIFY on each one */ void buildHeap ( std :: vector < int > * vector ){ int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } } Heap Sorting with min heap implementation Using min heap we can get the smallest element in \\(O(\\log n)\\) time. For \\(n\\) elements it will take \\(O(n \\log n)\\) time. This is the best a comparison sort can get. This solution takes no extra memory as the out array is filled one by one and the nums array is reduced one by one in the public sortArray() method. The following buildHeap procedure actually builds the min heap in \\(O(N)\\) time in-place. class Solution { private : int leftChild ( int index ){ return ( index * 2 ) + 1 ; } int rightChild ( int index ){ return ( index * 2 ) + 2 ; } void minHeapify ( vector < int > & nums , int index ){ int smallest = index ; int leftindex = leftChild ( index ); int rightindex = rightChild ( index ); int size = nums . size (); if (( leftindex < size ) && ( nums [ leftindex ] < nums [ smallest ])){ smallest = leftindex ; } if (( rightindex < size ) && ( nums [ rightindex ] < nums [ smallest ])){ smallest = rightindex ; } if ( smallest != index ){ swap ( nums [ smallest ], nums [ index ]); minHeapify ( nums , smallest ); } } void buildHeap ( vector < int > & nums ){ int size = nums . size (); int lastparent = ( size / 2 ) - 1 ; for ( int i = lastparent ; i >= 0 ; i -- ){ minHeapify ( nums , i ); } } public : vector < int > sortArray ( vector < int >& nums ) { vector < int > out ; buildHeap ( nums ); while ( nums . size () != 0 ){ std :: swap ( nums [ 0 ], nums . back ()); out . push_back ( nums . back ()); nums . pop_back (); minHeapify ( nums , 0 ); } return out ; } };","title":"Heaps Introduction, STL"},{"location":"heaps/heap-pq/#priority-queues-and-binary-heaps","text":"","title":" Priority Queues and Binary Heaps"},{"location":"heaps/heap-pq/#what-are-these-priority-queues","text":"A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm.","title":"What are these priority queues?"},{"location":"heaps/heap-pq/#identification","text":"You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq.","title":"Identification"},{"location":"heaps/heap-pq/#stl-usage","text":"A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap].","title":"STL Usage"},{"location":"heaps/heap-pq/#functions-to-remember","text":"top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container.","title":"Functions to remember"},{"location":"heaps/heap-pq/#recommended-use-of-heaps-instead-of-using-stl","text":"Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code","title":"Recommended use of heaps instead of using STL"},{"location":"heaps/heap-pq/#things-to-look-out-before-you-start","text":"First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time.","title":"Things to look out before you start"},{"location":"heaps/heap-pq/#heap-build-subroutines","text":"There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap.","title":"Heap Build Subroutines"},{"location":"heaps/heap-pq/#c-code","text":"#include <iostream> #include <vector> using std :: cout ; using std :: endl ; /** * Interface: MaxHeapify of std::vector vector, and the violation is at atIndex * Only solves a single violation * This is for maintaining the heap property */ void maxHeapify ( std :: vector < int > * vector , int atIndex ){ int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } /** * Build heap procedure. Runs in O(N) time in-place. * Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the * tree and runs MAX-HEAPIFY on each one */ void buildHeap ( std :: vector < int > * vector ){ int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } }","title":"C++ Code"},{"location":"heaps/heap-pq/#heap-sorting-with-min-heap-implementation","text":"Using min heap we can get the smallest element in \\(O(\\log n)\\) time. For \\(n\\) elements it will take \\(O(n \\log n)\\) time. This is the best a comparison sort can get. This solution takes no extra memory as the out array is filled one by one and the nums array is reduced one by one in the public sortArray() method. The following buildHeap procedure actually builds the min heap in \\(O(N)\\) time in-place. class Solution { private : int leftChild ( int index ){ return ( index * 2 ) + 1 ; } int rightChild ( int index ){ return ( index * 2 ) + 2 ; } void minHeapify ( vector < int > & nums , int index ){ int smallest = index ; int leftindex = leftChild ( index ); int rightindex = rightChild ( index ); int size = nums . size (); if (( leftindex < size ) && ( nums [ leftindex ] < nums [ smallest ])){ smallest = leftindex ; } if (( rightindex < size ) && ( nums [ rightindex ] < nums [ smallest ])){ smallest = rightindex ; } if ( smallest != index ){ swap ( nums [ smallest ], nums [ index ]); minHeapify ( nums , smallest ); } } void buildHeap ( vector < int > & nums ){ int size = nums . size (); int lastparent = ( size / 2 ) - 1 ; for ( int i = lastparent ; i >= 0 ; i -- ){ minHeapify ( nums , i ); } } public : vector < int > sortArray ( vector < int >& nums ) { vector < int > out ; buildHeap ( nums ); while ( nums . size () != 0 ){ std :: swap ( nums [ 0 ], nums . back ()); out . push_back ( nums . back ()); nums . pop_back (); minHeapify ( nums , 0 ); } return out ; } };","title":"Heap Sorting with min heap implementation"},{"location":"heaps/problems/","text":"Heap Problems Questions discussed Kth Largest Element in an Array (Medium) Find all K Largest Elements in the array Sort a K Sorted array Find K Closest Elements (Medium) Top K Frequent Elements (Medium) Top K Frequent Elements K Closest Points to Origin Kth Largest Element in an Array (Medium) Problem Statement Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Examples Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints \\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\) Approach There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k-1th largest will be removed minHeap . pop (); } } return minHeap . top (); } }; Find all K Largest Elements in the array Problem Statement This problem is a bit different than the previous one. Here you have to return K largest elements from a given sequence. For example flowchart LR 10-->12 12-->13 13-->167 167-->46 46-->2157 For the above sequence the \\(K = 3\\) largest elements should be the following: flowchart LR 2157-->167-->46 Approach From the above code if we look closely enough, we find that after all the operations done the remaining elements in the k sized heap contains all the elements that are greater or equal to the \\(K^{\\text{th}}\\) largest element in the given sequence. So return all the elements from the heap. C++ Code std :: vector < int > kLargestElements ( std :: vector < int > & vector , int k ){ std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; for ( auto element : vector ){ if ( minHeap . size () != k ){ minHeap . push ( element ); } else { minHeap . push ( element ); minHeap . pop (); } } while ( ! minHeap . empty ()){ out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; } Sort a K Sorted array Problem Statement Each element in the array must be within the range k from it's desired position, Now sort the array as efficiently as possible. Approach For each index, the corresponding sorted element is in the array is within k to the left and k to the right of that index. Now we make a min-heap of size k+1, Now we push first k+1 elements into the heap. Now for each index extract the min, then slide the window by 1 distance adding the \\((k+1) + 1^{th}\\) element to the heap and remove the min element from the min heap. In the next step do the same with \\((k+1) + 2^{th}\\) element, unitl this pointer reaches to the end. At the end extract the remaining min elements from the heap and add it to the out vector. #include <iostream> #include <queue> #include <vector> /* \ud83d\uddff Implementation for sorting a k sorted array using heap \ud83d\uddff \ud83d\uddff Input is given a k sorted array [\ud83d\uddff pass by address \ud83d\uddff] \ud83d\uddff returns the sorted array. */ std :: vector < int > kSortedArray ( std :: vector < int > & array , int k ) { int size = array . size (); int index = 0 ; std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; // initially push k element into the min heap int nextuptoK = k + 1 ; while ( nextuptoK ) { minHeap . push ( array [ nextuptoK ]); nextuptoK -- ; } // Now move forward with the array and put one new element into the min heap and // pop last element from the min heap [the minimum]. This popped element is the minimum element // so put it into the out vector. int window_last = k + 2 ; while ( window_last != size ) { out . push_back ( minHeap . top ()); minHeap . pop (); minHeap . push ( array [ window_last ]); window_last ++ ; } while ( ! minHeap . empty ()) { out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; } Find K Closest Elements (Medium) Problem Statement Given a sorted integer array arr , two integers k and x , return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: |a - x| < |b - x| |a - x| == |b - x| and a < b Examples Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] Input: arr = [1,2,3,4,5], k = 4, x = -1 Output: [1,2,3,4] Approach One approach could be that we subtract x from each element of the array and return whose difference with \\(x\\) is in \\(\\{0 \\to k\\}\\) Other approach would be to use a heap. Like the previous problem we pushed K largest or smallest elements into the array. Here what we'll do is Make a minHeap, Top K Frequent Elements (Medium) Problem Statement Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Examples Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] Constraints 1 <= nums.length <= 10 5 k is in the range [1, the number of unique elements in the array] . It is guaranteed that the answer is unique . Follow up: The algorithm's time complexity must be better than \\(O(n \\log n)\\) , where n is the array's size. Approach Code Top K Frequent Elements Find the problem on Leetcode \\(\\to\\) Problem Statement Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order Example Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1,12,2,34,124,124,12,31,23,123,12,312,3,123,123,123,12,31,23,123,123] and k = 5 Output: [123,12,23,31,124] Approach First we should make an unordered map to find the frequency of all the elements. We do not get that information by just looking at the elements of the array. After that once we have the frequency of all the elements, we'll push elements on to a min heap of size \\(K\\) based on the frequency of those elements. Making the size of the min heap limited to size \\(K\\) helps to keep track only the k most frequent elements, once we have a less frequent element, as it'll on the top of the min heap, we'll perform a heap pop. Code class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { // first count all the elements and their occurences unordered_map < int , int > map ; for ( auto i : nums ){ if ( map . find ( i ) == map . end ()) { map . insert ({ i , 1 }); } else { map [ i ] ++ ; } } // now that we have all the counts we'll do a quick heap implementation priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> minHeap ; for ( auto it = map . begin (); it != map . end (); it ++ ) { minHeap . push ({ it -> second , it -> first }); if ( minHeap . size () > k ) { minHeap . pop (); } } // at the end we have top k elements in the minHeap vector < int > answer ; while ( ! minHeap . empty ()) { answer . push_back ( minHeap . top (). second ); minHeap . pop (); } return answer ; } }; K Closest Points to Origin Find the problem on leetcode \\(\\to\\) Problem Statement Given an array of points where \\(\\text{points(i)} = [x_i, y_i]\\) represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., \\(\\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\\) ) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in). Approach We'll use max heap to store the distant points from the origin. To know how much distance they are in we'll make some ID system for each of the points, and calculate the distance between that point and the origin then put it in a hash table along with the ID, Now we'll for each entry in the hashtable we'll put the entry in a max heap (with priority being the distance to the origin), if the max heap size if greater than \\(k\\) then we'll pop from the heap, at last we'll get all the point's IDs remaining in the priority queue and return them via a ID to point lookup. Code class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int k ) { vector < int > origin = { 0 , 1 }; // make an ID System to identify each of the points // let's say their index in the points array is their ID // making map of point IDs and their distance to the origin // ID -> distance map unordered_map < int , float > distances ; for ( int i = 0 ; i < points . size (); i ++ ) { float distance = sqrt ( points [ i ][ 0 ] * points [ i ][ 0 ] + points [ i ][ 1 ] * points [ i ][ 1 ]); distances . insert ({ i , distance }); } // now make a priority queue to store the order and at last find k closest points // using a max heap we can do that priority_queue < pair < float , int >> pq ; // Max Heap for ( auto v : distances ) { int id = v . first ; int distance = v . second ; pq . push ({ v . second , v . first }); if ( pq . size () > k ) { pq . pop (); } } // now the last k means the k closest points are remaining in the pq vector < vector < int >> answers ; while ( not pq . empty ()) { auto top = pq . top (); pq . pop (); vector < int > v = { points [ top . second ][ 0 ], points [ top . second ][ 1 ]}; answers . push_back ( v ); } return answers ; } };","title":"Heap Problems"},{"location":"heaps/problems/#heap-problems","text":"Questions discussed Kth Largest Element in an Array (Medium) Find all K Largest Elements in the array Sort a K Sorted array Find K Closest Elements (Medium) Top K Frequent Elements (Medium) Top K Frequent Elements K Closest Points to Origin","title":" Heap Problems"},{"location":"heaps/problems/#kth-largest-element-in-an-array-medium","text":"","title":"Kth Largest Element in an Array (Medium)"},{"location":"heaps/problems/#problem-statement","text":"Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.","title":"Problem Statement"},{"location":"heaps/problems/#examples","text":"Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4","title":"Examples"},{"location":"heaps/problems/#constraints","text":"\\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\)","title":"Constraints"},{"location":"heaps/problems/#approach","text":"There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k-1th largest will be removed minHeap . pop (); } } return minHeap . top (); } };","title":"Approach"},{"location":"heaps/problems/#find-all-k-largest-elements-in-the-array","text":"","title":"Find all K Largest Elements in the array"},{"location":"heaps/problems/#problem-statement_1","text":"This problem is a bit different than the previous one. Here you have to return K largest elements from a given sequence. For example flowchart LR 10-->12 12-->13 13-->167 167-->46 46-->2157 For the above sequence the \\(K = 3\\) largest elements should be the following: flowchart LR 2157-->167-->46","title":"Problem Statement"},{"location":"heaps/problems/#approach_1","text":"From the above code if we look closely enough, we find that after all the operations done the remaining elements in the k sized heap contains all the elements that are greater or equal to the \\(K^{\\text{th}}\\) largest element in the given sequence. So return all the elements from the heap.","title":"Approach"},{"location":"heaps/problems/#c-code","text":"std :: vector < int > kLargestElements ( std :: vector < int > & vector , int k ){ std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; for ( auto element : vector ){ if ( minHeap . size () != k ){ minHeap . push ( element ); } else { minHeap . push ( element ); minHeap . pop (); } } while ( ! minHeap . empty ()){ out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; }","title":"C++ Code"},{"location":"heaps/problems/#sort-a-k-sorted-array","text":"","title":"Sort a K Sorted array"},{"location":"heaps/problems/#problem-statement_2","text":"Each element in the array must be within the range k from it's desired position, Now sort the array as efficiently as possible.","title":"Problem Statement"},{"location":"heaps/problems/#approach_2","text":"For each index, the corresponding sorted element is in the array is within k to the left and k to the right of that index. Now we make a min-heap of size k+1, Now we push first k+1 elements into the heap. Now for each index extract the min, then slide the window by 1 distance adding the \\((k+1) + 1^{th}\\) element to the heap and remove the min element from the min heap. In the next step do the same with \\((k+1) + 2^{th}\\) element, unitl this pointer reaches to the end. At the end extract the remaining min elements from the heap and add it to the out vector. #include <iostream> #include <queue> #include <vector> /* \ud83d\uddff Implementation for sorting a k sorted array using heap \ud83d\uddff \ud83d\uddff Input is given a k sorted array [\ud83d\uddff pass by address \ud83d\uddff] \ud83d\uddff returns the sorted array. */ std :: vector < int > kSortedArray ( std :: vector < int > & array , int k ) { int size = array . size (); int index = 0 ; std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; // initially push k element into the min heap int nextuptoK = k + 1 ; while ( nextuptoK ) { minHeap . push ( array [ nextuptoK ]); nextuptoK -- ; } // Now move forward with the array and put one new element into the min heap and // pop last element from the min heap [the minimum]. This popped element is the minimum element // so put it into the out vector. int window_last = k + 2 ; while ( window_last != size ) { out . push_back ( minHeap . top ()); minHeap . pop (); minHeap . push ( array [ window_last ]); window_last ++ ; } while ( ! minHeap . empty ()) { out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; }","title":"Approach"},{"location":"heaps/problems/#find-k-closest-elements-medium","text":"","title":"Find K Closest Elements (Medium)"},{"location":"heaps/problems/#problem-statement_3","text":"Given a sorted integer array arr , two integers k and x , return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: |a - x| < |b - x| |a - x| == |b - x| and a < b","title":"Problem Statement"},{"location":"heaps/problems/#examples_1","text":"Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] Input: arr = [1,2,3,4,5], k = 4, x = -1 Output: [1,2,3,4]","title":"Examples"},{"location":"heaps/problems/#approach_3","text":"One approach could be that we subtract x from each element of the array and return whose difference with \\(x\\) is in \\(\\{0 \\to k\\}\\) Other approach would be to use a heap. Like the previous problem we pushed K largest or smallest elements into the array. Here what we'll do is Make a minHeap,","title":"Approach"},{"location":"heaps/problems/#top-k-frequent-elements-medium","text":"","title":"Top K Frequent Elements (Medium)"},{"location":"heaps/problems/#problem-statement_4","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.","title":"Problem Statement"},{"location":"heaps/problems/#examples_2","text":"Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]","title":"Examples"},{"location":"heaps/problems/#constraints_1","text":"1 <= nums.length <= 10 5 k is in the range [1, the number of unique elements in the array] . It is guaranteed that the answer is unique . Follow up: The algorithm's time complexity must be better than \\(O(n \\log n)\\) , where n is the array's size.","title":"Constraints"},{"location":"heaps/problems/#approach_4","text":"","title":"Approach"},{"location":"heaps/problems/#code","text":"","title":"Code"},{"location":"heaps/problems/#top-k-frequent-elements","text":"Find the problem on Leetcode \\(\\to\\)","title":"Top K Frequent Elements"},{"location":"heaps/problems/#problem-statement_5","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order","title":"Problem Statement"},{"location":"heaps/problems/#example","text":"Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1,12,2,34,124,124,12,31,23,123,12,312,3,123,123,123,12,31,23,123,123] and k = 5 Output: [123,12,23,31,124]","title":"Example"},{"location":"heaps/problems/#approach_5","text":"First we should make an unordered map to find the frequency of all the elements. We do not get that information by just looking at the elements of the array. After that once we have the frequency of all the elements, we'll push elements on to a min heap of size \\(K\\) based on the frequency of those elements. Making the size of the min heap limited to size \\(K\\) helps to keep track only the k most frequent elements, once we have a less frequent element, as it'll on the top of the min heap, we'll perform a heap pop.","title":"Approach"},{"location":"heaps/problems/#code_1","text":"class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { // first count all the elements and their occurences unordered_map < int , int > map ; for ( auto i : nums ){ if ( map . find ( i ) == map . end ()) { map . insert ({ i , 1 }); } else { map [ i ] ++ ; } } // now that we have all the counts we'll do a quick heap implementation priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> minHeap ; for ( auto it = map . begin (); it != map . end (); it ++ ) { minHeap . push ({ it -> second , it -> first }); if ( minHeap . size () > k ) { minHeap . pop (); } } // at the end we have top k elements in the minHeap vector < int > answer ; while ( ! minHeap . empty ()) { answer . push_back ( minHeap . top (). second ); minHeap . pop (); } return answer ; } };","title":"Code"},{"location":"heaps/problems/#k-closest-points-to-origin","text":"Find the problem on leetcode \\(\\to\\)","title":"K Closest Points to Origin"},{"location":"heaps/problems/#problem-statement_6","text":"Given an array of points where \\(\\text{points(i)} = [x_i, y_i]\\) represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., \\(\\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\\) ) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).","title":"Problem Statement"},{"location":"heaps/problems/#approach_6","text":"We'll use max heap to store the distant points from the origin. To know how much distance they are in we'll make some ID system for each of the points, and calculate the distance between that point and the origin then put it in a hash table along with the ID, Now we'll for each entry in the hashtable we'll put the entry in a max heap (with priority being the distance to the origin), if the max heap size if greater than \\(k\\) then we'll pop from the heap, at last we'll get all the point's IDs remaining in the priority queue and return them via a ID to point lookup.","title":"Approach"},{"location":"heaps/problems/#code_2","text":"class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int k ) { vector < int > origin = { 0 , 1 }; // make an ID System to identify each of the points // let's say their index in the points array is their ID // making map of point IDs and their distance to the origin // ID -> distance map unordered_map < int , float > distances ; for ( int i = 0 ; i < points . size (); i ++ ) { float distance = sqrt ( points [ i ][ 0 ] * points [ i ][ 0 ] + points [ i ][ 1 ] * points [ i ][ 1 ]); distances . insert ({ i , distance }); } // now make a priority queue to store the order and at last find k closest points // using a max heap we can do that priority_queue < pair < float , int >> pq ; // Max Heap for ( auto v : distances ) { int id = v . first ; int distance = v . second ; pq . push ({ v . second , v . first }); if ( pq . size () > k ) { pq . pop (); } } // now the last k means the k closest points are remaining in the pq vector < vector < int >> answers ; while ( not pq . empty ()) { auto top = pq . top (); pq . pop (); vector < int > v = { points [ top . second ][ 0 ], points [ top . second ][ 1 ]}; answers . push_back ( v ); } return answers ; } };","title":"Code"},{"location":"recursion/intro/","text":"Introduction to recursion Recursion is when a [function] calls itself until some condition is met. Following things we need to understand very clearly before proceeding with recursion What is this making problem space smaller idea? We are not specifically looking for to reduce the problem space, instead we'll be making some decisions that will reduce the problem space. Reduction of problem space is a by-product of the decisions that we'll be making in a specific stage of the algorithm. For recursive function calls a new stack space is created and the function will have no memory of what were the variables in the previous function call. To avoid this we use parameterized recursive calls. Note static is just a global variable with visibility limited to one function. So if you declare it static , there is exactly one variable shared by all the levels of recursion. Without static , the variable is local, which means each function invocation has its own copy of variable's state. Easier Recursion problems Print some useful information 10 times Following is the code for printing \"something useful\" 10 times with recursion, Approach Static and global variables are stored in heap which is shared across all function calls. So we'll store a counter inside the heap to keep track of the counter across all function calls. void print (){ static int count = 10 ; if ( count != 0 ){ cout << \"Something \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; } Similarly print 1 to 10 using recursive calls void print (){ static int count = 10 ; if ( count != 0 ){ cout << count << \" \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; } Functional apporach In this apporach we will think of the problem [solution] as a recursion tree and the function calls to a smaller problem. Example: Sum of first N numbers int sumOfFirstNNumbers ( int startFrom , int UpTo ){ if ( startFrom <= UpTo ){ sum = startFrom + sumOfFirstNNumbers ( startFrom + 1 , UpTo ); } return sum ; } // OR int sumOfFirstNNumbers_2 ( int N ){ if ( N == 0 ) return 0 ; return N + sumOfFirstNNumbers_static ( N - 1 ); } int main () { std :: cout << sumOfFirstNNumbers ( 1 , 4 ); } Stepwise recursive calls for this apporach. Other approaches Using a static variable that is shared accross multiple function calls also works. int sumOfFirstNNumbers_static ( int N ){ static int sum = 0 ; // THIS is the ACCUMULATOR if ( N == 0 ) return 0 ; sum += N ; // Accumulate the \"N\"s into the SUM. sumOfFirstNNumbers_static ( N - 1 ); return sum ; } Reverse an array of numbers using recursive calls only Approach : Add n th element and recursively call the function from 1 to \\(n-1\\) , and add \\(n-1^{th}\\) elements to the answer array, again recursively call the function until we reach \\(0^{th}\\) element. std :: vector < int > reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only static std :: vector < int > ans ; if ( to != -1 ){ ans . push_back ( arr [ to ]); reverse ( arr , from , to -1 ); } return ans ; } We can also modify the original to avoid extra spaces. We can swap the last and first elements until first pointer crosses last pointer. The following is \\(O(N)\\) auxiliary space solution. Code void reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only if ( from <= to ){ std :: swap ( arr [ from ], arr [ to ]); reverse ( arr , from + 1 , to -1 ); } } Find all the sub-sequences that sums up to K. Problem Statement You'll be given a sequence and with recursive calls find out all the sub-sequences that sum up to K. Approach First we can either take or not take one element of the sequence, each time we'll check if the number is taken the sum is greater than the required or not, If greater we stop and return else we include it and check if the sum is equal to K? If equal we simply print the sequence. Code #include <iostream> #include <vector> using std :: cout ; using std :: endl ; void solver ( std :: vector < int > & v , int index , int k , int sum ){ // sub-seq whose sum is K from the given sequence V // shared across all recursive calls static std :: vector < int > b ; if ( index > v . size () - 1 ) return ; if ( sum < k ){ // try with the current value b . push_back ( v [ index ]); sum = sum + v [ index ]; solver ( v , index + 1 , k , sum ); // again try without the current value b . pop_back (); sum = sum - v [ index ]; solver ( v , index + 1 , k , sum ); } if ( sum == k ){ for ( auto i : b ){ cout << i << \" \" ; } cout << endl ; } }","title":"Recursion Introduction"},{"location":"recursion/intro/#introduction-to-recursion","text":"Recursion is when a [function] calls itself until some condition is met. Following things we need to understand very clearly before proceeding with recursion","title":" Introduction to recursion"},{"location":"recursion/intro/#what-is-this-making-problem-space-smaller-idea","text":"We are not specifically looking for to reduce the problem space, instead we'll be making some decisions that will reduce the problem space. Reduction of problem space is a by-product of the decisions that we'll be making in a specific stage of the algorithm. For recursive function calls a new stack space is created and the function will have no memory of what were the variables in the previous function call. To avoid this we use parameterized recursive calls. Note static is just a global variable with visibility limited to one function. So if you declare it static , there is exactly one variable shared by all the levels of recursion. Without static , the variable is local, which means each function invocation has its own copy of variable's state.","title":"What is this making problem space smaller idea?"},{"location":"recursion/intro/#easier-recursion-problems","text":"","title":"Easier Recursion problems"},{"location":"recursion/intro/#print-some-useful-information-10-times","text":"Following is the code for printing \"something useful\" 10 times with recursion,","title":"Print some useful information 10 times"},{"location":"recursion/intro/#approach","text":"Static and global variables are stored in heap which is shared across all function calls. So we'll store a counter inside the heap to keep track of the counter across all function calls. void print (){ static int count = 10 ; if ( count != 0 ){ cout << \"Something \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; }","title":"Approach"},{"location":"recursion/intro/#similarly-print-1-to-10-using-recursive-calls","text":"void print (){ static int count = 10 ; if ( count != 0 ){ cout << count << \" \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; }","title":"Similarly print 1 to 10 using recursive calls"},{"location":"recursion/intro/#functional-apporach","text":"In this apporach we will think of the problem [solution] as a recursion tree and the function calls to a smaller problem.","title":"Functional apporach"},{"location":"recursion/intro/#example-sum-of-first-n-numbers","text":"int sumOfFirstNNumbers ( int startFrom , int UpTo ){ if ( startFrom <= UpTo ){ sum = startFrom + sumOfFirstNNumbers ( startFrom + 1 , UpTo ); } return sum ; } // OR int sumOfFirstNNumbers_2 ( int N ){ if ( N == 0 ) return 0 ; return N + sumOfFirstNNumbers_static ( N - 1 ); } int main () { std :: cout << sumOfFirstNNumbers ( 1 , 4 ); } Stepwise recursive calls for this apporach.","title":"Example: Sum of first N numbers"},{"location":"recursion/intro/#other-approaches","text":"Using a static variable that is shared accross multiple function calls also works. int sumOfFirstNNumbers_static ( int N ){ static int sum = 0 ; // THIS is the ACCUMULATOR if ( N == 0 ) return 0 ; sum += N ; // Accumulate the \"N\"s into the SUM. sumOfFirstNNumbers_static ( N - 1 ); return sum ; }","title":"Other approaches"},{"location":"recursion/intro/#reverse-an-array-of-numbers-using-recursive-calls-only","text":"Approach : Add n th element and recursively call the function from 1 to \\(n-1\\) , and add \\(n-1^{th}\\) elements to the answer array, again recursively call the function until we reach \\(0^{th}\\) element. std :: vector < int > reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only static std :: vector < int > ans ; if ( to != -1 ){ ans . push_back ( arr [ to ]); reverse ( arr , from , to -1 ); } return ans ; } We can also modify the original to avoid extra spaces. We can swap the last and first elements until first pointer crosses last pointer. The following is \\(O(N)\\) auxiliary space solution.","title":"Reverse an array of numbers using recursive calls only"},{"location":"recursion/intro/#code","text":"void reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only if ( from <= to ){ std :: swap ( arr [ from ], arr [ to ]); reverse ( arr , from + 1 , to -1 ); } }","title":"Code"},{"location":"recursion/intro/#find-all-the-sub-sequences-that-sums-up-to-k","text":"","title":"Find all the sub-sequences that sums up to K."},{"location":"recursion/intro/#problem-statement","text":"You'll be given a sequence and with recursive calls find out all the sub-sequences that sum up to K.","title":"Problem Statement"},{"location":"recursion/intro/#approach_1","text":"First we can either take or not take one element of the sequence, each time we'll check if the number is taken the sum is greater than the required or not, If greater we stop and return else we include it and check if the sum is equal to K? If equal we simply print the sequence.","title":"Approach"},{"location":"recursion/intro/#code_1","text":"#include <iostream> #include <vector> using std :: cout ; using std :: endl ; void solver ( std :: vector < int > & v , int index , int k , int sum ){ // sub-seq whose sum is K from the given sequence V // shared across all recursive calls static std :: vector < int > b ; if ( index > v . size () - 1 ) return ; if ( sum < k ){ // try with the current value b . push_back ( v [ index ]); sum = sum + v [ index ]; solver ( v , index + 1 , k , sum ); // again try without the current value b . pop_back (); sum = sum - v [ index ]; solver ( v , index + 1 , k , sum ); } if ( sum == k ){ for ( auto i : b ){ cout << i << \" \" ; } cout << endl ; } }","title":"Code"},{"location":"recursion/problems/","text":"Recursion, Backtracking and Subset Problems These pattern of questions include subset formation, backtracking and recursive calls. Almost all of the questions are leetcode medium level questions. Solving these following problems will help people gain a better understanding of Backtracking, Recursion calls, Subset pattern of questions. Find all the subsets Problem on Leetcode \\(\\to\\) Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Approach With basic recursive approach, we first include an element and don't include an element. This is how we can generate all the unique subsets from a given set. We push the subset to the answer only at the last step of the recursion tree when the index reaches to the last element. Code class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& v , int index ) { static vector < int > b ; if ( index > v . size () - 1 ) { // Push the subset only at the last step of the recursion tree vector < int > c ( b ); // create a copy of b and add it into answer answer . push_back ( c ); return ; } // with the element b . push_back ( v [ index ]); recurse ( v , index + 1 ); // without the current element b . pop_back (); recurse ( v , index + 1 ); } public : vector < vector < int >> subsets ( vector < int >& nums ) { recurse ( nums , 0 ); return answer ; } }; Subsets II Subsets II is a little bit different, given an integer array nums that may contain duplicates , return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Approach The approach should be similar to the subset approach, now in order to avoid duplicates in the power set what we can do is the following We can first sort the input array then skip duplicates while traversing through the array in the recursive calls by instead of skipping 1 index, skip multiple indexes until we can't find a new value. This specific modification helps us avoid duplicates while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } Now we can avoid duplicates in the power set. Code class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& nums , int index ){ static vector < int > b ; if ( index >= nums . size ()) { // at the end of tree vector < int > c ( b ); answer . push_back ( c ); return ; } b . push_back ( nums [ index ]); recurse ( nums , index + 1 ); b . pop_back (); while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } recurse ( nums , index + 1 ); } public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); recurse ( nums , 0 ); return answer ; } }; Combination Sum Problem on Leetcode \\(\\to\\) Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Examples Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Input: candidates = [2], target = 1 Output: [] Constraints: \\(1 \\leq\\) candidates.length \\(\\leq 30\\) \\(1 \\leq\\) <= candidates[i] \\(\\leq 200\\) All elements of candidates are distinct. \\(1 \\leq\\) target \\(\\leq 500\\) Approach We'll create a recursive subroutine called recurse which will recursively find all the sub-sequences that sums up to target Recall a similar problem in the intro section where we solved Find all the sub-sequences that sums up to K. But here the problem is little different, here one element can be added multiple times. So we create a modification in the first recursive call: recurse(candidates, target, sum, index); . In this case we are again calling with the same index so that we can check if multiple times we can add the same element. For the case where we are not considering a particular element [as] we are not considering a particular element, we'll simply call the recursive call recurse(candidates, target, sum, index + 1; with \\(\\text{Index} + 1\\) . Code class Solution { public : vector < vector < int >> answer ; void recurse ( vector < int > & candidates , int target , int sum , int index ) { static vector < int > b ; // shared data structure if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { // check with the current index b . push_back ( candidates [ index ]); sum = sum + candidates [ index ]; recurse ( candidates , target , sum , index ); // can take the same index multiple times // remove the current index and check again b . pop_back (); sum = sum - candidates [ index ]; recurse ( candidates , target , sum , index + 1 ); // index+1 bcz we are no longer interested with that index } if ( sum == target ) { vector < int > bk ( b ); answer . push_back ( bk ); } } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { recurse ( candidates , target , 0 , 0 ); return answer ; } }; Combination Sum III Find the problem on Leetcode \\(\\to\\) Problem Statement This is a slight modification of the previous problem, find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Approach Similar to the last problem we'll continue with a recursive approach and use a shared data structure b to keep track of the combinations. The code will be the almost same as the previous problem but we'll include the answer if and only if the size of the answer is equal to k according to the question specifications. For candidates the question says they are \\(1 \\to 9\\) , but we'll include \\(10\\) because the following test case will fail if we don't include \\(10\\) . Figure out why on your own. (Hint: draw the recursion tree) TEST CASE FAILURE: target = 45 k = 9 ACTUAL RESULT SHOULD BE RETURENED: [1,2,3,4,5,6,7,8,9] Failure: fails to return the result if the candidates are {1 to 9} Code class Solution { private : vector < vector < int >> answer ; void build ( int k , int target , int sum , int index , vector < int >& candidates ) { // shared data structure across recursion static vector < int > b ; if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { b . push_back ( candidates [ index ]); build ( k , target , sum + candidates [ index ], index + 1 , candidates ); b . pop_back (); build ( k , target , sum , index + 1 , candidates ); } if ( sum == target and b . size () == k ) { vector < int > lvl ( b ); answer . push_back ( lvl ); } } public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < int > candidates = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; build ( k , n , 0 , 0 , candidates ); return answer ; } };","title":"Recursion, Backtracking, Subset Pattern"},{"location":"recursion/problems/#recursion-backtracking-and-subset-problems","text":"These pattern of questions include subset formation, backtracking and recursive calls. Almost all of the questions are leetcode medium level questions. Solving these following problems will help people gain a better understanding of Backtracking, Recursion calls, Subset pattern of questions.","title":" Recursion, Backtracking and Subset Problems"},{"location":"recursion/problems/#find-all-the-subsets","text":"Problem on Leetcode \\(\\to\\) Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.","title":"Find all the subsets"},{"location":"recursion/problems/#approach","text":"With basic recursive approach, we first include an element and don't include an element. This is how we can generate all the unique subsets from a given set. We push the subset to the answer only at the last step of the recursion tree when the index reaches to the last element.","title":"Approach"},{"location":"recursion/problems/#code","text":"class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& v , int index ) { static vector < int > b ; if ( index > v . size () - 1 ) { // Push the subset only at the last step of the recursion tree vector < int > c ( b ); // create a copy of b and add it into answer answer . push_back ( c ); return ; } // with the element b . push_back ( v [ index ]); recurse ( v , index + 1 ); // without the current element b . pop_back (); recurse ( v , index + 1 ); } public : vector < vector < int >> subsets ( vector < int >& nums ) { recurse ( nums , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#subsets-ii","text":"Subsets II is a little bit different, given an integer array nums that may contain duplicates , return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.","title":"Subsets II"},{"location":"recursion/problems/#approach_1","text":"The approach should be similar to the subset approach, now in order to avoid duplicates in the power set what we can do is the following We can first sort the input array then skip duplicates while traversing through the array in the recursive calls by instead of skipping 1 index, skip multiple indexes until we can't find a new value. This specific modification helps us avoid duplicates while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } Now we can avoid duplicates in the power set.","title":"Approach"},{"location":"recursion/problems/#code_1","text":"class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& nums , int index ){ static vector < int > b ; if ( index >= nums . size ()) { // at the end of tree vector < int > c ( b ); answer . push_back ( c ); return ; } b . push_back ( nums [ index ]); recurse ( nums , index + 1 ); b . pop_back (); while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } recurse ( nums , index + 1 ); } public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); recurse ( nums , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#combination-sum","text":"Problem on Leetcode \\(\\to\\) Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.","title":"Combination Sum"},{"location":"recursion/problems/#examples","text":"Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Input: candidates = [2], target = 1 Output: []","title":"Examples"},{"location":"recursion/problems/#constraints","text":"\\(1 \\leq\\) candidates.length \\(\\leq 30\\) \\(1 \\leq\\) <= candidates[i] \\(\\leq 200\\) All elements of candidates are distinct. \\(1 \\leq\\) target \\(\\leq 500\\)","title":"Constraints:"},{"location":"recursion/problems/#approach_2","text":"We'll create a recursive subroutine called recurse which will recursively find all the sub-sequences that sums up to target Recall a similar problem in the intro section where we solved Find all the sub-sequences that sums up to K. But here the problem is little different, here one element can be added multiple times. So we create a modification in the first recursive call: recurse(candidates, target, sum, index); . In this case we are again calling with the same index so that we can check if multiple times we can add the same element. For the case where we are not considering a particular element [as] we are not considering a particular element, we'll simply call the recursive call recurse(candidates, target, sum, index + 1; with \\(\\text{Index} + 1\\) .","title":"Approach"},{"location":"recursion/problems/#code_2","text":"class Solution { public : vector < vector < int >> answer ; void recurse ( vector < int > & candidates , int target , int sum , int index ) { static vector < int > b ; // shared data structure if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { // check with the current index b . push_back ( candidates [ index ]); sum = sum + candidates [ index ]; recurse ( candidates , target , sum , index ); // can take the same index multiple times // remove the current index and check again b . pop_back (); sum = sum - candidates [ index ]; recurse ( candidates , target , sum , index + 1 ); // index+1 bcz we are no longer interested with that index } if ( sum == target ) { vector < int > bk ( b ); answer . push_back ( bk ); } } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { recurse ( candidates , target , 0 , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#combination-sum-iii","text":"Find the problem on Leetcode \\(\\to\\)","title":"Combination Sum III"},{"location":"recursion/problems/#problem-statement","text":"This is a slight modification of the previous problem, find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.","title":"Problem Statement"},{"location":"recursion/problems/#approach_3","text":"Similar to the last problem we'll continue with a recursive approach and use a shared data structure b to keep track of the combinations. The code will be the almost same as the previous problem but we'll include the answer if and only if the size of the answer is equal to k according to the question specifications. For candidates the question says they are \\(1 \\to 9\\) , but we'll include \\(10\\) because the following test case will fail if we don't include \\(10\\) . Figure out why on your own. (Hint: draw the recursion tree) TEST CASE FAILURE: target = 45 k = 9 ACTUAL RESULT SHOULD BE RETURENED: [1,2,3,4,5,6,7,8,9] Failure: fails to return the result if the candidates are {1 to 9}","title":"Approach"},{"location":"recursion/problems/#code_3","text":"class Solution { private : vector < vector < int >> answer ; void build ( int k , int target , int sum , int index , vector < int >& candidates ) { // shared data structure across recursion static vector < int > b ; if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { b . push_back ( candidates [ index ]); build ( k , target , sum + candidates [ index ], index + 1 , candidates ); b . pop_back (); build ( k , target , sum , index + 1 , candidates ); } if ( sum == target and b . size () == k ) { vector < int > lvl ( b ); answer . push_back ( lvl ); } } public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < int > candidates = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; build ( k , n , 0 , 0 , candidates ); return answer ; } };","title":"Code"},{"location":"stacks/problems/","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"],"text":"Stack Problems Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution. Nearest greater to right or Next Largest Element Problem statement Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1 Brute Force approach Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None Optimized solution with Stacks Stack implementation from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0 Optimized apporach with stacks We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ])) Nearest greater to left (NGEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1 Approach Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1] Nearest smaller to left (NSEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2 Approach Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1] Minimum Stack with extra space Problem Statement Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called. Constraints \\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop. Approach We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } }; Time Complexity push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\) Space Complexity At the very worst total space complexity is \\(\\mathcal{O}(N)\\) Stock Span Problem Problem Statement Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day. Example testcase For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\) Approach If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; } Time Complexity At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() . Space Complexity Space complexity is \\(O(\\mathcal{N})\\) . Maximum Area Histogram Problem Statement Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram. Examples Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Thought process Brainstorm! Approach Proper Approach! Time and Space complexity \\(O(\\mathcal{N})\\) time and space is taken. Code Subroutines Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right. NSR (NSE, Nearest smaller to the Right) implementation #include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; } NSEle (Nearest smaller to the left) implementation vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; } The main function maxAreaHistogram() void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; } Testing the code out int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; } Output TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10 Max Area Rectangle under binary matrix Problem On leetcode \\(\\to\\) Problem Statement Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Constraints: rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) . Approach Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels. The Skyline problem Same Problem on Leetcode \\(\\to\\) Problem Statement A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. Score of Parentheses Problem on leetcode \\(\\to\\) Problem Statement Given a balanced parentheses string s, return the score of the string - \"()\" has score 1, - AB has score A + B, where A and B are balanced parentheses strings, - (A) has score 2 * A, where A is a balanced parentheses string. Examples Input: s = \"()\" Output: 1 Input: s = \"(())\" Output: 2 Input: s = \"()()\" Output: 2 Constraints \\(2\\) <= s.length <= \\(50\\) s consists of only '(' and ')' . s is always a balanced parentheses string. Approach Using recursion because seems like a recursive problem with pattern of return (what is inside of(what is inside of (what is inside))) . C++ code class Solution { private : int globalTracker = 0 ; public : int scoreOfParentheses ( string s ) { int score = 0 ; // Using recursion bcz seems like a recursive problem // return (what is inside of(what is inside of (what is inside))) while ( globalTracker < s . size () - 1 ){ char first = s . at ( globalTracker ); globalTracker ++ ; char second = s . at ( globalTracker ); if ( first == '(' ){ if ( second == ')' ){ score = score + 1 ; globalTracker ++ ; } else { score = score + 2 * ( scoreOfParentheses ( s )); } } else { return score ; } } return score ; } };","title":"Stack Problems"},{"location":"stacks/problems/#stack-problems","text":"Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution.","title":" Stack Problems"},{"location":"stacks/problems/#nearest-greater-to-right-or-next-largest-element","text":"","title":"Nearest greater to right or Next Largest Element"},{"location":"stacks/problems/#problem-statement","text":"Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples","text":"Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1","title":"Examples"},{"location":"stacks/problems/#brute-force-approach","text":"Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None","title":"Brute Force approach"},{"location":"stacks/problems/#optimized-solution-with-stacks","text":"","title":"Optimized solution with Stacks"},{"location":"stacks/problems/#stack-implementation","text":"from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0","title":"Stack implementation"},{"location":"stacks/problems/#optimized-apporach-with-stacks","text":"We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ]))","title":"Optimized apporach with stacks"},{"location":"stacks/problems/#nearest-greater-to-left-ngele","text":"","title":"Nearest greater to left (NGEle)"},{"location":"stacks/problems/#problem-statement_1","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_1","text":"Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1","title":"Examples"},{"location":"stacks/problems/#approach","text":"Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#nearest-smaller-to-left-nsele","text":"","title":"Nearest smaller to left (NSEle)"},{"location":"stacks/problems/#problem-statement_2","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_2","text":"Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2","title":"Examples"},{"location":"stacks/problems/#approach_1","text":"Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#minimum-stack-with-extra-space","text":"","title":"Minimum Stack with extra space"},{"location":"stacks/problems/#problem-statement_3","text":"Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called.","title":"Problem Statement"},{"location":"stacks/problems/#constraints","text":"\\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop.","title":"Constraints"},{"location":"stacks/problems/#approach_2","text":"We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Approach"},{"location":"stacks/problems/#time-complexity","text":"push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\)","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity","text":"At the very worst total space complexity is \\(\\mathcal{O}(N)\\)","title":"Space Complexity"},{"location":"stacks/problems/#stock-span-problem","text":"","title":"Stock Span Problem"},{"location":"stacks/problems/#problem-statement_4","text":"Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day.","title":"Problem Statement"},{"location":"stacks/problems/#example-testcase","text":"For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\)","title":"Example testcase"},{"location":"stacks/problems/#approach_3","text":"If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; }","title":"Approach"},{"location":"stacks/problems/#time-complexity_1","text":"At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() .","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity_1","text":"Space complexity is \\(O(\\mathcal{N})\\) .","title":"Space Complexity"},{"location":"stacks/problems/#maximum-area-histogram","text":"","title":"Maximum Area Histogram"},{"location":"stacks/problems/#problem-statement_5","text":"Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram.","title":"Problem Statement"},{"location":"stacks/problems/#examples_3","text":"Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.","title":"Examples"},{"location":"stacks/problems/#thought-process","text":"Brainstorm!","title":"Thought process"},{"location":"stacks/problems/#approach_4","text":"Proper Approach!","title":"Approach"},{"location":"stacks/problems/#time-and-space-complexity","text":"\\(O(\\mathcal{N})\\) time and space is taken.","title":"Time and Space complexity"},{"location":"stacks/problems/#code","text":"","title":"Code"},{"location":"stacks/problems/#subroutines","text":"Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right.","title":"Subroutines"},{"location":"stacks/problems/#nsr-nse-nearest-smaller-to-the-right-implementation","text":"#include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; }","title":"NSR (NSE, Nearest smaller to the Right) implementation"},{"location":"stacks/problems/#nsele-nearest-smaller-to-the-left-implementation","text":"vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; }","title":"NSEle (Nearest smaller to the left) implementation"},{"location":"stacks/problems/#the-main-function-maxareahistogram","text":"void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; }","title":"The main function maxAreaHistogram()"},{"location":"stacks/problems/#testing-the-code-out","text":"int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; }","title":"Testing the code out"},{"location":"stacks/problems/#output","text":"TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10","title":"Output"},{"location":"stacks/problems/#max-area-rectangle-under-binary-matrix","text":"Problem On leetcode \\(\\to\\)","title":"Max Area Rectangle under binary matrix"},{"location":"stacks/problems/#problem-statement_6","text":"Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture.","title":"Problem Statement"},{"location":"stacks/problems/#constraints_1","text":"rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) .","title":"Constraints:"},{"location":"stacks/problems/#approach_5","text":"Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels.","title":"Approach"},{"location":"stacks/problems/#the-skyline-problem","text":"Same Problem on Leetcode \\(\\to\\)","title":"The Skyline problem"},{"location":"stacks/problems/#problem-statement_7","text":"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.","title":"Problem Statement"},{"location":"stacks/problems/#score-of-parentheses","text":"Problem on leetcode \\(\\to\\)","title":"Score of Parentheses"},{"location":"stacks/problems/#problem-statement_8","text":"Given a balanced parentheses string s, return the score of the string - \"()\" has score 1, - AB has score A + B, where A and B are balanced parentheses strings, - (A) has score 2 * A, where A is a balanced parentheses string.","title":"Problem Statement"},{"location":"stacks/problems/#examples_4","text":"Input: s = \"()\" Output: 1 Input: s = \"(())\" Output: 2 Input: s = \"()()\" Output: 2","title":"Examples"},{"location":"stacks/problems/#constraints_2","text":"\\(2\\) <= s.length <= \\(50\\) s consists of only '(' and ')' . s is always a balanced parentheses string.","title":"Constraints"},{"location":"stacks/problems/#approach_6","text":"Using recursion because seems like a recursive problem with pattern of return (what is inside of(what is inside of (what is inside))) .","title":"Approach"},{"location":"stacks/problems/#c-code","text":"class Solution { private : int globalTracker = 0 ; public : int scoreOfParentheses ( string s ) { int score = 0 ; // Using recursion bcz seems like a recursive problem // return (what is inside of(what is inside of (what is inside))) while ( globalTracker < s . size () - 1 ){ char first = s . at ( globalTracker ); globalTracker ++ ; char second = s . at ( globalTracker ); if ( first == '(' ){ if ( second == ')' ){ score = score + 1 ; globalTracker ++ ; } else { score = score + 2 * ( scoreOfParentheses ( s )); } } else { return score ; } } return score ; } };","title":"C++ code"},{"location":"stacks/usage/","text":"Implementation of Stacks and Queues A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes. Source Code from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ]) Stacks implementation with Deque Module class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \" Stacks implementation with C++ With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks Usage"},{"location":"stacks/usage/#implementation-of-stacks-and-queues","text":"A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes.","title":" Implementation of Stacks and Queues"},{"location":"stacks/usage/#source-code","text":"from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ])","title":"Source Code"},{"location":"stacks/usage/#stacks-implementation-with-deque-module","text":"class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \"","title":"Stacks implementation with Deque Module"},{"location":"stacks/usage/#stacks-implementation-with-c","text":"With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks implementation with C++"},{"location":"trees/implementation/","text":"Tree implementation Tree is a non linear graph data structure which has no cycle. Tree is hiararchical data structure, any sort of data that has some sort of hiararchy we can use a tree to represent, get, delete efficiently. Tree Standard struct STL don't have general binary tree representation [has red black tree (height balanced binary search tree)]. The following struct can be used to represent a tree structure. struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; // Create a Tree Structure int main () { TreeNode * root = new TreeNode ( 12 ); root -> left = new TreeNode ( 112 ); root -> right = new TreeNode ( 44 ); } Visual representation of the structure : graph TD subgraph After Inserstions 12((12)) --> 44((44)) & 112((112)) 112 --> aa[null_ptr] & bb[null_ptr] 44 --> aaa[null_ptr] & bbb[null_ptr] end subgraph At the start A((12)) --> b[null_ptr] & c[null_ptr] end Tree from input stream Now for some cases you may have to take input from a stream of numbers and create a tree structure from them. Here is a detailed implementation on how to do that. First we create a character array and put the entire stream into that character array, // Get complete binray tree input from a stream char a [ 1000 ]; cin . getline ( a , 1000 ); Now we create a vector and we'll tokenize the character array and get all the numbers from them into the vector. vector < int > v ; // String TOKENIZER to get all the numbers and convert them into integers // then push it into the vector char * ans = strtok ( a , \" \" ); while ( ans != NULL ){ v . push_back ( stoi ( ans )); ans = strtok ( NULL , \" \" ); } Now most of the cases this will be some traversal order, and from this traversal order we create a binary tree. The most logical way one can provide the input is that they give you the level order traversal of the tree in that stream. Here is a Tree Class and a function to create a binary tree from a vector of numbers. // Tree Definition class Tree { public : int data ; Tree * left , * right ; Tree ( int d ){ data = d ; left = nullptr ; right = nullptr ; } }; Creating tree from the input vector Tree * createTreeFromVector ( vector < int > v ) { if ( v . size () == 0 ) return nullptr ; int root = v [ 0 ]; Tree * treeRoot = new Tree ( root ); // start from the 1st element and push into a queue and add it to left of root; // because we push data in from left to right in complete binary tree queue < Tree *> q ; q . push ( treeRoot ); int i = 1 ; while ( ! q . empty ()){ Tree * thisNode = q . front (); q . pop (); thisNode -> left = new Tree ( v [ i ++ ]); q . push ( thisNode -> left ); if ( i >= v . size ()) break ; thisNode -> right = new Tree ( v [ i ++ ]); q . push ( thisNode -> right ); if ( i >= v . size ()) break ; } return treeRoot ; } See the problem section now Tree Problem Section","title":"Tree Implementation"},{"location":"trees/implementation/#tree-implementation","text":"Tree is a non linear graph data structure which has no cycle. Tree is hiararchical data structure, any sort of data that has some sort of hiararchy we can use a tree to represent, get, delete efficiently.","title":" Tree implementation"},{"location":"trees/implementation/#tree-standard-struct","text":"STL don't have general binary tree representation [has red black tree (height balanced binary search tree)]. The following struct can be used to represent a tree structure. struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; // Create a Tree Structure int main () { TreeNode * root = new TreeNode ( 12 ); root -> left = new TreeNode ( 112 ); root -> right = new TreeNode ( 44 ); } Visual representation of the structure : graph TD subgraph After Inserstions 12((12)) --> 44((44)) & 112((112)) 112 --> aa[null_ptr] & bb[null_ptr] 44 --> aaa[null_ptr] & bbb[null_ptr] end subgraph At the start A((12)) --> b[null_ptr] & c[null_ptr] end","title":"Tree Standard struct"},{"location":"trees/implementation/#tree-from-input-stream","text":"Now for some cases you may have to take input from a stream of numbers and create a tree structure from them. Here is a detailed implementation on how to do that. First we create a character array and put the entire stream into that character array, // Get complete binray tree input from a stream char a [ 1000 ]; cin . getline ( a , 1000 ); Now we create a vector and we'll tokenize the character array and get all the numbers from them into the vector. vector < int > v ; // String TOKENIZER to get all the numbers and convert them into integers // then push it into the vector char * ans = strtok ( a , \" \" ); while ( ans != NULL ){ v . push_back ( stoi ( ans )); ans = strtok ( NULL , \" \" ); } Now most of the cases this will be some traversal order, and from this traversal order we create a binary tree. The most logical way one can provide the input is that they give you the level order traversal of the tree in that stream. Here is a Tree Class and a function to create a binary tree from a vector of numbers. // Tree Definition class Tree { public : int data ; Tree * left , * right ; Tree ( int d ){ data = d ; left = nullptr ; right = nullptr ; } }; Creating tree from the input vector Tree * createTreeFromVector ( vector < int > v ) { if ( v . size () == 0 ) return nullptr ; int root = v [ 0 ]; Tree * treeRoot = new Tree ( root ); // start from the 1st element and push into a queue and add it to left of root; // because we push data in from left to right in complete binary tree queue < Tree *> q ; q . push ( treeRoot ); int i = 1 ; while ( ! q . empty ()){ Tree * thisNode = q . front (); q . pop (); thisNode -> left = new Tree ( v [ i ++ ]); q . push ( thisNode -> left ); if ( i >= v . size ()) break ; thisNode -> right = new Tree ( v [ i ++ ]); q . push ( thisNode -> right ); if ( i >= v . size ()) break ; } return treeRoot ; }","title":"Tree from input stream"},{"location":"trees/implementation/#see-the-problem-section-now","text":"Tree Problem Section","title":"See the problem section now"},{"location":"trees/problems/","text":"Tree Problems Questions discussed Traversal problems N-ary Tree Preorder Traversal Balanced Binary Tree Branch Sum Problem Invert a binary tree Iterative In Order Traversal Minimum Depth of a Binary Tree Connect Level Order Siblings Binary Tree Path Sum Count All Paths for a Sum Traceout All Paths for a Sum Validate a Binary Search Tree Find Kth Largest value in the binary search tree Find the total number of Binary Search Trees possible Same Binary Search Tree Binary Search Tree Iterator Count Complete Tree Nodes Deepest Leaves Sum Sum of Nodes with Even-Valued Grandparent Same Tree Flatten Binary Tree to Linked List Lowest Common Ancestor of a Binary Search Tree Maximum Product of Splitted Binary Tree Count Good Nodes in Binary Tree Trim a Binary Search Tree Binary Tree Right Side View Traversal problems Inorder, preorder, and postorder traversal Let's don't waste time and finish the \"confusing\" topic of pre order, post order and in order traversal on binary trees. Most of my friends tell me that they often forget how each traversal works and ask me how to remember them. Well, here you go When running through a tree (binary or binary search tree) we start from the root. Now arrange the queue of nodes like this if we visit the node for the first time we add that to the pre-order queue, the node for the second time we add that to the in-order queue, the node for the 3rd time we add that to the post-order queue. And now you have 3 queues each with pre-in-post order traversal path. Also make a note that if the binary tree is a binary search tree, then the in-order traversal will give a sorted array. We can use this property to check if the binary tree is a binary search tree or not. More formal definition Pre order traversal is implemented like this: \\(\\text{Root} \\to \\text{Left} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Root} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) C++ Code // Definition of the tree node struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; void inOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { inOrderTraversal ( nodePointer -> left ); printf ( \"%d \" , nodePointer -> data ); inOrderTraversal ( nodePointer -> right ); } } void preOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { printf ( \"%d \" , nodePointer -> data ); preOrderTraversal ( nodePointer -> left ); preOrderTraversal ( nodePointer -> right ); } } void postOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { postOrderTraversal ( nodePointer -> left ); postOrderTraversal ( nodePointer -> right ); printf ( \"%d \" , nodePointer -> data ); } } Level order traversal for binary trees For the following binary tree graph TB 12((12)) --> 44((44)) & 112((112)) 112 --> aa((34)) & bb((55)) 44 --> aaa((69)) & bbb((420)) The equivalent level order traversal should be graph LR a[12] --> b[44] --> c[112] --> 34 --> 55 --> 69 --> 420 Approach If you see there is a queuing order, every level of the tree gets processed from left to right. Then in the next level they are processed from left to right as well as their parent's order. So if we use a queue we can solve this problem. With queue we can solve this problem, and here is a step by step approach Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> v ; if ( ! root ) return v ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , depth }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( depth > v . size ()) { vector < int > v1 ; v1 . push_back ( front -> val ); v . push_back ( v1 ); } else if ( depth == v . size ()) { v [ depth - 1 ]. push_back ( front -> val ); } if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } return v ; } }; N-ary Tree Preorder Traversal Problem on Leetcode \\(\\to\\) Problem Statement Given the root of an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples) Example Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] Approach We know the approach to find the preorder traversal of a binary tree, there we'd do the root, then left then right Instead here we'll do the root, then first from the left, then second from the left and so on until we reach n'th children of the root. So the coding should be pretty simple as following Code /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { private : vector < int > order ; public : vector < int > preorder ( Node * root ) { if ( root ) { order . push_back ( root -> val ); for ( auto tr : root -> children ) { preorder ( tr ); } } return order ; } }; Balanced Binary Tree Problem on leetcode \\(\\to\\) Problem Statement Given a binary tree, determine if it is height-balanced. Approach If a binary tree is height-balanced then the difference of height of the right subtree and left subtree should not be greater than 2. Now from the last problem we can recursivly find the height of the left and right subtrees and check if the difference between them is > 1. If at any point we find that the height difference is > 1, we indicate this some how to the main function and say it's not height balanced. Code class Solution { public : int height ( TreeNode * root ) { if ( ! root ) return 0 ; // recursively find the height of subtrees int leftheight = height ( root -> left ); int rightheight = height ( root -> right ); // if we find a height imbalance we inform it to the parent. if ( std :: abs ( leftheight - rightheight ) > 1 ) return -1 ; // If [at parent] we find one of the subtrees has height imbalance // we return -1 and exit the program if ( leftheight == -1 or rightheight == -1 ) return -1 ; return 1 + max ( leftheight , rightheight ); } bool isBalanced ( TreeNode * root ) { // if the subroutine finds anywhere in the tree a height imbalance // we return false. return height ( root ) != -1 ; } }; Branch Sum Problem Problem Statement You'll be given the root node of the binary tree. Now you have to return all the branch's \"SUM\" in a vector. Example: Approach The code should be almost similar to the height finding recursive approach for binary trees. Here we will change the code slightly so that we pass a int sum with each recursion and continue to add until we reach the bottom of the tree. At leaf node we check if (tree->left == nullptr and tree->right == nullptr) then we just push the sum to the answer and return. Code void branchSum ( vector < int > & v , Tree * tree , int sum ) { if ( tree -> left == nullptr and tree -> right == nullptr ) { v . push_back ( sum + tree -> data ); return ; } branchSum ( v , tree -> left , sum + tree -> data ); branchSum ( v , tree -> right , sum + tree -> data ); } int main (){ vector < int > v ; branchSum ( v , root , 0 ); for ( auto t : v ) cout << t << \" \" ; } Output INORDER TRAVERSAL OF THE TREE 4 2 5 1 6 3 7 Branch Sum of TREE 7 8 10 11 Invert a binary tree Problem statement You'll be given a binary tree, find out the inverted equivalent of the tree. It is prefered to do the inversion in place. Example Let's say we have a binary tree B. Inverting the binary tree will result into the mirror immage of the tree. Apporach This is probably one of the best tree questions, it seems that there are a lot of things to track here. So solving this problem requires attention to lot of details. The apporach to solve this is to swap the nodes instead of the values. First we swap the left node with the right node for the head and then recursively swap the left and right nodes for the left and right nodes. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root ){ TreeNode * temp = root -> left ; root -> left = root -> right ; root -> right = temp ; invertTree ( root -> left ); invertTree ( root -> right ); } return root ; } }; Approach With BFS I personally don't prefer any recursive approach. With BFS also we can easily solve this problem. We put the node in queue to be processed and when we are at this node if this is not NULL we swap it's left and right children. This is the way we can swap left and right thus inverting it level by level because BFS works level order. class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()){ TreeNode * thisNode = q . front (); // get front of the queue to process q . pop (); if ( thisNode != nullptr ){ // swap it's left and right TreeNode * left = thisNode -> left ; thisNode -> left = thisNode -> right ; thisNode -> right = left ; q . push ( thisNode -> left ); // put both the children to be processed later q . push ( thisNode -> right ); } } return root ; } }; Iterative In Order Traversal As you probably guessed, I don't like to use recursive approaches all that much. In tree traversals you have to iterate over the tree in the following order: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) . Now how can we avoid recursion? One possible solution could be to use stack and imitate the call stack. Code We should mimic the behavior of the recursion in the recursive implementation of the in order traversal. void iterativeInOrderTraversal ( Tree * root ){ vector < Tree *> stack ; Tree * traveller = root ; while ( true ){ if ( traveller != nullptr ){ stack . push_back ( traveller ); traveller = traveller -> left ; } else { if ( stack . empty ()) break ; traveller = stack . back (); stack . pop_back (); cout << traveller -> data << \" \" ; traveller = traveller -> right ; } } } Now that we've seen the code, we should analyse the code using a dry run. This is the starting of the algorithm . In first step we go left until the first NULL is found, and we put all the nodes into the stack so to process later. Now at this point we've reached the point where we should start processing the node. This node stack.top() do not have any left children so for left we don't do anything, and print this node, then we should go to right and process that. We keep on deleting from stack and print until we go right of Node 1. Now we reached to a non-NULL node so the if part will be executed. It will put all the left of 3 into the stack until a NULL is reached. At the very last step \\(\\text{NODE}(5)\\) will be processed which I did not show. It's a genuinely good problem and there is a lot to keep track of in the iterative version for a easy recursive problem. This goes to show how much the recursion stack actually helps, but at the cost of proper mental gymnastics to come up with a recursive approach. Minimum Depth of a Binary Tree Find the Problem on Leetcode \\(\\to\\) Problem statement Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node. Examples: Depth = Path of 1 \\(\\to\\) 3. So the code should return 2. graph TD 1((1)) --> 2((2)) & 3((3)) 2 --> 4((4)) & 5((5)) style 1 fill:#bbf, color:#fff style 3 fill:#bbf, color:#fff Depth = Path of 12 \\(\\to\\) 7 \\(\\to\\) 9. So the code should return 3. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff Approach This is a pattern related to breath first search traversal. Think of this logically, if you traverse level by level and you find the first node that is a leaf node. This means you found the shallowest node in the binary tree. You track and return the depth of that shallowest node. C++ Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , 1 }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int nextDepth = q . front (). second + 1 ; q . pop (); if ( front -> left ) q . push ({ front -> left , nextDepth }); if ( front -> right ) q . push ({ front -> right , nextDepth }); if ( ! front -> left and ! front -> right ) return nextDepth - 1 ; depth = nextDepth ; } return depth ; } }; Connect Level Order Siblings Find the Problem on Leetcode \\(\\to\\) Problem statement Given a binary tree, connect each node with its level order successor. The last node of each level should point to a null node in place. A new next attribute is added to the tree structure. Update the next in-place. Example Approach With Extra Space We store level wise node references in a vector<vector<Node *>> using BFS and a modified queue, then we link them together. To maintain the vector<vector<Node *>> we need \\(O(N)\\) Space. Code for this approach /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return root ; queue < pair < Node * , int >> q ; vector < vector < Node *>> v ; int depth = 1 ; q . push ({ root , depth }); while ( ! q . empty ()) { Node * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( depth > v . size ()) { vector < Node *> v1 ; v1 . push_back ( front ); v . push_back ( v1 ); } else if ( depth == v . size ()) { v [ depth - 1 ]. push_back ( front ); } if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } // for each level of nodes process the next attribute and set to its neighbors. for ( auto level : v ) { int size = level . size (); int index = 0 ; while ( index < size - 1 ){ level [ index ] -> next = level [ index + 1 ]; index ++ ; } level [ index ] -> next = nullptr ; } return root ; } }; Approach with a bit less space Question on Leetcode \\(\\to\\) In this approach, instead of storing the level wise ordering in a vector of vectors, we simply link the nodes as we go by just keeping one reference to the previously processed node. But still we have to keep the queue in order to run the BFS. So the extra space is actually needed which is \\(\\text{MAX(WIDTH of TREE)}\\) . Binary Tree Path Sum Problem Statement Given a binary tree and a number \u2018S\u2019, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals \u2018S\u2019. Example Path Sum = \\(28\\) . Output = TRUE. Path Sum = \\(21\\) . Output = False. No path in the following tree has sum 21. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff Code approach 1 We recursively go in depth first search and check if the sum is matching with the path, if yes we return true . class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( ! root -> left and ! root -> right ) { if ( targetSum == root -> val ) { return true ; } } return hasPathSum ( root -> left , targetSum - root -> val ) || hasPathSum ( root -> right , targetSum - root -> val ); } }; Code approach 2 It has a separate private boolean variable a which can even be modified to store how many times a path sum target is met. class Solution { private : bool a [ 2 ] = { false , false }; public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( not root -> left and not root -> right ) { if ( root -> val == targetSum ) { a [ 0 ] = true ; a [ 1 ] = true ; // sets if at least 1 true occurred } else { a [ 0 ] = false ; // resets to false if some branch did not cut it } } hasPathSum ( root -> left , targetSum - root -> val ); hasPathSum ( root -> right , targetSum - root -> val ); return a [ 0 ] || a [ 1 ]; } }; Count All Paths for a Sum In the previous example we checked if some path contains the sum or not? but here find all paths from root-to-leaf such that the sum of all the node values of each path equals \u2018S\u2019. Return the count of paths matching the sum. Approach Approach is the same as the previous approach's code # \\(2\\) , with a little modification. Instead of marking true if some path gives a match we'll update some counter. Code class Solution { private : pair < bool , int > a = { false , 0 }; // instead we put a counter in there. public : int countPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( not root -> left and not root -> right ) { if ( root -> val == targetSum ) { a . first = true ; a . second += 1 ; // updates per target sum occurrences. } else { a . first = false ; // resets to false if some branch did not cut it } } countPathSum ( root -> left , targetSum - root -> val ); countPathSum ( root -> right , targetSum - root -> val ); return a . second ; } }; Traceout All Paths for a Sum It is the same as the previous problem but here you have to return the path where the sum is matching. Return a vector<vector<Tree*>> . Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Same Problem on Leetcode \\(\\to\\) Example Target sum for the following tree: \\(34\\) graph TD 12((12)) --> 7((1)) & 1((1)) 7 --> 9((21)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf style 7 fill:#bbf style 10 fill:#bbf style 9 fill:#bbf style 11 fill:#bbf style 1 fill:#bbf Paths that returns \\(34\\) are the following: \\(12 \\to 1 \\to 21\\) \\(12 \\to 1 \\to 10 \\to 11\\) So these 2 path should be returned as the function finishes. Approach We create 2 vectors: one vector<vector<Tree*>> and one vector<Tree*> , the second one vector<Tree*> will be unique for each recursion level, When we traverse the tree Depth First we put the nodes into vector<Tree*> , When we reach the leaf node we check if the sum is matchting with the desired path sum. If yes we record the path sum. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < int > thisLevel ; vector < vector < int >> answer ; // recursively go dfs helper ( root , targetSum , thisLevel , answer ); return answer ; } void helper ( TreeNode * root , int targetSum , vector < int > thisLevel , vector < vector < int >> & answer ){ if ( ! root ) return ; thisLevel . push_back ( root -> val ); if ( not root -> left and not root -> right ) { if ( targetSum == root -> val ) { // means this path sum is exactly the targetSum // record the path answer . push_back ( thisLevel ); } } helper ( root -> left , targetSum - root -> val , thisLevel , answer ); helper ( root -> right , targetSum - root -> val , thisLevel , answer ); } }; Validate a Binary Search Tree Problem on Leetcode \\(\\to\\) Problem Statement Given a binary tree check if the binary tree conforms to the criteria for a binary search tree. Approach Given a binary tree (with unit node) it is always considered a binary search tree. Given a binary tree with one unit left node and unit right node, if \\(\\text{Val(left)} \\leq \\text{Val(parent)} \\leq \\text{Val(right)}\\) then it is a binary search tree. Given a binary tree with left subtree and right subtree, it is considered a binary search tree if both the left and right subtrees are binary search trees and condition 2 satisfies. Using these 3 steps we can determine if the binary tree is binary search tree. But using only these three steps can not independently determine if the binary tree is binary search tree? For example in the following tree, all the elements to the right subtree of the Node \\(10\\) must be greater than \\(10\\) . But the first \\(3\\) steps of the algorithm only checks for local violations. graph TD subgraph With No local and global violation 10a((10)) --> 5a((5)) & 15((15)) 5a --> 2((2)) & 5b((6)) 2 --> 1a((1)) & null1((null)) 15 --> 13((13)) & 22((22)) 13 --> null12((null)) & 14((14)) end subgraph With Global violation at 3 10((10)) --> 1((1)) & 4((4)) 4 --> 3((3)) & 6((6)) end If we look closely all the elements of right subtree for 10 the for tree with no local violation, has the value \\(\\gt 10\\) so minimum for such elements in the right subarray is at least \\(\\gt 10\\) . And there is no max limit as such for any element in the right subtree. But once we fix the right of \\(10\\) as \\(15\\) then the left of \\(15\\) can have the maximum value at most \\(14\\) (because all are integers) and at minimum \\(11\\) because it is on the right of 10. So now let's analyse for all nodes what can be the maximum and what can be the minimum value. Then if we recursively check we should check for Binary Search Tree property. Below this is a tree and for each nodes the minumum and maximum is calculated From the diagram we can see that when we travel to left, the minimum for the left children is \\(\\text{Parent.Minimum}\\) and the maximum is \\(\\text{Parent.Value}\\) . When we travel to right, the minimum for the right children is \\(\\text{Parent.Value}\\) and the maximum is \\(\\text{Parent.Maximum}\\) . So upon travel to left, bound for left's value is \\(\\text{Min} = \\text{Parent.Min}\\) and \\(\\text{Max} = \\text{Parent.Value}\\) Upon travel to right, bound for right's value is \\(\\text{Min} = \\text{Parent.Value}\\) and \\(\\text{Max} = \\text{Parent.Maximum}\\) Now let's transfer it into a working C++ Code. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : bool subRoutine ( TreeNode * root , long minim , long maxim ) { if ( ! root ) return true ; long valueHere = root -> val ; bool thisLevel = false ; if ( minim < valueHere and valueHere < maxim ) thisLevel = true ; bool isLeft = subRoutine ( root -> left , minim , root -> val ); bool isRight = subRoutine ( root -> right , root -> val , maxim ); return thisLevel && isLeft && isRight ; } public : bool isValidBST ( TreeNode * root ) { return subRoutine ( root , LONG_MIN , LONG_MAX ); } }; Find Kth Largest value in the binary search tree Problem On Leetcode \\(\\to\\) Problem Statement Given a binary search tree find the kth largest value accross all the nodes in the tree. Approach We should traverse the tree in-order, so the values encountered are in non descending order. Now we count until we reach kth smallest value. We record the kth smallest value in some variable and return. Code class Solution { private : int treeNodeCount = 1 ; // starting index is 1 int setValue ; // should hold the kth smallest value public : int kthSmallest ( TreeNode * root , int k ) { if ( root ) { kthSmallest ( root -> left , k ); if ( treeNodeCount == k ) { setValue = root -> val ; // set the kth smallest value } treeNodeCount ++ ; kthSmallest ( root -> right , k ); } return setValue ; } }; Time and memory complexity We are essentially traversing in-order so the it's \\(O(N)\\) Extra memory is \\(O(1)\\) . For usage of recursive function calls we need at least \\(O(\\lg N)\\) (height of the tree) auxiliary space. Find the total number of Binary Search Trees possible Find the Problem on Leetcode \\(\\to\\) Problem Statement Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Approach It's the nth catalan number which represents the number of structures possible with upto n nodes. Now for each structure there can be only one inorder traversal which represents to a sorted order. So n'th catalan number is the answer. Code class Solution { private : unsigned long int catalan ( int n ) { vector < unsigned long int > catalanTable ; catalanTable . push_back ( 1 ); // catalan(0) catalanTable . push_back ( 1 ); // catalan(1) for ( int i = 2 ; i <= n ; i ++ ) { catalanTable . push_back ( 0 ); for ( int j = 0 ; j < i ; j ++ ) catalanTable [ i ] += catalanTable [ j ] * catalanTable [ i - j - 1 ]; } return catalanTable . back (); } public : int numTrees ( int n ) { // catalan's number is the answer return ( int ) catalan ( n ); } }; Same Binary Search Tree Problem Statement You are given 2 sequences of numbers. Find out if you put numbers in a binary search tree in those 2 orders it'll be the same binary search tree. The caveat is that you can't construct the tree yourself and compare using some tree traversal techniques. Input Format You'll be given 2 binary search tree insertion order in 2 vector<int> . This is the order you are expected to insert into the binary search tree. Compare both and return true if the binary search trees are essentially the same. Example vector<int> v1 = {10, 15, 8, 12, 94, 81, 5, 2, 11}; and vector<int> v2 = {10, 8, 5, 15, 2, 12, 11, 94, 81} inserting using v1 order and v2 order will result in the same binary search tree, so the function will return true . Approach If we look closely we'll see that the binary search tree is constructed uniquely if all the elements coming to left of the root element (10) is in the same order in both the cases. The elements that is greater than the root element (10) will not interfere with the left subtree of the binary search tree. So we compare the order of elements < root (10) and compare order of elements > root (10). If the order are same then both must be the same binary search tree. Time and Space complexity No extra space is required, the algorithm runs in \\(O(n)\\) time. Binary Search Tree Iterator Problem on Leetcode \\(\\to\\) Problem Statement Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Approaches Straight forward apporach A straight forward solution is to build the in-order traversal when the binary search tree is constructed. Then solve the next() and hasNext() problem accordingly. Code with Straight Forward Apporach class BSTIterator { private : vector < int > inOrder ; int current ; void makeInOrder ( TreeNode * root ) { if ( root ) { makeInOrder ( root -> left ); inOrder . push_back ( root -> val ); makeInOrder ( root -> right ); } } public : BSTIterator ( TreeNode * root ) { // Make the in-order traversal beforehand makeInOrder ( root ); current = -1 ; // start with -1 // so when first next() is called we return the root } int next () { current ++ ; return inOrder [ current ]; } bool hasNext () { if ( current == inOrder . size () - 1 ) { return false ; } return true ; } }; Count Complete Tree Nodes Problem on Leetcode \\(\\to\\) Problem statement Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity. Approach We can easily solve this problem with recursion but as in this problem sub-trees of the binary tree is complete binary tree we can use the formula to calculate the number of nodes as \\(2^{\\text{height}}\\) . This way the overall time complexity reduces. Otherwise if \\(O(N)\\) is possible we could just run an in order traversal algorithm to find the number of nodes in the tree. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int two_pow ( int n ) { // find 2^n int result = 1 ; while ( n != 0 ) { result *= 2 ; n -- ; } return result ; } int lh ( TreeNode * root ) { // find left height of a given tree if ( ! root ) return 0 ; return 1 + lh ( root -> left ); } int rh ( TreeNode * root ) { // find right height of a given tree if ( ! root ) return 0 ; return 1 + rh ( root -> right ); } int count ( TreeNode * root ) { int leftHeight = lh ( root ); int rightHeight = rh ( root ); // if both left and right height is the same then // with respect to the root at current recursion level it is balanced and complete // so the number of node will be 2^n - 1 if ( leftHeight == rightHeight ) { return two_pow ( leftHeight ) - 1 ; } // else we continue with the normal recursive counting return 1 + count ( root -> left ) + count ( root -> right ); } public : int countNodes ( TreeNode * root ) { if ( not root ) return 0 ; return count ( root ); } }; Deepest Leaves Sum Problem on Leetcode \\(\\to\\) Problem Statemet Given the root of a binary tree, return the sum of values of its deepest leaves. Approach We shoud use my BFS technique with passing depth. Using this technique when we find a leaf node we store it in a pair<int, int> and save the depth. If we find a leaf node less than this depth, so this can not be in the answer so we ignore it. If we find a leaf node is at the same level this means it can be included in the answer and later if we find any node at a deeper depth we'll discard all the calculations before. So here is the code using the upper approach /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : pair < int , int > sumAndDepth = { 0 , 0 }; int deepestLeavesSum ( TreeNode * root ) { queue < pair < TreeNode * , int >> q ; // set root node at depth 1 q . push ({ root , 1 }); while ( ! q . empty ()) { TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( not front -> left and not front -> right ) { // it is a leaf node if ( depth == sumAndDepth . second ) { // if the leaf node is at 'presumably' the deepest node // add the values sumAndDepth . first += front -> val ; sumAndDepth . second = depth ; } else if ( depth > sumAndDepth . second ) { // else if some other node is at a greater depth // reset the depth and sum sumAndDepth . first = 0 + front -> val ; sumAndDepth . second = depth ; } } // simple BFS strategy if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } return sumAndDepth . first ; // return the sum at the last } }; Sum of Nodes with Even-Valued Grandparent Problem on Leetcode \\(\\to\\) Problem Statement Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent of a node is the parent of its parent if it exists. Approach It's a simple recursive problem, we'll get to every node and check if it is even then if it has a grandparent. Every node has 4 possible grand-children: left of left children, right of left children, right of right children, left of right children, With that apporach let's code Code class Solution { private : int sum = 0 ; public : int sumEvenGrandparent ( TreeNode * root ) { if ( root ) { if ( root -> val % 2 == 0 ) { // if even number check all the grandchildren if ( root -> left ) { if ( root -> left -> left ) { sum += root -> left -> left -> val ; } if ( root -> left -> right ) { sum += root -> left -> right -> val ; } } if ( root -> right ) { if ( root -> right -> left ) { sum += root -> right -> left -> val ; } if ( root -> right -> right ) { sum += root -> right -> right -> val ; } } } sumEvenGrandparent ( root -> left ); sumEvenGrandparent ( root -> right ); } return sum ; } }; Same Tree Problem on Leetcode \\(\\to\\) Problem Statement Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example Input: p = [1,2,3], q = [1,2,3] Output: true Approach We'll go through both the tree with a simultaneous in-order traversal, if we find any incorrect order we'll report false. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( not p and not q ) return true ; if ( p and q ) { return ( p -> val == q -> val ) and isSameTree ( p -> left , q -> left ) and isSameTree ( p -> right , q -> right ); } return false ; } }; Flatten Binary Tree to Linked List Find Problem on Leetcode \\(\\to\\) Problem Statement Given the root of a binary tree, flatten the tree into a \"linked list\": The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The \"linked list\" should be in the same order as a pre-order traversal of the binary tree. Approach We have to solve this using a recursive approach, otherwise, the problem will become too complicated to solve because then you also have to keep track of the call stack. In recursion, we'll assume we have a leftEnd and rightEnd after the recursion, for any given root of the binary tree leftEnd is the flattened root->left of that root. Now as per the problem statement we set the following three leftEnd->right = root->right; root->right = root->left; root->left = nullptr; and now at the end, we return the __End , which is used recursively to connect the flattened binary tree. We'll return the rightEnd if possible else the leftEnd or root . Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : TreeNode * recursive_descent ( TreeNode * root ) { if ( root ) { TreeNode * leftEnd = recursive_descent ( root -> left ); TreeNode * rightEnd = recursive_descent ( root -> right ); if ( root -> left ) { leftEnd -> right = root -> right ; root -> right = root -> left ; root -> left = nullptr ; } if ( rightEnd ) return rightEnd ; else if ( not rightEnd and leftEnd ) return leftEnd ; else return root ; } return nullptr ; } public : void flatten ( TreeNode * root ) { recursive_descent ( root ); } }; Lowest Common Ancestor of a Binary Search Tree Problem Statement Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d Approach We'll use a simple recursive technique to find the lowest common ancestor, if the node p and node q are in different subtrees from a certain root, then it is must that the root is the lowest common ancestor. If we find the both the node p and node q are in the same subtree, we'll recursively descent into that subtree in search for the lowest common ancestor. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { bool findOnSubTree ( TreeNode * root , TreeNode * q ) { if ( root ) { return findOnSubTree ( root -> left , q ) or ( root -> val == q -> val ) or findOnSubTree ( root -> right , q ); } return false ; } public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { // check if both in the same tree or not? // recursively go to that subtree only if ( findOnSubTree ( root -> left , p ) and findOnSubTree ( root -> left , q )) { return lowestCommonAncestor ( root -> left , p , q ); } else if ( findOnSubTree ( root -> right , p ) and findOnSubTree ( root -> right , q )) { return lowestCommonAncestor ( root -> right , p , q ); } // now check if both are in different subtree or not? if ( findOnSubTree ( root -> left , p ) and findOnSubTree ( root -> right , q )) { return root ; } else if ( findOnSubTree ( root -> right , p ) and findOnSubTree ( root -> left , q )) { return root ; } // base case all must have the ancestor root return root ; } }; Another approach We can also take on the fact that we have a binary search tree, so we can say that if we start at the root node of the tree then if p and q value both are less than the root we search in the left subtree and if p and q value both are greater than the root node we search in the right subtree. Any case other than that, means values have split between left and right subtrees from that position, that means this is the lowest common ancestor. So return that. Code for this approach class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { TreeNode * current = root ; while ( current ) { if ( p -> val < current -> val and q -> val < current -> val ) { current = current -> left ; } else if ( p -> val > current -> val and q -> val > current -> val ) { current = current -> right ; } else { return current ; } } // base case of all return root ; } }; Maximum Product of Splitted Binary Tree Find the problem on Leetcode \\(\\to\\) Problem Statement Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo \\(10^9 + 7\\) . Note that you need to maximize the answer before taking the mod and not after taking it. Examples Input: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6) Approach We'll find the sum in each of the subtrees. If we know the sum of a subtree, the answer is max( (total_sum - subtree_sum) * subtree_sum) in each node. To find the total_sum we run a subroutine helper() that'll find the sum with post order traversal. At the end keep track of the max of max( (total_sum - subtree_sum) * subtree_sum) for each of the subtrees for every node. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int M = 1e9 + 7 ; long long max_prod = 0 ; int helper ( TreeNode * root ) { int total = 0 ; if ( not root ) return 0 ; total += root -> val + helper ( root -> left ) + helper ( root -> right ); return total ; } int subroutine ( TreeNode * root , int total ) { if ( not root ) return 0 ; int sum = root -> val ; int left = subroutine ( root -> left , total ); int right = subroutine ( root -> right , total ); sum = sum + left + right ; max_prod = std :: max ( max_prod , ( left * 1L L ) * (( total - left ) * 1L L )); max_prod = std :: max ( max_prod , ( right * 1L L ) * (( total - right ) * 1L L )); return sum ; } public : int maxProduct ( TreeNode * root ) { int total = helper ( root ); subroutine ( root , total ); return max_prod % M ; } }; Count Good Nodes in Binary Tree Find the problem on Leetcode \\(\\to\\) Problem Statement Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree. Example Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path Node 3 -> (3,1,3) is the maximum value in the path. Approach We'll send a maxSeen so far variable down with the recursive calls. If we find a node with value greater or equal to the current node we'll increment the counter of good notes. At last we'll return the good_node_counter global variable. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int good_node_counter = 0 ; void recursive_subroutine ( TreeNode * root , int maxSeen ) { if ( not root ) return ; if ( root -> val >= maxSeen ) { good_node_counter ++ ; } maxSeen = std :: max ( maxSeen , root -> val ); recursive_subroutine ( root -> left , maxSeen ); recursive_subroutine ( root -> right , maxSeen ); } public : int goodNodes ( TreeNode * root ) { recursive_subroutine ( root , root -> val ); return good_node_counter ; } }; Trim a Binary Search Tree Find the Problem on Leetcode \\(\\to\\) Problem Statement Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. Example Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] Approach We'll do a recursive descent into the binary search tree. As it is a binary search tree we can find the way to go down the recursion based on the values at the current node. Few of the moves that we'll be taking during the recursion are the following If some root->left->val is less than the low means that the current node's left child should become the current node's left's right child (making all the left->left->right&left invalid because they will be less than the lower bound on the binary search tree). Even then there can be a problem that the new left of the current node is out of bounds again. So we recursively call the function on that same node again. After this when we are done correcting the node there may be a chance that some of the children are not corrected yet, so we recursively call the function on the left children trimBST(root->left, low, high); . We symmatically solve the right children. This is how we solved the left and the right children but we didn't solved the current root yet. To solve this we'll do a simple recursive return from the left or the right depending upon the value at the root node. if ( root -> val < low ) return trimBST ( root -> right , low , high ); if ( root -> val > high ) return trimBST ( root -> left , low , high ); Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * trimBST ( TreeNode * root , int low , int high ) { if ( not root ) return root ; if ( root -> left and root -> left -> val < low ) { root -> left = root -> left -> right ; trimBST ( root , low , high ); } trimBST ( root -> left , low , high ); if ( root -> right and root -> right -> val > high ) { root -> right = root -> right -> left ; trimBST ( root , low , high ); } trimBST ( root -> right , low , high ); if ( root -> val < low ) return trimBST ( root -> right , low , high ); if ( root -> val > high ) return trimBST ( root -> left , low , high ); return root ; } }; Binary Tree Right Side View Find the problem on leetcode \\(\\to\\) Problem Statement Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Input: root = [1,null,3] Output: [1,3] Input: root = [] Output: [] Approach If you look closely to the example above, you can see that the right side view is the right most node of the tree for each level, armed with that knowledge you can travel level by level using a level order traversal, then find what is the last node of that level, you return that value. At the worst case the Binary Tree is skewed so at most \\(O(N)\\) space and time is required to find the right view of that tree. The following is the code example that implements this approach. Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < int > answer ; vector < int > rightSideView ( TreeNode * root ) { if ( not root ) return answer ; vector < vector < int >> levelOrder ; queue < pair < TreeNode * , int >> q ; q . push ({ root , 1 }); while ( ! q . empty ()) { TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); if ( depth > levelOrder . size ()) { vector < int > v ; v . push_back ( front -> val ); levelOrder . push_back ( v ); } else if ( depth == levelOrder . size ()){ levelOrder [ depth -1 ]. push_back ( front -> val ); } } for ( int i = 0 ; i < levelOrder . size (); i ++ ) { vector < int > lvl = levelOrder [ i ]; answer . push_back ( lvl [ lvl . size () - 1 ]); } return answer ; } };","title":"Tree Problems"},{"location":"trees/problems/#tree-problems","text":"Questions discussed Traversal problems N-ary Tree Preorder Traversal Balanced Binary Tree Branch Sum Problem Invert a binary tree Iterative In Order Traversal Minimum Depth of a Binary Tree Connect Level Order Siblings Binary Tree Path Sum Count All Paths for a Sum Traceout All Paths for a Sum Validate a Binary Search Tree Find Kth Largest value in the binary search tree Find the total number of Binary Search Trees possible Same Binary Search Tree Binary Search Tree Iterator Count Complete Tree Nodes Deepest Leaves Sum Sum of Nodes with Even-Valued Grandparent Same Tree Flatten Binary Tree to Linked List Lowest Common Ancestor of a Binary Search Tree Maximum Product of Splitted Binary Tree Count Good Nodes in Binary Tree Trim a Binary Search Tree Binary Tree Right Side View","title":" Tree Problems"},{"location":"trees/problems/#traversal-problems","text":"","title":"Traversal problems"},{"location":"trees/problems/#inorder-preorder-and-postorder-traversal","text":"Let's don't waste time and finish the \"confusing\" topic of pre order, post order and in order traversal on binary trees. Most of my friends tell me that they often forget how each traversal works and ask me how to remember them. Well, here you go When running through a tree (binary or binary search tree) we start from the root. Now arrange the queue of nodes like this if we visit the node for the first time we add that to the pre-order queue, the node for the second time we add that to the in-order queue, the node for the 3rd time we add that to the post-order queue. And now you have 3 queues each with pre-in-post order traversal path. Also make a note that if the binary tree is a binary search tree, then the in-order traversal will give a sorted array. We can use this property to check if the binary tree is a binary search tree or not.","title":"Inorder, preorder, and postorder traversal"},{"location":"trees/problems/#more-formal-definition","text":"Pre order traversal is implemented like this: \\(\\text{Root} \\to \\text{Left} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Root} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\)","title":"More formal definition"},{"location":"trees/problems/#c-code","text":"// Definition of the tree node struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; void inOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { inOrderTraversal ( nodePointer -> left ); printf ( \"%d \" , nodePointer -> data ); inOrderTraversal ( nodePointer -> right ); } } void preOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { printf ( \"%d \" , nodePointer -> data ); preOrderTraversal ( nodePointer -> left ); preOrderTraversal ( nodePointer -> right ); } } void postOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { postOrderTraversal ( nodePointer -> left ); postOrderTraversal ( nodePointer -> right ); printf ( \"%d \" , nodePointer -> data ); } }","title":"C++ Code"},{"location":"trees/problems/#level-order-traversal-for-binary-trees","text":"For the following binary tree graph TB 12((12)) --> 44((44)) & 112((112)) 112 --> aa((34)) & bb((55)) 44 --> aaa((69)) & bbb((420)) The equivalent level order traversal should be graph LR a[12] --> b[44] --> c[112] --> 34 --> 55 --> 69 --> 420","title":"Level order traversal for binary trees"},{"location":"trees/problems/#approach","text":"If you see there is a queuing order, every level of the tree gets processed from left to right. Then in the next level they are processed from left to right as well as their parent's order. So if we use a queue we can solve this problem. With queue we can solve this problem, and here is a step by step approach","title":"Approach"},{"location":"trees/problems/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> v ; if ( ! root ) return v ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , depth }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( depth > v . size ()) { vector < int > v1 ; v1 . push_back ( front -> val ); v . push_back ( v1 ); } else if ( depth == v . size ()) { v [ depth - 1 ]. push_back ( front -> val ); } if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } return v ; } };","title":"Code"},{"location":"trees/problems/#n-ary-tree-preorder-traversal","text":"Problem on Leetcode \\(\\to\\)","title":"N-ary Tree Preorder Traversal"},{"location":"trees/problems/#problem-statement","text":"Given the root of an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)","title":"Problem Statement"},{"location":"trees/problems/#example","text":"Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]","title":"Example"},{"location":"trees/problems/#approach_1","text":"We know the approach to find the preorder traversal of a binary tree, there we'd do the root, then left then right Instead here we'll do the root, then first from the left, then second from the left and so on until we reach n'th children of the root. So the coding should be pretty simple as following","title":"Approach"},{"location":"trees/problems/#code_1","text":"/* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { private : vector < int > order ; public : vector < int > preorder ( Node * root ) { if ( root ) { order . push_back ( root -> val ); for ( auto tr : root -> children ) { preorder ( tr ); } } return order ; } };","title":"Code"},{"location":"trees/problems/#balanced-binary-tree","text":"Problem on leetcode \\(\\to\\)","title":"Balanced Binary Tree"},{"location":"trees/problems/#problem-statement_1","text":"Given a binary tree, determine if it is height-balanced.","title":"Problem Statement"},{"location":"trees/problems/#approach_2","text":"If a binary tree is height-balanced then the difference of height of the right subtree and left subtree should not be greater than 2. Now from the last problem we can recursivly find the height of the left and right subtrees and check if the difference between them is > 1. If at any point we find that the height difference is > 1, we indicate this some how to the main function and say it's not height balanced.","title":"Approach"},{"location":"trees/problems/#code_2","text":"class Solution { public : int height ( TreeNode * root ) { if ( ! root ) return 0 ; // recursively find the height of subtrees int leftheight = height ( root -> left ); int rightheight = height ( root -> right ); // if we find a height imbalance we inform it to the parent. if ( std :: abs ( leftheight - rightheight ) > 1 ) return -1 ; // If [at parent] we find one of the subtrees has height imbalance // we return -1 and exit the program if ( leftheight == -1 or rightheight == -1 ) return -1 ; return 1 + max ( leftheight , rightheight ); } bool isBalanced ( TreeNode * root ) { // if the subroutine finds anywhere in the tree a height imbalance // we return false. return height ( root ) != -1 ; } };","title":"Code"},{"location":"trees/problems/#branch-sum-problem","text":"","title":"Branch Sum Problem"},{"location":"trees/problems/#problem-statement_2","text":"You'll be given the root node of the binary tree. Now you have to return all the branch's \"SUM\" in a vector.","title":"Problem Statement"},{"location":"trees/problems/#example_1","text":"","title":"Example:"},{"location":"trees/problems/#approach_3","text":"The code should be almost similar to the height finding recursive approach for binary trees. Here we will change the code slightly so that we pass a int sum with each recursion and continue to add until we reach the bottom of the tree. At leaf node we check if (tree->left == nullptr and tree->right == nullptr) then we just push the sum to the answer and return.","title":"Approach"},{"location":"trees/problems/#code_3","text":"void branchSum ( vector < int > & v , Tree * tree , int sum ) { if ( tree -> left == nullptr and tree -> right == nullptr ) { v . push_back ( sum + tree -> data ); return ; } branchSum ( v , tree -> left , sum + tree -> data ); branchSum ( v , tree -> right , sum + tree -> data ); } int main (){ vector < int > v ; branchSum ( v , root , 0 ); for ( auto t : v ) cout << t << \" \" ; } Output INORDER TRAVERSAL OF THE TREE 4 2 5 1 6 3 7 Branch Sum of TREE 7 8 10 11","title":"Code"},{"location":"trees/problems/#invert-a-binary-tree","text":"","title":"Invert a binary tree"},{"location":"trees/problems/#problem-statement_3","text":"You'll be given a binary tree, find out the inverted equivalent of the tree. It is prefered to do the inversion in place. Example Let's say we have a binary tree B. Inverting the binary tree will result into the mirror immage of the tree.","title":"Problem statement"},{"location":"trees/problems/#apporach","text":"This is probably one of the best tree questions, it seems that there are a lot of things to track here. So solving this problem requires attention to lot of details. The apporach to solve this is to swap the nodes instead of the values. First we swap the left node with the right node for the head and then recursively swap the left and right nodes for the left and right nodes. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root ){ TreeNode * temp = root -> left ; root -> left = root -> right ; root -> right = temp ; invertTree ( root -> left ); invertTree ( root -> right ); } return root ; } };","title":"Apporach"},{"location":"trees/problems/#approach-with-bfs","text":"I personally don't prefer any recursive approach. With BFS also we can easily solve this problem. We put the node in queue to be processed and when we are at this node if this is not NULL we swap it's left and right children. This is the way we can swap left and right thus inverting it level by level because BFS works level order. class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()){ TreeNode * thisNode = q . front (); // get front of the queue to process q . pop (); if ( thisNode != nullptr ){ // swap it's left and right TreeNode * left = thisNode -> left ; thisNode -> left = thisNode -> right ; thisNode -> right = left ; q . push ( thisNode -> left ); // put both the children to be processed later q . push ( thisNode -> right ); } } return root ; } };","title":"Approach With BFS"},{"location":"trees/problems/#iterative-in-order-traversal","text":"As you probably guessed, I don't like to use recursive approaches all that much. In tree traversals you have to iterate over the tree in the following order: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) . Now how can we avoid recursion? One possible solution could be to use stack and imitate the call stack.","title":"Iterative In Order Traversal"},{"location":"trees/problems/#code_4","text":"We should mimic the behavior of the recursion in the recursive implementation of the in order traversal. void iterativeInOrderTraversal ( Tree * root ){ vector < Tree *> stack ; Tree * traveller = root ; while ( true ){ if ( traveller != nullptr ){ stack . push_back ( traveller ); traveller = traveller -> left ; } else { if ( stack . empty ()) break ; traveller = stack . back (); stack . pop_back (); cout << traveller -> data << \" \" ; traveller = traveller -> right ; } } } Now that we've seen the code, we should analyse the code using a dry run. This is the starting of the algorithm . In first step we go left until the first NULL is found, and we put all the nodes into the stack so to process later. Now at this point we've reached the point where we should start processing the node. This node stack.top() do not have any left children so for left we don't do anything, and print this node, then we should go to right and process that. We keep on deleting from stack and print until we go right of Node 1. Now we reached to a non-NULL node so the if part will be executed. It will put all the left of 3 into the stack until a NULL is reached. At the very last step \\(\\text{NODE}(5)\\) will be processed which I did not show. It's a genuinely good problem and there is a lot to keep track of in the iterative version for a easy recursive problem. This goes to show how much the recursion stack actually helps, but at the cost of proper mental gymnastics to come up with a recursive approach.","title":"Code"},{"location":"trees/problems/#minimum-depth-of-a-binary-tree","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Minimum Depth of a Binary Tree"},{"location":"trees/problems/#problem-statement_4","text":"Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node.","title":"Problem statement"},{"location":"trees/problems/#examples","text":"Depth = Path of 1 \\(\\to\\) 3. So the code should return 2. graph TD 1((1)) --> 2((2)) & 3((3)) 2 --> 4((4)) & 5((5)) style 1 fill:#bbf, color:#fff style 3 fill:#bbf, color:#fff Depth = Path of 12 \\(\\to\\) 7 \\(\\to\\) 9. So the code should return 3. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff","title":"Examples:"},{"location":"trees/problems/#approach_4","text":"This is a pattern related to breath first search traversal. Think of this logically, if you traverse level by level and you find the first node that is a leaf node. This means you found the shallowest node in the binary tree. You track and return the depth of that shallowest node.","title":"Approach"},{"location":"trees/problems/#c-code_1","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , 1 }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int nextDepth = q . front (). second + 1 ; q . pop (); if ( front -> left ) q . push ({ front -> left , nextDepth }); if ( front -> right ) q . push ({ front -> right , nextDepth }); if ( ! front -> left and ! front -> right ) return nextDepth - 1 ; depth = nextDepth ; } return depth ; } };","title":"C++ Code"},{"location":"trees/problems/#connect-level-order-siblings","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Connect Level Order Siblings"},{"location":"trees/problems/#problem-statement_5","text":"Given a binary tree, connect each node with its level order successor. The last node of each level should point to a null node in place. A new next attribute is added to the tree structure. Update the next in-place.","title":"Problem statement"},{"location":"trees/problems/#example_2","text":"","title":"Example"},{"location":"trees/problems/#approach-with-extra-space","text":"We store level wise node references in a vector<vector<Node *>> using BFS and a modified queue, then we link them together. To maintain the vector<vector<Node *>> we need \\(O(N)\\) Space.","title":"Approach With Extra Space"},{"location":"trees/problems/#code-for-this-approach","text":"/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return root ; queue < pair < Node * , int >> q ; vector < vector < Node *>> v ; int depth = 1 ; q . push ({ root , depth }); while ( ! q . empty ()) { Node * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( depth > v . size ()) { vector < Node *> v1 ; v1 . push_back ( front ); v . push_back ( v1 ); } else if ( depth == v . size ()) { v [ depth - 1 ]. push_back ( front ); } if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } // for each level of nodes process the next attribute and set to its neighbors. for ( auto level : v ) { int size = level . size (); int index = 0 ; while ( index < size - 1 ){ level [ index ] -> next = level [ index + 1 ]; index ++ ; } level [ index ] -> next = nullptr ; } return root ; } };","title":"Code for this approach"},{"location":"trees/problems/#approach-with-a-bit-less-space","text":"Question on Leetcode \\(\\to\\) In this approach, instead of storing the level wise ordering in a vector of vectors, we simply link the nodes as we go by just keeping one reference to the previously processed node. But still we have to keep the queue in order to run the BFS. So the extra space is actually needed which is \\(\\text{MAX(WIDTH of TREE)}\\) .","title":"Approach with a bit less space"},{"location":"trees/problems/#binary-tree-path-sum","text":"","title":"Binary Tree Path Sum"},{"location":"trees/problems/#problem-statement_6","text":"Given a binary tree and a number \u2018S\u2019, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals \u2018S\u2019.","title":"Problem Statement"},{"location":"trees/problems/#example_3","text":"Path Sum = \\(28\\) . Output = TRUE. Path Sum = \\(21\\) . Output = False. No path in the following tree has sum 21. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff","title":"Example"},{"location":"trees/problems/#code-approach-1","text":"We recursively go in depth first search and check if the sum is matching with the path, if yes we return true . class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( ! root -> left and ! root -> right ) { if ( targetSum == root -> val ) { return true ; } } return hasPathSum ( root -> left , targetSum - root -> val ) || hasPathSum ( root -> right , targetSum - root -> val ); } };","title":"Code approach 1"},{"location":"trees/problems/#code-approach-2","text":"It has a separate private boolean variable a which can even be modified to store how many times a path sum target is met. class Solution { private : bool a [ 2 ] = { false , false }; public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( not root -> left and not root -> right ) { if ( root -> val == targetSum ) { a [ 0 ] = true ; a [ 1 ] = true ; // sets if at least 1 true occurred } else { a [ 0 ] = false ; // resets to false if some branch did not cut it } } hasPathSum ( root -> left , targetSum - root -> val ); hasPathSum ( root -> right , targetSum - root -> val ); return a [ 0 ] || a [ 1 ]; } };","title":"Code approach 2"},{"location":"trees/problems/#count-all-paths-for-a-sum","text":"In the previous example we checked if some path contains the sum or not? but here find all paths from root-to-leaf such that the sum of all the node values of each path equals \u2018S\u2019. Return the count of paths matching the sum.","title":"Count All Paths for a Sum"},{"location":"trees/problems/#approach_5","text":"Approach is the same as the previous approach's code # \\(2\\) , with a little modification. Instead of marking true if some path gives a match we'll update some counter.","title":"Approach"},{"location":"trees/problems/#code_5","text":"class Solution { private : pair < bool , int > a = { false , 0 }; // instead we put a counter in there. public : int countPathSum ( TreeNode * root , int targetSum ) { if ( ! root ) return false ; if ( not root -> left and not root -> right ) { if ( root -> val == targetSum ) { a . first = true ; a . second += 1 ; // updates per target sum occurrences. } else { a . first = false ; // resets to false if some branch did not cut it } } countPathSum ( root -> left , targetSum - root -> val ); countPathSum ( root -> right , targetSum - root -> val ); return a . second ; } };","title":"Code"},{"location":"trees/problems/#traceout-all-paths-for-a-sum","text":"It is the same as the previous problem but here you have to return the path where the sum is matching. Return a vector<vector<Tree*>> . Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Same Problem on Leetcode \\(\\to\\)","title":"Traceout All Paths for a Sum"},{"location":"trees/problems/#example_4","text":"Target sum for the following tree: \\(34\\) graph TD 12((12)) --> 7((1)) & 1((1)) 7 --> 9((21)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf style 7 fill:#bbf style 10 fill:#bbf style 9 fill:#bbf style 11 fill:#bbf style 1 fill:#bbf Paths that returns \\(34\\) are the following: \\(12 \\to 1 \\to 21\\) \\(12 \\to 1 \\to 10 \\to 11\\) So these 2 path should be returned as the function finishes.","title":"Example"},{"location":"trees/problems/#approach_6","text":"We create 2 vectors: one vector<vector<Tree*>> and one vector<Tree*> , the second one vector<Tree*> will be unique for each recursion level, When we traverse the tree Depth First we put the nodes into vector<Tree*> , When we reach the leaf node we check if the sum is matchting with the desired path sum. If yes we record the path sum.","title":"Approach"},{"location":"trees/problems/#code_6","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < int > thisLevel ; vector < vector < int >> answer ; // recursively go dfs helper ( root , targetSum , thisLevel , answer ); return answer ; } void helper ( TreeNode * root , int targetSum , vector < int > thisLevel , vector < vector < int >> & answer ){ if ( ! root ) return ; thisLevel . push_back ( root -> val ); if ( not root -> left and not root -> right ) { if ( targetSum == root -> val ) { // means this path sum is exactly the targetSum // record the path answer . push_back ( thisLevel ); } } helper ( root -> left , targetSum - root -> val , thisLevel , answer ); helper ( root -> right , targetSum - root -> val , thisLevel , answer ); } };","title":"Code"},{"location":"trees/problems/#validate-a-binary-search-tree","text":"Problem on Leetcode \\(\\to\\)","title":"Validate a Binary Search Tree"},{"location":"trees/problems/#problem-statement_7","text":"Given a binary tree check if the binary tree conforms to the criteria for a binary search tree.","title":"Problem Statement"},{"location":"trees/problems/#approach_7","text":"Given a binary tree (with unit node) it is always considered a binary search tree. Given a binary tree with one unit left node and unit right node, if \\(\\text{Val(left)} \\leq \\text{Val(parent)} \\leq \\text{Val(right)}\\) then it is a binary search tree. Given a binary tree with left subtree and right subtree, it is considered a binary search tree if both the left and right subtrees are binary search trees and condition 2 satisfies. Using these 3 steps we can determine if the binary tree is binary search tree. But using only these three steps can not independently determine if the binary tree is binary search tree? For example in the following tree, all the elements to the right subtree of the Node \\(10\\) must be greater than \\(10\\) . But the first \\(3\\) steps of the algorithm only checks for local violations. graph TD subgraph With No local and global violation 10a((10)) --> 5a((5)) & 15((15)) 5a --> 2((2)) & 5b((6)) 2 --> 1a((1)) & null1((null)) 15 --> 13((13)) & 22((22)) 13 --> null12((null)) & 14((14)) end subgraph With Global violation at 3 10((10)) --> 1((1)) & 4((4)) 4 --> 3((3)) & 6((6)) end If we look closely all the elements of right subtree for 10 the for tree with no local violation, has the value \\(\\gt 10\\) so minimum for such elements in the right subarray is at least \\(\\gt 10\\) . And there is no max limit as such for any element in the right subtree. But once we fix the right of \\(10\\) as \\(15\\) then the left of \\(15\\) can have the maximum value at most \\(14\\) (because all are integers) and at minimum \\(11\\) because it is on the right of 10. So now let's analyse for all nodes what can be the maximum and what can be the minimum value. Then if we recursively check we should check for Binary Search Tree property. Below this is a tree and for each nodes the minumum and maximum is calculated From the diagram we can see that when we travel to left, the minimum for the left children is \\(\\text{Parent.Minimum}\\) and the maximum is \\(\\text{Parent.Value}\\) . When we travel to right, the minimum for the right children is \\(\\text{Parent.Value}\\) and the maximum is \\(\\text{Parent.Maximum}\\) . So upon travel to left, bound for left's value is \\(\\text{Min} = \\text{Parent.Min}\\) and \\(\\text{Max} = \\text{Parent.Value}\\) Upon travel to right, bound for right's value is \\(\\text{Min} = \\text{Parent.Value}\\) and \\(\\text{Max} = \\text{Parent.Maximum}\\) Now let's transfer it into a working C++ Code.","title":"Approach"},{"location":"trees/problems/#code_7","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : bool subRoutine ( TreeNode * root , long minim , long maxim ) { if ( ! root ) return true ; long valueHere = root -> val ; bool thisLevel = false ; if ( minim < valueHere and valueHere < maxim ) thisLevel = true ; bool isLeft = subRoutine ( root -> left , minim , root -> val ); bool isRight = subRoutine ( root -> right , root -> val , maxim ); return thisLevel && isLeft && isRight ; } public : bool isValidBST ( TreeNode * root ) { return subRoutine ( root , LONG_MIN , LONG_MAX ); } };","title":"Code"},{"location":"trees/problems/#find-kth-largest-value-in-the-binary-search-tree","text":"Problem On Leetcode \\(\\to\\)","title":"Find Kth Largest value in the binary search tree"},{"location":"trees/problems/#problem-statement_8","text":"Given a binary search tree find the kth largest value accross all the nodes in the tree.","title":"Problem Statement"},{"location":"trees/problems/#approach_8","text":"We should traverse the tree in-order, so the values encountered are in non descending order. Now we count until we reach kth smallest value. We record the kth smallest value in some variable and return.","title":"Approach"},{"location":"trees/problems/#code_8","text":"class Solution { private : int treeNodeCount = 1 ; // starting index is 1 int setValue ; // should hold the kth smallest value public : int kthSmallest ( TreeNode * root , int k ) { if ( root ) { kthSmallest ( root -> left , k ); if ( treeNodeCount == k ) { setValue = root -> val ; // set the kth smallest value } treeNodeCount ++ ; kthSmallest ( root -> right , k ); } return setValue ; } };","title":"Code"},{"location":"trees/problems/#time-and-memory-complexity","text":"We are essentially traversing in-order so the it's \\(O(N)\\) Extra memory is \\(O(1)\\) . For usage of recursive function calls we need at least \\(O(\\lg N)\\) (height of the tree) auxiliary space.","title":"Time and memory complexity"},{"location":"trees/problems/#find-the-total-number-of-binary-search-trees-possible","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Find the total number of Binary Search Trees possible"},{"location":"trees/problems/#problem-statement_9","text":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.","title":"Problem Statement"},{"location":"trees/problems/#approach_9","text":"It's the nth catalan number which represents the number of structures possible with upto n nodes. Now for each structure there can be only one inorder traversal which represents to a sorted order. So n'th catalan number is the answer.","title":"Approach"},{"location":"trees/problems/#code_9","text":"class Solution { private : unsigned long int catalan ( int n ) { vector < unsigned long int > catalanTable ; catalanTable . push_back ( 1 ); // catalan(0) catalanTable . push_back ( 1 ); // catalan(1) for ( int i = 2 ; i <= n ; i ++ ) { catalanTable . push_back ( 0 ); for ( int j = 0 ; j < i ; j ++ ) catalanTable [ i ] += catalanTable [ j ] * catalanTable [ i - j - 1 ]; } return catalanTable . back (); } public : int numTrees ( int n ) { // catalan's number is the answer return ( int ) catalan ( n ); } };","title":"Code"},{"location":"trees/problems/#same-binary-search-tree","text":"","title":"Same Binary Search Tree"},{"location":"trees/problems/#problem-statement_10","text":"You are given 2 sequences of numbers. Find out if you put numbers in a binary search tree in those 2 orders it'll be the same binary search tree. The caveat is that you can't construct the tree yourself and compare using some tree traversal techniques.","title":"Problem Statement"},{"location":"trees/problems/#input-format","text":"You'll be given 2 binary search tree insertion order in 2 vector<int> . This is the order you are expected to insert into the binary search tree. Compare both and return true if the binary search trees are essentially the same.","title":"Input Format"},{"location":"trees/problems/#example_5","text":"vector<int> v1 = {10, 15, 8, 12, 94, 81, 5, 2, 11}; and vector<int> v2 = {10, 8, 5, 15, 2, 12, 11, 94, 81} inserting using v1 order and v2 order will result in the same binary search tree, so the function will return true .","title":"Example"},{"location":"trees/problems/#approach_10","text":"If we look closely we'll see that the binary search tree is constructed uniquely if all the elements coming to left of the root element (10) is in the same order in both the cases. The elements that is greater than the root element (10) will not interfere with the left subtree of the binary search tree. So we compare the order of elements < root (10) and compare order of elements > root (10). If the order are same then both must be the same binary search tree.","title":"Approach"},{"location":"trees/problems/#time-and-space-complexity","text":"No extra space is required, the algorithm runs in \\(O(n)\\) time.","title":"Time and Space complexity"},{"location":"trees/problems/#binary-search-tree-iterator","text":"Problem on Leetcode \\(\\to\\)","title":"Binary Search Tree Iterator"},{"location":"trees/problems/#problem-statement_11","text":"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.","title":"Problem Statement"},{"location":"trees/problems/#approaches","text":"","title":"Approaches"},{"location":"trees/problems/#straight-forward-apporach","text":"A straight forward solution is to build the in-order traversal when the binary search tree is constructed. Then solve the next() and hasNext() problem accordingly.","title":"Straight forward apporach"},{"location":"trees/problems/#code-with-straight-forward-apporach","text":"class BSTIterator { private : vector < int > inOrder ; int current ; void makeInOrder ( TreeNode * root ) { if ( root ) { makeInOrder ( root -> left ); inOrder . push_back ( root -> val ); makeInOrder ( root -> right ); } } public : BSTIterator ( TreeNode * root ) { // Make the in-order traversal beforehand makeInOrder ( root ); current = -1 ; // start with -1 // so when first next() is called we return the root } int next () { current ++ ; return inOrder [ current ]; } bool hasNext () { if ( current == inOrder . size () - 1 ) { return false ; } return true ; } };","title":"Code with Straight Forward Apporach"},{"location":"trees/problems/#count-complete-tree-nodes","text":"Problem on Leetcode \\(\\to\\)","title":"Count Complete Tree Nodes"},{"location":"trees/problems/#problem-statement_12","text":"Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity.","title":"Problem statement"},{"location":"trees/problems/#approach_11","text":"We can easily solve this problem with recursion but as in this problem sub-trees of the binary tree is complete binary tree we can use the formula to calculate the number of nodes as \\(2^{\\text{height}}\\) . This way the overall time complexity reduces. Otherwise if \\(O(N)\\) is possible we could just run an in order traversal algorithm to find the number of nodes in the tree.","title":"Approach"},{"location":"trees/problems/#code_10","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int two_pow ( int n ) { // find 2^n int result = 1 ; while ( n != 0 ) { result *= 2 ; n -- ; } return result ; } int lh ( TreeNode * root ) { // find left height of a given tree if ( ! root ) return 0 ; return 1 + lh ( root -> left ); } int rh ( TreeNode * root ) { // find right height of a given tree if ( ! root ) return 0 ; return 1 + rh ( root -> right ); } int count ( TreeNode * root ) { int leftHeight = lh ( root ); int rightHeight = rh ( root ); // if both left and right height is the same then // with respect to the root at current recursion level it is balanced and complete // so the number of node will be 2^n - 1 if ( leftHeight == rightHeight ) { return two_pow ( leftHeight ) - 1 ; } // else we continue with the normal recursive counting return 1 + count ( root -> left ) + count ( root -> right ); } public : int countNodes ( TreeNode * root ) { if ( not root ) return 0 ; return count ( root ); } };","title":"Code"},{"location":"trees/problems/#deepest-leaves-sum","text":"Problem on Leetcode \\(\\to\\)","title":"Deepest Leaves Sum"},{"location":"trees/problems/#problem-statemet","text":"Given the root of a binary tree, return the sum of values of its deepest leaves.","title":"Problem Statemet"},{"location":"trees/problems/#approach_12","text":"We shoud use my BFS technique with passing depth. Using this technique when we find a leaf node we store it in a pair<int, int> and save the depth. If we find a leaf node less than this depth, so this can not be in the answer so we ignore it. If we find a leaf node is at the same level this means it can be included in the answer and later if we find any node at a deeper depth we'll discard all the calculations before. So here is the code using the upper approach /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : pair < int , int > sumAndDepth = { 0 , 0 }; int deepestLeavesSum ( TreeNode * root ) { queue < pair < TreeNode * , int >> q ; // set root node at depth 1 q . push ({ root , 1 }); while ( ! q . empty ()) { TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( not front -> left and not front -> right ) { // it is a leaf node if ( depth == sumAndDepth . second ) { // if the leaf node is at 'presumably' the deepest node // add the values sumAndDepth . first += front -> val ; sumAndDepth . second = depth ; } else if ( depth > sumAndDepth . second ) { // else if some other node is at a greater depth // reset the depth and sum sumAndDepth . first = 0 + front -> val ; sumAndDepth . second = depth ; } } // simple BFS strategy if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); } return sumAndDepth . first ; // return the sum at the last } };","title":"Approach"},{"location":"trees/problems/#sum-of-nodes-with-even-valued-grandparent","text":"Problem on Leetcode \\(\\to\\)","title":"Sum of Nodes with Even-Valued Grandparent"},{"location":"trees/problems/#problem-statement_13","text":"Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent of a node is the parent of its parent if it exists.","title":"Problem Statement"},{"location":"trees/problems/#approach_13","text":"It's a simple recursive problem, we'll get to every node and check if it is even then if it has a grandparent. Every node has 4 possible grand-children: left of left children, right of left children, right of right children, left of right children, With that apporach let's code","title":"Approach"},{"location":"trees/problems/#code_11","text":"class Solution { private : int sum = 0 ; public : int sumEvenGrandparent ( TreeNode * root ) { if ( root ) { if ( root -> val % 2 == 0 ) { // if even number check all the grandchildren if ( root -> left ) { if ( root -> left -> left ) { sum += root -> left -> left -> val ; } if ( root -> left -> right ) { sum += root -> left -> right -> val ; } } if ( root -> right ) { if ( root -> right -> left ) { sum += root -> right -> left -> val ; } if ( root -> right -> right ) { sum += root -> right -> right -> val ; } } } sumEvenGrandparent ( root -> left ); sumEvenGrandparent ( root -> right ); } return sum ; } };","title":"Code"},{"location":"trees/problems/#same-tree","text":"Problem on Leetcode \\(\\to\\)","title":"Same Tree"},{"location":"trees/problems/#problem-statement_14","text":"Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.","title":"Problem Statement"},{"location":"trees/problems/#example_6","text":"Input: p = [1,2,3], q = [1,2,3] Output: true","title":"Example"},{"location":"trees/problems/#approach_14","text":"We'll go through both the tree with a simultaneous in-order traversal, if we find any incorrect order we'll report false.","title":"Approach"},{"location":"trees/problems/#code_12","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( not p and not q ) return true ; if ( p and q ) { return ( p -> val == q -> val ) and isSameTree ( p -> left , q -> left ) and isSameTree ( p -> right , q -> right ); } return false ; } };","title":"Code"},{"location":"trees/problems/#flatten-binary-tree-to-linked-list","text":"Find Problem on Leetcode \\(\\to\\)","title":"Flatten Binary Tree to Linked List"},{"location":"trees/problems/#problem-statement_15","text":"Given the root of a binary tree, flatten the tree into a \"linked list\": The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.","title":"Problem Statement"},{"location":"trees/problems/#approach_15","text":"We have to solve this using a recursive approach, otherwise, the problem will become too complicated to solve because then you also have to keep track of the call stack. In recursion, we'll assume we have a leftEnd and rightEnd after the recursion, for any given root of the binary tree leftEnd is the flattened root->left of that root. Now as per the problem statement we set the following three leftEnd->right = root->right; root->right = root->left; root->left = nullptr; and now at the end, we return the __End , which is used recursively to connect the flattened binary tree. We'll return the rightEnd if possible else the leftEnd or root .","title":"Approach"},{"location":"trees/problems/#code_13","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : TreeNode * recursive_descent ( TreeNode * root ) { if ( root ) { TreeNode * leftEnd = recursive_descent ( root -> left ); TreeNode * rightEnd = recursive_descent ( root -> right ); if ( root -> left ) { leftEnd -> right = root -> right ; root -> right = root -> left ; root -> left = nullptr ; } if ( rightEnd ) return rightEnd ; else if ( not rightEnd and leftEnd ) return leftEnd ; else return root ; } return nullptr ; } public : void flatten ( TreeNode * root ) { recursive_descent ( root ); } };","title":"Code"},{"location":"trees/problems/#lowest-common-ancestor-of-a-binary-search-tree","text":"","title":"Lowest Common Ancestor of a Binary Search Tree"},{"location":"trees/problems/#problem-statement_16","text":"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d","title":"Problem Statement"},{"location":"trees/problems/#approach_16","text":"We'll use a simple recursive technique to find the lowest common ancestor, if the node p and node q are in different subtrees from a certain root, then it is must that the root is the lowest common ancestor. If we find the both the node p and node q are in the same subtree, we'll recursively descent into that subtree in search for the lowest common ancestor.","title":"Approach"},{"location":"trees/problems/#code_14","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { bool findOnSubTree ( TreeNode * root , TreeNode * q ) { if ( root ) { return findOnSubTree ( root -> left , q ) or ( root -> val == q -> val ) or findOnSubTree ( root -> right , q ); } return false ; } public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { // check if both in the same tree or not? // recursively go to that subtree only if ( findOnSubTree ( root -> left , p ) and findOnSubTree ( root -> left , q )) { return lowestCommonAncestor ( root -> left , p , q ); } else if ( findOnSubTree ( root -> right , p ) and findOnSubTree ( root -> right , q )) { return lowestCommonAncestor ( root -> right , p , q ); } // now check if both are in different subtree or not? if ( findOnSubTree ( root -> left , p ) and findOnSubTree ( root -> right , q )) { return root ; } else if ( findOnSubTree ( root -> right , p ) and findOnSubTree ( root -> left , q )) { return root ; } // base case all must have the ancestor root return root ; } };","title":"Code"},{"location":"trees/problems/#another-approach","text":"We can also take on the fact that we have a binary search tree, so we can say that if we start at the root node of the tree then if p and q value both are less than the root we search in the left subtree and if p and q value both are greater than the root node we search in the right subtree. Any case other than that, means values have split between left and right subtrees from that position, that means this is the lowest common ancestor. So return that.","title":"Another approach"},{"location":"trees/problems/#code-for-this-approach_1","text":"class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { TreeNode * current = root ; while ( current ) { if ( p -> val < current -> val and q -> val < current -> val ) { current = current -> left ; } else if ( p -> val > current -> val and q -> val > current -> val ) { current = current -> right ; } else { return current ; } } // base case of all return root ; } };","title":"Code for this approach"},{"location":"trees/problems/#maximum-product-of-splitted-binary-tree","text":"Find the problem on Leetcode \\(\\to\\)","title":"Maximum Product of Splitted Binary Tree"},{"location":"trees/problems/#problem-statement_17","text":"Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo \\(10^9 + 7\\) . Note that you need to maximize the answer before taking the mod and not after taking it.","title":"Problem Statement"},{"location":"trees/problems/#examples_1","text":"Input: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)","title":"Examples"},{"location":"trees/problems/#approach_17","text":"We'll find the sum in each of the subtrees. If we know the sum of a subtree, the answer is max( (total_sum - subtree_sum) * subtree_sum) in each node. To find the total_sum we run a subroutine helper() that'll find the sum with post order traversal. At the end keep track of the max of max( (total_sum - subtree_sum) * subtree_sum) for each of the subtrees for every node.","title":"Approach"},{"location":"trees/problems/#code_15","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int M = 1e9 + 7 ; long long max_prod = 0 ; int helper ( TreeNode * root ) { int total = 0 ; if ( not root ) return 0 ; total += root -> val + helper ( root -> left ) + helper ( root -> right ); return total ; } int subroutine ( TreeNode * root , int total ) { if ( not root ) return 0 ; int sum = root -> val ; int left = subroutine ( root -> left , total ); int right = subroutine ( root -> right , total ); sum = sum + left + right ; max_prod = std :: max ( max_prod , ( left * 1L L ) * (( total - left ) * 1L L )); max_prod = std :: max ( max_prod , ( right * 1L L ) * (( total - right ) * 1L L )); return sum ; } public : int maxProduct ( TreeNode * root ) { int total = helper ( root ); subroutine ( root , total ); return max_prod % M ; } };","title":"Code"},{"location":"trees/problems/#count-good-nodes-in-binary-tree","text":"Find the problem on Leetcode \\(\\to\\)","title":"Count Good Nodes in Binary Tree"},{"location":"trees/problems/#problem-statement_18","text":"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.","title":"Problem Statement"},{"location":"trees/problems/#example_7","text":"Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path Node 3 -> (3,1,3) is the maximum value in the path.","title":"Example"},{"location":"trees/problems/#approach_18","text":"We'll send a maxSeen so far variable down with the recursive calls. If we find a node with value greater or equal to the current node we'll increment the counter of good notes. At last we'll return the good_node_counter global variable.","title":"Approach"},{"location":"trees/problems/#code_16","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : int good_node_counter = 0 ; void recursive_subroutine ( TreeNode * root , int maxSeen ) { if ( not root ) return ; if ( root -> val >= maxSeen ) { good_node_counter ++ ; } maxSeen = std :: max ( maxSeen , root -> val ); recursive_subroutine ( root -> left , maxSeen ); recursive_subroutine ( root -> right , maxSeen ); } public : int goodNodes ( TreeNode * root ) { recursive_subroutine ( root , root -> val ); return good_node_counter ; } };","title":"Code"},{"location":"trees/problems/#trim-a-binary-search-tree","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Trim a Binary Search Tree"},{"location":"trees/problems/#problem-statement_19","text":"Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.","title":"Problem Statement"},{"location":"trees/problems/#example_8","text":"Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1]","title":"Example"},{"location":"trees/problems/#approach_19","text":"We'll do a recursive descent into the binary search tree. As it is a binary search tree we can find the way to go down the recursion based on the values at the current node. Few of the moves that we'll be taking during the recursion are the following If some root->left->val is less than the low means that the current node's left child should become the current node's left's right child (making all the left->left->right&left invalid because they will be less than the lower bound on the binary search tree). Even then there can be a problem that the new left of the current node is out of bounds again. So we recursively call the function on that same node again. After this when we are done correcting the node there may be a chance that some of the children are not corrected yet, so we recursively call the function on the left children trimBST(root->left, low, high); . We symmatically solve the right children. This is how we solved the left and the right children but we didn't solved the current root yet. To solve this we'll do a simple recursive return from the left or the right depending upon the value at the root node. if ( root -> val < low ) return trimBST ( root -> right , low , high ); if ( root -> val > high ) return trimBST ( root -> left , low , high );","title":"Approach"},{"location":"trees/problems/#code_17","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * trimBST ( TreeNode * root , int low , int high ) { if ( not root ) return root ; if ( root -> left and root -> left -> val < low ) { root -> left = root -> left -> right ; trimBST ( root , low , high ); } trimBST ( root -> left , low , high ); if ( root -> right and root -> right -> val > high ) { root -> right = root -> right -> left ; trimBST ( root , low , high ); } trimBST ( root -> right , low , high ); if ( root -> val < low ) return trimBST ( root -> right , low , high ); if ( root -> val > high ) return trimBST ( root -> left , low , high ); return root ; } };","title":"Code"},{"location":"trees/problems/#binary-tree-right-side-view","text":"Find the problem on leetcode \\(\\to\\)","title":"Binary Tree Right Side View"},{"location":"trees/problems/#problem-statement_20","text":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.","title":"Problem Statement"},{"location":"trees/problems/#example_9","text":"Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Input: root = [1,null,3] Output: [1,3] Input: root = [] Output: []","title":"Example"},{"location":"trees/problems/#approach_20","text":"If you look closely to the example above, you can see that the right side view is the right most node of the tree for each level, armed with that knowledge you can travel level by level using a level order traversal, then find what is the last node of that level, you return that value. At the worst case the Binary Tree is skewed so at most \\(O(N)\\) space and time is required to find the right view of that tree. The following is the code example that implements this approach.","title":"Approach"},{"location":"trees/problems/#code_18","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < int > answer ; vector < int > rightSideView ( TreeNode * root ) { if ( not root ) return answer ; vector < vector < int >> levelOrder ; queue < pair < TreeNode * , int >> q ; q . push ({ root , 1 }); while ( ! q . empty ()) { TreeNode * front = q . front (). first ; int depth = q . front (). second ; q . pop (); if ( front -> left ) q . push ({ front -> left , depth + 1 }); if ( front -> right ) q . push ({ front -> right , depth + 1 }); if ( depth > levelOrder . size ()) { vector < int > v ; v . push_back ( front -> val ); levelOrder . push_back ( v ); } else if ( depth == levelOrder . size ()){ levelOrder [ depth -1 ]. push_back ( front -> val ); } } for ( int i = 0 ; i < levelOrder . size (); i ++ ) { vector < int > lvl = levelOrder [ i ]; answer . push_back ( lvl [ lvl . size () - 1 ]); } return answer ; } };","title":"Code"}]}