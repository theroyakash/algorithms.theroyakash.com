{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"theroyakash algorithms Materials for FAANG and top startup coding interview and running notes on that. Made by @theroyakash Who am I? This is me! I go by theroyakash on the internet. I am a computer scientist will be starting my masters in computer science from IIT (Indian Institute of Technology), with research in high-performance algorithms, data structures, distributed systems, and beyond. See my work searching google for theroyakash and on Github . What is this? This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I and SDE II algorithm round. Patterns Sliding Window Pattern , more is being added. Arrays and Strings Recursion and problems coming soon Linked lists and problems Stacks and Queues Binary Search and Problems (more coming soon) Trees and Graphs and Graph Problems , along with heaps and heap problems Bit Manipulation (With C/C++) Sorting and Searching [coming soon] Dynamic Programming with Top-Down (Recursive) approach [coming soon] Also Coming Soon Few more freebies coming soon Complete Notes for Advanced algorithms design and selected data structure analysis Randomized algorithm notes Distributed Systems Book [expected 2023 Summer]. Other Products See the freebies page to see more products available for free to use. This is me! Other links Visit my website here . My Github , More about me , Send me an email .","title":"Introduction"},{"location":"#theroyakash-algorithms","text":"Materials for FAANG and top startup coding interview and running notes on that. Made by @theroyakash","title":"theroyakash algorithms"},{"location":"#who-am-i","text":"This is me! I go by theroyakash on the internet. I am a computer scientist will be starting my masters in computer science from IIT (Indian Institute of Technology), with research in high-performance algorithms, data structures, distributed systems, and beyond. See my work searching google for theroyakash and on Github .","title":"Who am I?"},{"location":"#what-is-this","text":"This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I and SDE II algorithm round.","title":"What is this?"},{"location":"#patterns","text":"Sliding Window Pattern , more is being added. Arrays and Strings Recursion and problems coming soon Linked lists and problems Stacks and Queues Binary Search and Problems (more coming soon) Trees and Graphs and Graph Problems , along with heaps and heap problems Bit Manipulation (With C/C++) Sorting and Searching [coming soon] Dynamic Programming with Top-Down (Recursive) approach [coming soon]","title":"Patterns"},{"location":"#also-coming-soon","text":"Few more freebies coming soon Complete Notes for Advanced algorithms design and selected data structure analysis Randomized algorithm notes Distributed Systems Book [expected 2023 Summer].","title":"Also Coming Soon"},{"location":"#other-products","text":"See the freebies page to see more products available for free to use. This is me!","title":"Other Products"},{"location":"#other-links","text":"Visit my website here . My Github , More about me , Send me an email .","title":"Other links"},{"location":"blind75/","tags":["Blind 75","ONGOING SERIES"],"text":"Blind 75 problems This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":"Blind 75 Problems"},{"location":"blind75/#blind-75-problems","text":"This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":" Blind 75 problems"},{"location":"bss/","tags":["Medium","Binary Search","One day to complete"],"text":"Binary Search Introductions Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\) Toy problem to start Problem Statement Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only. Example Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10 Approach This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start <= end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 9\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.25\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.7\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.1\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3.27\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3\\) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3 Find out the Nth Root of a given element. Problem Statement For a given N and a number K, find \\(\\sqrt[N]{K}\\) . Approach It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294) Median of Row Wise Sorted Matrix Problem Statement We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd. Example Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5 Constraints Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd. Apporach Naive Approach Iterate over all the elements, and then sort them, then return the middle element. Time Complexity for this naive apporach \\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) . Space Complexity \\(O(NM)\\) Extra space is required. More optimized apporach","title":"Basics and introduction"},{"location":"bss/#binary-search-introductions","text":"Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\)","title":" Binary Search Introductions"},{"location":"bss/#toy-problem-to-start","text":"","title":"Toy problem to start"},{"location":"bss/#problem-statement","text":"Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only.","title":"Problem Statement"},{"location":"bss/#example","text":"Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10","title":"Example"},{"location":"bss/#approach","text":"This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start <= end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 9\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.25\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.7\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 6.1\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3.27\\) \\([2, 3, 5, 6, 6.6, 6.7, 7, 10]\\) , \\(\\text{target} = 3\\) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3","title":"Approach"},{"location":"bss/#find-out-the-nth-root-of-a-given-element","text":"","title":"Find out the Nth Root of a given element."},{"location":"bss/#problem-statement_1","text":"For a given N and a number K, find \\(\\sqrt[N]{K}\\) .","title":"Problem Statement"},{"location":"bss/#approach_1","text":"It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294)","title":"Approach"},{"location":"bss/#median-of-row-wise-sorted-matrix","text":"","title":"Median of Row Wise Sorted Matrix"},{"location":"bss/#problem-statement_2","text":"We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd.","title":"Problem Statement"},{"location":"bss/#example_1","text":"Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5","title":"Example"},{"location":"bss/#constraints","text":"Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd.","title":"Constraints"},{"location":"bss/#apporach","text":"","title":"Apporach"},{"location":"bss/#naive-approach","text":"Iterate over all the elements, and then sort them, then return the middle element.","title":"Naive Approach"},{"location":"bss/#time-complexity-for-this-naive-apporach","text":"\\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) .","title":"Time Complexity for this naive apporach"},{"location":"bss/#space-complexity","text":"\\(O(NM)\\) Extra space is required.","title":"Space Complexity"},{"location":"bss/#more-optimized-apporach","text":"","title":"More optimized apporach"},{"location":"freebies/","text":"Freebies Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked. C++ I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . How to use the stdin and stdout and take input from files and write output to text files to quickly submit solutions to online coding platforms. Here is an article with that information . Writing C++ Output with color Distinguishing C++ output inside the terminal is a hard job. Use the following color pallette to distinguish the outputs. #define RESET \"\\033[0m\" #define BLACK \"\\033[30m\" /* Black */ #define RED \"\\033[31m\" /* Red */ #define GREEN \"\\033[32m\" /* Green */ #define YELLOW \"\\033[33m\" /* Yellow */ #define BLUE \"\\033[34m\" /* Blue */ #define MAGENTA \"\\033[35m\" /* Magenta */ #define CYAN \"\\033[36m\" /* Cyan */ #define WHITE \"\\033[37m\" /* White */ #define BOLDBLACK \"\\033[1m\\033[30m\" /* Bold Black */ #define BOLDRED \"\\033[1m\\033[31m\" /* Bold Red */ #define BOLDGREEN \"\\033[1m\\033[32m\" /* Bold Green */ #define BOLDYELLOW \"\\033[1m\\033[33m\" /* Bold Yellow */ #define BOLDBLUE \"\\033[1m\\033[34m\" /* Bold Blue */ #define BOLDMAGENTA \"\\033[1m\\033[35m\" /* Bold Magenta */ #define BOLDCYAN \"\\033[1m\\033[36m\" /* Bold Cyan */ #define BOLDWHITE \"\\033[1m\\033[37m\" /* Bold White */ Usage with std::cout Everytime you use any of the color you must reset the color from the terminal like the following: int main () { vector < int > v = { 1 , 0 , 1 , 0 , 0 }; for ( auto i : v ) cout << BOLDCYAN << i << \" \" << RESET ; cout << \" \\n \" ; return 0 ; } Algorithms C++ C++ Algorithms is a simple data structure implementation library that you can remember to implement in an interview setting. Contributing There is some open positions for contribution in AKDSFramework tinyds , and C++ Algorithms projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Freebies"},{"location":"freebies/#freebies","text":"Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked.","title":"Freebies"},{"location":"freebies/#c","text":"I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . How to use the stdin and stdout and take input from files and write output to text files to quickly submit solutions to online coding platforms. Here is an article with that information .","title":"C++"},{"location":"freebies/#writing-c-output-with-color","text":"Distinguishing C++ output inside the terminal is a hard job. Use the following color pallette to distinguish the outputs. #define RESET \"\\033[0m\" #define BLACK \"\\033[30m\" /* Black */ #define RED \"\\033[31m\" /* Red */ #define GREEN \"\\033[32m\" /* Green */ #define YELLOW \"\\033[33m\" /* Yellow */ #define BLUE \"\\033[34m\" /* Blue */ #define MAGENTA \"\\033[35m\" /* Magenta */ #define CYAN \"\\033[36m\" /* Cyan */ #define WHITE \"\\033[37m\" /* White */ #define BOLDBLACK \"\\033[1m\\033[30m\" /* Bold Black */ #define BOLDRED \"\\033[1m\\033[31m\" /* Bold Red */ #define BOLDGREEN \"\\033[1m\\033[32m\" /* Bold Green */ #define BOLDYELLOW \"\\033[1m\\033[33m\" /* Bold Yellow */ #define BOLDBLUE \"\\033[1m\\033[34m\" /* Bold Blue */ #define BOLDMAGENTA \"\\033[1m\\033[35m\" /* Bold Magenta */ #define BOLDCYAN \"\\033[1m\\033[36m\" /* Bold Cyan */ #define BOLDWHITE \"\\033[1m\\033[37m\" /* Bold White */","title":"Writing C++ Output with color"},{"location":"freebies/#usage-with-stdcout","text":"Everytime you use any of the color you must reset the color from the terminal like the following: int main () { vector < int > v = { 1 , 0 , 1 , 0 , 0 }; for ( auto i : v ) cout << BOLDCYAN << i << \" \" << RESET ; cout << \" \\n \" ; return 0 ; }","title":"Usage with std::cout"},{"location":"freebies/#algorithms-c","text":"C++ Algorithms is a simple data structure implementation library that you can remember to implement in an interview setting.","title":"Algorithms C++"},{"location":"freebies/#contributing","text":"There is some open positions for contribution in AKDSFramework tinyds , and C++ Algorithms projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Contributing"},{"location":"otherbinarysearch-problems/","text":"Binary Search problems Binary search problems are really useful because they run in sublinear time. We'll be solving the following problems in order to master this Binary Search implementation in C++ Binary search is really easy to implement. Main goal is to divide the search space into 2 partitions ( bi ) and then based on the criteria search only in one partition. Expected time complexity Expected time complexity is \\(O(\\log N)\\) where N is the number of elements in the array. Code implementation // Return the index of the element in the array // using binary search int binary_search ( std :: vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = ( end + start ) / 2 ; int index = -1 ; // return -1 if not found while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return middle ; } middle = ( end + start ) / 2 ; } return index ; } Binary Search on Reverse Sorted Array We've seen the binary search algorithm for a sorted array, but if the array is reverse sorted then we can easily modify the binary search algorithm here else if (v[middle] > target) { start = middle + 1; } because the target element is lower and the array is reverse sorted so the required element should be at the end partition of the array. So a little modification of the binary search algorithm is sufficient to solve the problem. Order agnostic search If the array is sorted but we don't know the order of the elements whether it is ascending or descending? Then what we can do is the following Approach See if the array size is 1 or not then we return. If the array size is more than 1, then find if \\(\\text{A[0]} > \\text{A[1]}\\) or not? If it is then the array is reverse sorted. If that is not the case then the array is sorted in ascending order. We run the previous or previous to previous algorithm accordingly. First and Last occurrence of an Element In a sorted array if we have more than one element we may want to know what is the first occurrence of some element (assuming they exists). Approach We can use linear search but there is no fun in that. Instead we use a binary search, but how we'll do this? Let's employ a binary search subroutine, now this will find any occurrence of the target element, Now if this is not the first occurrence of the target element we will need to search the left subsection of the array, and in case we didn't find any we record this occurence as the first occurrence of the target element so far, Now we search for the target element again in the left subsection of the array by modifying end = middle - 1 Code int firstOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int first = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search first = middle ; end = middle - 1 ; } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return first ; } For finding the last occurence Similarly we can find the last occurence of an element in the sorted array by modifying the previous problem slightly, by first finding the element with binary search, then instead of finding the element in the left side [for first occurence] we search the right sub array for the last occurence of the element. int lastOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int last = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search last = middle ; start = middle + 1 ; // look in the right subarray for the last occurrence } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return last ; } Count of an Element in a Sorted Array Similar problem on Leetcode \\(\\to\\) This is a very simple problem, we can find the first occurrence of an element [index] and last occurence of an element and subtract. This will return the number of times the element was found in the array. Expected Time complexity \\(O(\\text{lg} N)\\) for finding the first occurrence and \\(O(\\text{lg} N)\\) for finding the last occurrence. Total of \\(O(\\text{lg} N)\\) . Number of Times a Sorted array is Rotated Problem Statement An asending sorted array \\(A[0 \\to N]\\) once rotated becomes \\(A[1 \\to N] + A[0]\\) . When it twice rotated becomes \\(A[2 \\to N] + A[0 \\to 1]\\) . When the array is rotated \\(k\\) times, the array becomes \\(A[K \\to N] + A[0 \\to K - 1]\\) Brute Force Approach Using a linear search if we find for some \\(i\\) \\(A[i] > A[i+1]\\) , that \\(i\\) is the index of the rotation starting point. Subtract \\(i\\) from length of the array to find how much rotation took place. One more thing we can observe is that the \\((\\text{size - index of the minimum element})\\) is the # of rotations done on the sorted array. Both of these solution is \\(O(N)\\) so not efficient enough. More optimized approach We cannot afford to search for the minimum element in the entire array, this will cost \\(O(N)\\) time. However if we reduce the size of the search space we can reduce the time complexity of the algorithm. This apporach works like this: First check the middle \\(i\\) , if the value is smaller than both the element to its side \\(i - 1\\) and \\(i + 1\\) , then it is the point of the minimum element means this is the point of rotation. If this is not true then based on some idea we should reduce the size of the search space, otherwise its gonna be \\(O(N)\\) We do this very ingenious way, first we check if the middle element is smaller than the first element or not? If this is the case then the minimum element is present in the left side of the middle element. Else the element should be present in the right side of the middle element. Code class Solution { public : int findMin ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; int size = nums . size (); int middle = start + ( end - start ) / 2 ; while ( start < end ){ if ( nums [ middle ] > nums [ end ]) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return size - start + 1 ; } }; Find an Element in a Rotated Sorted Array Approach If we look at the previous problem, we'll see that the (rotation point): let's call that the pivot, the subarray before pivot is sorted and subarray after pivot is sorted as well. If we run 2 binary search on each of the subarrays we'll find the target element in \\(O(\\text{lg} N)\\) time. Code // Consider binary_search is already available int rotatation_point ( vector < int > & v ){ int start = 0 ; int end = v . size () - 1 ; int mid = start + ( end - start ) / 2 ; while ( start <= end ){ if ( v [ middle ] > v [ end ]){ start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } // now middle is the index of the rotation point int index1 = binary_search ( v , 0 , middle - 1 ); int index2 = binary_search ( v , middle , end ); return std :: max ( index1 , index2 ); } int search_on_rotated ( vector < int > & v ){ // find the rotation point } Searching in a Nearly Sorted Array Find Floor of an element in a Sorted Array Ceil of an element in a Sorted Array Next alphabetical element Find position of an element in an Infinite Sorted Array Index of First 1 in a Binary Sorted Infinite Array Minimum Difference Element in a Sorted Array Binary Search on Answer Concept Peak Element Find maximum element in Bitonic Array Search An Element in Bitonic Array Allocate minimum number of pages","title":"Other binary search problems"},{"location":"otherbinarysearch-problems/#binary-search-problems","text":"Binary search problems are really useful because they run in sublinear time. We'll be solving the following problems in order to master this","title":" Binary Search problems"},{"location":"otherbinarysearch-problems/#binary-search-implementation-in-c","text":"Binary search is really easy to implement. Main goal is to divide the search space into 2 partitions ( bi ) and then based on the criteria search only in one partition.","title":"Binary Search implementation in C++"},{"location":"otherbinarysearch-problems/#expected-time-complexity","text":"Expected time complexity is \\(O(\\log N)\\) where N is the number of elements in the array.","title":"Expected time complexity"},{"location":"otherbinarysearch-problems/#code-implementation","text":"// Return the index of the element in the array // using binary search int binary_search ( std :: vector < int > & v , int target ) { int start = 0 ; int end = v . size () - 1 ; int middle = ( end + start ) / 2 ; int index = -1 ; // return -1 if not found while ( start <= end ) { if ( v [ middle ] < target ) { start = middle + 1 ; } else if ( v [ middle ] > target ) { end = middle - 1 ; } else { return middle ; } middle = ( end + start ) / 2 ; } return index ; }","title":"Code implementation"},{"location":"otherbinarysearch-problems/#binary-search-on-reverse-sorted-array","text":"We've seen the binary search algorithm for a sorted array, but if the array is reverse sorted then we can easily modify the binary search algorithm here else if (v[middle] > target) { start = middle + 1; } because the target element is lower and the array is reverse sorted so the required element should be at the end partition of the array. So a little modification of the binary search algorithm is sufficient to solve the problem.","title":"Binary Search on Reverse Sorted Array"},{"location":"otherbinarysearch-problems/#order-agnostic-search","text":"If the array is sorted but we don't know the order of the elements whether it is ascending or descending? Then what we can do is the following","title":"Order agnostic search"},{"location":"otherbinarysearch-problems/#approach","text":"See if the array size is 1 or not then we return. If the array size is more than 1, then find if \\(\\text{A[0]} > \\text{A[1]}\\) or not? If it is then the array is reverse sorted. If that is not the case then the array is sorted in ascending order. We run the previous or previous to previous algorithm accordingly.","title":"Approach"},{"location":"otherbinarysearch-problems/#first-and-last-occurrence-of-an-element","text":"In a sorted array if we have more than one element we may want to know what is the first occurrence of some element (assuming they exists).","title":"First and Last occurrence of an Element"},{"location":"otherbinarysearch-problems/#approach_1","text":"We can use linear search but there is no fun in that. Instead we use a binary search, but how we'll do this? Let's employ a binary search subroutine, now this will find any occurrence of the target element, Now if this is not the first occurrence of the target element we will need to search the left subsection of the array, and in case we didn't find any we record this occurence as the first occurrence of the target element so far, Now we search for the target element again in the left subsection of the array by modifying end = middle - 1","title":"Approach"},{"location":"otherbinarysearch-problems/#code","text":"int firstOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int first = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search first = middle ; end = middle - 1 ; } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return first ; } For finding the last occurence Similarly we can find the last occurence of an element in the sorted array by modifying the previous problem slightly, by first finding the element with binary search, then instead of finding the element in the left side [for first occurence] we search the right sub array for the last occurence of the element. int lastOccurence ( vector < int > & v , int target ){ int start = 0 ; int end = v . size () - 1 ; int middle = start + ( end - start ) / 2 ; int last = -1 ; while ( start <= end ) { if ( v [ middle ] == target ) { // modification to the general binary search last = middle ; start = middle + 1 ; // look in the right subarray for the last occurrence } else if ( v [ middle ] < target ) { start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } return last ; }","title":"Code"},{"location":"otherbinarysearch-problems/#count-of-an-element-in-a-sorted-array","text":"Similar problem on Leetcode \\(\\to\\) This is a very simple problem, we can find the first occurrence of an element [index] and last occurence of an element and subtract. This will return the number of times the element was found in the array.","title":"Count of an Element in a Sorted Array"},{"location":"otherbinarysearch-problems/#expected-time-complexity_1","text":"\\(O(\\text{lg} N)\\) for finding the first occurrence and \\(O(\\text{lg} N)\\) for finding the last occurrence. Total of \\(O(\\text{lg} N)\\) .","title":"Expected Time complexity"},{"location":"otherbinarysearch-problems/#number-of-times-a-sorted-array-is-rotated","text":"","title":"Number of Times a Sorted array is Rotated"},{"location":"otherbinarysearch-problems/#problem-statement","text":"An asending sorted array \\(A[0 \\to N]\\) once rotated becomes \\(A[1 \\to N] + A[0]\\) . When it twice rotated becomes \\(A[2 \\to N] + A[0 \\to 1]\\) . When the array is rotated \\(k\\) times, the array becomes \\(A[K \\to N] + A[0 \\to K - 1]\\)","title":"Problem Statement"},{"location":"otherbinarysearch-problems/#brute-force-approach","text":"Using a linear search if we find for some \\(i\\) \\(A[i] > A[i+1]\\) , that \\(i\\) is the index of the rotation starting point. Subtract \\(i\\) from length of the array to find how much rotation took place. One more thing we can observe is that the \\((\\text{size - index of the minimum element})\\) is the # of rotations done on the sorted array. Both of these solution is \\(O(N)\\) so not efficient enough.","title":"Brute Force Approach"},{"location":"otherbinarysearch-problems/#more-optimized-approach","text":"We cannot afford to search for the minimum element in the entire array, this will cost \\(O(N)\\) time. However if we reduce the size of the search space we can reduce the time complexity of the algorithm. This apporach works like this: First check the middle \\(i\\) , if the value is smaller than both the element to its side \\(i - 1\\) and \\(i + 1\\) , then it is the point of the minimum element means this is the point of rotation. If this is not true then based on some idea we should reduce the size of the search space, otherwise its gonna be \\(O(N)\\) We do this very ingenious way, first we check if the middle element is smaller than the first element or not? If this is the case then the minimum element is present in the left side of the middle element. Else the element should be present in the right side of the middle element.","title":"More optimized approach"},{"location":"otherbinarysearch-problems/#code_1","text":"class Solution { public : int findMin ( vector < int >& nums ) { int start = 0 ; int end = nums . size () - 1 ; int size = nums . size (); int middle = start + ( end - start ) / 2 ; while ( start < end ){ if ( nums [ middle ] > nums [ end ]) { start = middle + 1 ; } else { end = middle ; } middle = start + ( end - start ) / 2 ; } return size - start + 1 ; } };","title":"Code"},{"location":"otherbinarysearch-problems/#find-an-element-in-a-rotated-sorted-array","text":"","title":"Find an Element in a Rotated Sorted Array"},{"location":"otherbinarysearch-problems/#approach_2","text":"If we look at the previous problem, we'll see that the (rotation point): let's call that the pivot, the subarray before pivot is sorted and subarray after pivot is sorted as well. If we run 2 binary search on each of the subarrays we'll find the target element in \\(O(\\text{lg} N)\\) time.","title":"Approach"},{"location":"otherbinarysearch-problems/#code_2","text":"// Consider binary_search is already available int rotatation_point ( vector < int > & v ){ int start = 0 ; int end = v . size () - 1 ; int mid = start + ( end - start ) / 2 ; while ( start <= end ){ if ( v [ middle ] > v [ end ]){ start = middle + 1 ; } else { end = middle - 1 ; } middle = start + ( end - start ) / 2 ; } // now middle is the index of the rotation point int index1 = binary_search ( v , 0 , middle - 1 ); int index2 = binary_search ( v , middle , end ); return std :: max ( index1 , index2 ); } int search_on_rotated ( vector < int > & v ){ // find the rotation point }","title":"Code"},{"location":"otherbinarysearch-problems/#searching-in-a-nearly-sorted-array","text":"","title":"Searching in a Nearly Sorted Array"},{"location":"otherbinarysearch-problems/#find-floor-of-an-element-in-a-sorted-array","text":"","title":"Find Floor of an element in a Sorted Array"},{"location":"otherbinarysearch-problems/#ceil-of-an-element-in-a-sorted-array","text":"","title":"Ceil of an element in a Sorted Array"},{"location":"otherbinarysearch-problems/#next-alphabetical-element","text":"","title":"Next alphabetical element"},{"location":"otherbinarysearch-problems/#find-position-of-an-element-in-an-infinite-sorted-array","text":"","title":"Find position of an element in an Infinite Sorted Array"},{"location":"otherbinarysearch-problems/#index-of-first-1-in-a-binary-sorted-infinite-array","text":"","title":"Index of First 1 in a Binary Sorted Infinite Array"},{"location":"otherbinarysearch-problems/#minimum-difference-element-in-a-sorted-array","text":"","title":"Minimum Difference Element in a Sorted Array"},{"location":"otherbinarysearch-problems/#binary-search-on-answer-concept","text":"","title":"Binary Search on Answer Concept"},{"location":"otherbinarysearch-problems/#peak-element","text":"","title":"Peak Element"},{"location":"otherbinarysearch-problems/#find-maximum-element-in-bitonic-array","text":"","title":"Find maximum element in Bitonic Array"},{"location":"otherbinarysearch-problems/#search-an-element-in-bitonic-array","text":"","title":"Search An Element in Bitonic Array"},{"location":"otherbinarysearch-problems/#allocate-minimum-number-of-pages","text":"","title":"Allocate minimum number of pages"},{"location":"stdinout-usage/","text":"Standard input output usage Taking data in and writing data out to a file In some of the problems in SDE 1 and SDE 2 online coding rounds, you have to take care of the program inputs. Here is an example of how we can write all inputs to a text file and then run our algorithms. You must add 2 files called \"input.txt\" and \"output.txt\" in the same directory and add these 2 lines of code in the main() freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Input Now in the input.txt file, you design as the inputs are given in the following case the input was 3 a b c 4 a b 12 c b 2 b a 99 c a 8 Output The corresponding output file is written as c [a: 8][b: 2] b [a: 99] a [b: 12] a->b c->b b->a c->a Code #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; int main () { freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Graph g ; int vertex ; cin >> vertex ; vector < char > v ; while ( vertex != 0 ){ char vertex_label ; cin >> vertex_label ; v . push_back ( vertex_label ); vertex -- ; } g . register_vertex ( v ); int numberofedges ; cin >> numberofedges ; while ( numberofedges != 0 ){ char from , to ; int weight ; cin >> from >> to >> weight ; g . add_edge ( from , to , weight ); numberofedges -- ; } unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } cout << \" \\n \" ; // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } cout << \" \\n \" ; }","title":"Standard Input Output"},{"location":"stdinout-usage/#standard-input-output-usage","text":"","title":"Standard input output usage"},{"location":"stdinout-usage/#taking-data-in-and-writing-data-out-to-a-file","text":"In some of the problems in SDE 1 and SDE 2 online coding rounds, you have to take care of the program inputs. Here is an example of how we can write all inputs to a text file and then run our algorithms. You must add 2 files called \"input.txt\" and \"output.txt\" in the same directory and add these 2 lines of code in the main() freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout );","title":"Taking data in and writing data out to a file"},{"location":"stdinout-usage/#input","text":"Now in the input.txt file, you design as the inputs are given in the following case the input was 3 a b c 4 a b 12 c b 2 b a 99 c a 8","title":"Input"},{"location":"stdinout-usage/#output","text":"The corresponding output file is written as c [a: 8][b: 2] b [a: 99] a [b: 12] a->b c->b b->a c->a","title":"Output"},{"location":"stdinout-usage/#code","text":"#include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; int main () { freopen ( \"input.txt\" , \"r\" , stdin ); freopen ( \"output.txt\" , \"w\" , stdout ); Graph g ; int vertex ; cin >> vertex ; vector < char > v ; while ( vertex != 0 ){ char vertex_label ; cin >> vertex_label ; v . push_back ( vertex_label ); vertex -- ; } g . register_vertex ( v ); int numberofedges ; cin >> numberofedges ; while ( numberofedges != 0 ){ char from , to ; int weight ; cin >> from >> to >> weight ; g . add_edge ( from , to , weight ); numberofedges -- ; } unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } cout << \" \\n \" ; // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } cout << \" \\n \" ; }","title":" Code"},{"location":"LinkedLists/problems/","tags":["Linked List Problems","SDE 1 and SDE 2"],"text":"Linked List problems Implement Linked list and write reverse() Problem Statement Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\) Approach Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space. C++ Code for Linked List #include <iostream> using std :: cout ; using std :: endl ; using std :: vector ; template < class T > class LinkedListNode { public : T data ; LinkedListNode < T > * next ; }; template < class T > class LinkedList { private : LinkedListNode < T > * head ; LinkedListNode < T > * end ; int classPriveSize ; public : LinkedList () { head = NULL ; end = NULL ; classPriveSize = 0 ; } ~ LinkedList () { Clear (); } void push_back ( T value ) { if ( classPriveSize == 0 ) { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; head = newNode ; end = newNode ; } else { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; end -> next = newNode ; end = newNode ; } classPriveSize ++ ; } T front () { return head -> data ; } T back () { return end -> data ; } }; linkedlist_reverse() method We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Middle of the Linked List Problem Statement Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\) Approach Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; } Merge 2 sorted lists Find the problem on Leetcode \\(\\to\\) Problem Statement You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4] Approach We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list. Code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; } Time and Space complexity Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation. Implementing this problem in-place Step wise iteration explainer Iteration 1 Iteration 2 Iteration 3 Iteration 4 Iteration 5, and so on and the last /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } }; Delete Node in a Linked List Problem on Leetcode \\(\\to\\) Problem Statement Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. Example Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Approach Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } }; Remove Nth Node From End of List Given the head of a linked list, remove the nth node from the end of the list and return its head Video Explaination Example For elements \\([1, 2, 3, 4, 5]\\) , remove the second node from the last. This will return \\([1, 2, 3, 5]\\) . Similarly \\([1]\\) and \\(n = 1\\) will return \\([]\\) . Constraints Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ The number of nodes in the list is \\(\\mathcal{N}\\) 1 <= \\(\\mathcal{N}\\) <= 30 0 <= (new ListNode())->val <= 100 1 <= n <= \\(\\mathcal{N}\\) (n is within the bounds). Approach Implementation with two pass Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; } Implementation with one pass only With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last. A bit modification We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following Edge Case There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; } C++ Code ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; } Time and space complexity For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution. Add Two Numbers Given as LinkedLists Asked in Amazon, Microsoft, Facebook, Qualcomm. Elsewhere Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\) Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Testcase Examples \\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\) Approach Do normal addition from 1st standard and add digit by digit in a new linked list. C++ code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; } C++ code for leetcode with custom definition for singly-linked list Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } }; Intersection of Two Linked Lists Find the problem on Leetcode \\(\\to\\) Problem Statement Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null . Example For the following problem, head1 and head2 are given, find the marked blue intersection point. Approach Brute Force approach For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space. Using Hash table As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point. C++ Code class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } }; Time and Space Complexity As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first. Linear time and Constant Space Approach Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean: C++ Code for Most Optimal Approach class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } }; Time and Space Complexity The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required. Detect a cycle in linked list Problem Statement Given head, the head of a linked list, determine if the linked list has a cycle in it. Approach Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true . C++ Code class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } }; Time and space complexity \\(O(N)\\) time and no extra space. Palindrome Linked list Problem Statement Given the head of a singly linked list, return true if it is a palindrome. Approach With More Space First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false . C++ Code class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } }; More optimized approach Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } }; Find the starting point of cycle in linked list Problem on Leetcode \\(\\to\\) Problem Statement Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory, Linked List definition // Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} }; Approach with extra space We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle. Pseudocode for this apporach ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; } Time and Space complexity Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable. Approach with no extra space First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet. Video for intuition The following is a video explaining why this apporach works? C++ Code class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } }; Given the head of a linked list, rotate the list to the right by k places Problem Statement Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints: The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\) Approach First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL . C++ Code class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } }; Copy List with Random Pointer Find the Problem on leetcode \\(\\to\\) Problem Statement A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. C++ Node definition class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } }; Approach Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } }; Time and Memory complexity We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.","title":"Linked List problems"},{"location":"LinkedLists/problems/#linked-list-problems","text":"","title":"Linked List problems"},{"location":"LinkedLists/problems/#implement-linked-list-and-write-reverse","text":"","title":"Implement Linked list and write reverse()"},{"location":"LinkedLists/problems/#problem-statement","text":"Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach","text":"Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space.","title":"Approach"},{"location":"LinkedLists/problems/#c-code-for-linked-list","text":"#include <iostream> using std :: cout ; using std :: endl ; using std :: vector ; template < class T > class LinkedListNode { public : T data ; LinkedListNode < T > * next ; }; template < class T > class LinkedList { private : LinkedListNode < T > * head ; LinkedListNode < T > * end ; int classPriveSize ; public : LinkedList () { head = NULL ; end = NULL ; classPriveSize = 0 ; } ~ LinkedList () { Clear (); } void push_back ( T value ) { if ( classPriveSize == 0 ) { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; head = newNode ; end = newNode ; } else { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; end -> next = newNode ; end = newNode ; } classPriveSize ++ ; } T front () { return head -> data ; } T back () { return end -> data ; } };","title":"C++ Code for Linked List"},{"location":"LinkedLists/problems/#linkedlist_reverse-method","text":"We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } };","title":"linkedlist_reverse() method"},{"location":"LinkedLists/problems/#middle-of-the-linked-list","text":"","title":"Middle of the Linked List"},{"location":"LinkedLists/problems/#problem-statement_1","text":"Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_1","text":"Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; }","title":"Approach"},{"location":"LinkedLists/problems/#merge-2-sorted-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Merge 2 sorted lists"},{"location":"LinkedLists/problems/#problem-statement_2","text":"You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4]","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_2","text":"We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list.","title":"Approach"},{"location":"LinkedLists/problems/#code","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; }","title":" Code"},{"location":"LinkedLists/problems/#time-and-space-complexity","text":"Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation.","title":" Time and Space complexity"},{"location":"LinkedLists/problems/#implementing-this-problem-in-place","text":"","title":"Implementing this problem in-place"},{"location":"LinkedLists/problems/#step-wise-iteration-explainer","text":"","title":"Step wise iteration explainer"},{"location":"LinkedLists/problems/#iteration-1","text":"","title":"Iteration 1"},{"location":"LinkedLists/problems/#iteration-2","text":"","title":"Iteration 2"},{"location":"LinkedLists/problems/#iteration-3","text":"","title":"Iteration 3"},{"location":"LinkedLists/problems/#iteration-4","text":"","title":"Iteration 4"},{"location":"LinkedLists/problems/#iteration-5-and-so-on-and-the-last","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } };","title":"Iteration 5, and so on and the last"},{"location":"LinkedLists/problems/#delete-node-in-a-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Delete Node in a Linked List"},{"location":"LinkedLists/problems/#problem-statement_3","text":"Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.","title":"Problem Statement"},{"location":"LinkedLists/problems/#example","text":"Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.","title":"Example"},{"location":"LinkedLists/problems/#approach_3","text":"Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } };","title":"Approach"},{"location":"LinkedLists/problems/#remove-nth-node-from-end-of-list","text":"Given the head of a linked list, remove the nth node from the end of the list and return its head","title":"Remove Nth Node From End of List"},{"location":"LinkedLists/problems/#video-explaination","text":"","title":"Video Explaination"},{"location":"LinkedLists/problems/#example_1","text":"For elements \\([1, 2, 3, 4, 5]\\) , remove the second node from the last. This will return \\([1, 2, 3, 5]\\) . Similarly \\([1]\\) and \\(n = 1\\) will return \\([]\\) .","title":"Example"},{"location":"LinkedLists/problems/#constraints","text":"Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ The number of nodes in the list is \\(\\mathcal{N}\\) 1 <= \\(\\mathcal{N}\\) <= 30 0 <= (new ListNode())->val <= 100 1 <= n <= \\(\\mathcal{N}\\) (n is within the bounds).","title":"Constraints"},{"location":"LinkedLists/problems/#approach_4","text":"","title":"Approach"},{"location":"LinkedLists/problems/#implementation-with-two-pass","text":"Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; }","title":"Implementation with two pass"},{"location":"LinkedLists/problems/#implementation-with-one-pass-only","text":"With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last.","title":"Implementation with one pass only"},{"location":"LinkedLists/problems/#a-bit-modification","text":"We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following","title":"A bit modification"},{"location":"LinkedLists/problems/#edge-case","text":"There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; }","title":"Edge Case"},{"location":"LinkedLists/problems/#c-code","text":"ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; }","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_1","text":"For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#add-two-numbers-given-as-linkedlists","text":"Asked in Amazon, Microsoft, Facebook, Qualcomm.","title":"Add Two Numbers Given as LinkedLists"},{"location":"LinkedLists/problems/#elsewhere","text":"Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\)","title":"Elsewhere"},{"location":"LinkedLists/problems/#problem-statement_4","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","title":"Problem Statement"},{"location":"LinkedLists/problems/#testcase-examples","text":"\\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\)","title":"Testcase Examples"},{"location":"LinkedLists/problems/#approach_5","text":"Do normal addition from 1st standard and add digit by digit in a new linked list.","title":"Approach"},{"location":"LinkedLists/problems/#c-code_1","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; }","title":"C++ code"},{"location":"LinkedLists/problems/#c-code-for-leetcode-with-custom-definition-for-singly-linked-list","text":"Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } };","title":"C++ code for leetcode with custom definition for singly-linked list"},{"location":"LinkedLists/problems/#intersection-of-two-linked-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Intersection of Two Linked Lists"},{"location":"LinkedLists/problems/#problem-statement_5","text":"Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null .","title":"Problem Statement"},{"location":"LinkedLists/problems/#example_2","text":"For the following problem, head1 and head2 are given, find the marked blue intersection point.","title":"Example"},{"location":"LinkedLists/problems/#approach_6","text":"","title":"Approach"},{"location":"LinkedLists/problems/#brute-force-approach","text":"For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space.","title":"Brute Force approach"},{"location":"LinkedLists/problems/#using-hash-table","text":"As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point.","title":"Using Hash table"},{"location":"LinkedLists/problems/#c-code_2","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_2","text":"As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#linear-time-and-constant-space-approach","text":"Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean:","title":"Linear time and Constant Space Approach"},{"location":"LinkedLists/problems/#c-code-for-most-optimal-approach","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } };","title":"C++ Code for Most Optimal Approach"},{"location":"LinkedLists/problems/#time-and-space-complexity_3","text":"The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#detect-a-cycle-in-linked-list","text":"","title":"Detect a cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_6","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_7","text":"Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_3","text":"class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_4","text":"\\(O(N)\\) time and no extra space.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#palindrome-linked-list","text":"","title":"Palindrome Linked list"},{"location":"LinkedLists/problems/#problem-statement_7","text":"Given the head of a singly linked list, return true if it is a palindrome.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach-with-more-space","text":"First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false .","title":"Approach With More Space"},{"location":"LinkedLists/problems/#c-code_4","text":"class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#more-optimized-approach","text":"Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } };","title":"More optimized approach"},{"location":"LinkedLists/problems/#find-the-starting-point-of-cycle-in-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Find the starting point of cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_8","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list.","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_1","text":"The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory,","title":"Constraints"},{"location":"LinkedLists/problems/#linked-list-definition","text":"// Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} };","title":"Linked List definition"},{"location":"LinkedLists/problems/#approach-with-extra-space","text":"We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle.","title":"Approach with extra space"},{"location":"LinkedLists/problems/#pseudocode-for-this-apporach","text":"ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; }","title":"Pseudocode for this apporach"},{"location":"LinkedLists/problems/#time-and-space-complexity_5","text":"Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable.","title":"Time and Space complexity"},{"location":"LinkedLists/problems/#approach-with-no-extra-space","text":"First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet.","title":"Approach with no extra space"},{"location":"LinkedLists/problems/#video-for-intuition","text":"The following is a video explaining why this apporach works?","title":"Video for intuition"},{"location":"LinkedLists/problems/#c-code_5","text":"class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#given-the-head-of-a-linked-list-rotate-the-list-to-the-right-by-k-places","text":"","title":"Given the head of a linked list, rotate the list to the right by k places"},{"location":"LinkedLists/problems/#problem-statement_9","text":"Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1]","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_2","text":"The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\)","title":"Constraints:"},{"location":"LinkedLists/problems/#approach_8","text":"First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_6","text":"class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#copy-list-with-random-pointer","text":"Find the Problem on leetcode \\(\\to\\)","title":"Copy List with Random Pointer"},{"location":"LinkedLists/problems/#problem-statement_10","text":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.","title":"Problem Statement"},{"location":"LinkedLists/problems/#c-node-definition","text":"class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } };","title":"C++ Node definition"},{"location":"LinkedLists/problems/#approach_9","text":"Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } };","title":"Approach"},{"location":"LinkedLists/problems/#time-and-memory-complexity","text":"We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.","title":"Time and Memory complexity"},{"location":"LinkedLists/stl-usage/","text":"Linked List STL operations Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure . Table of contents Linked List STL operations Table of contents std::list<typename> Operations Operation Modefiers Essential operations std::forward_list<typename> std::list<typename> supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted. Operations front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; } Operation Modefiers Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front() Essential operations merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; } std::forward_list<typename> front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"Linked List STL Usage"},{"location":"LinkedLists/stl-usage/#linked-list-stl-operations","text":"Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure .","title":"Linked List STL operations"},{"location":"LinkedLists/stl-usage/#table-of-contents","text":"Linked List STL operations Table of contents std::list<typename> Operations Operation Modefiers Essential operations std::forward_list<typename>","title":"Table of contents"},{"location":"LinkedLists/stl-usage/#stdlisttypename","text":"supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.","title":"std::list&lt;typename&gt;"},{"location":"LinkedLists/stl-usage/#operations","text":"front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; }","title":"Operations"},{"location":"LinkedLists/stl-usage/#operation-modefiers","text":"Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front()","title":"Operation Modefiers"},{"location":"LinkedLists/stl-usage/#essential-operations","text":"merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; }","title":"Essential operations"},{"location":"LinkedLists/stl-usage/#stdforward_listtypename","text":"front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"std::forward_list&lt;typename&gt;"},{"location":"arrays/array-problems/","text":"Problems on arrays Dutch National Flag Partitioning Problem Statement Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color. Solution Pattern Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an average \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Average running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time. String Compression Problem Problem Statement Implement a method to perform basic string compression, like this \"aaaabbbcccaa\" -> \"a4b3c3a2\" My first Approach Make a one key dictionary. Add and count the subsequent characters, Once you find a new element then drop the key, add the contents to the builder string and count again. def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2' Time complexity This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string. Find All Numbers Disappeared in an Array Problem Statement Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Examples Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Input: nums = [1,1] Output: [2] Constraints n == len(nums) 1 <= n <= 105 1 <= nums[i] <= n Algorithm must run in \\(O(N)\\) time and no extra space. def findDisappearedNumbers ( self , nums : list [ int ]) -> list [ int ]: pass","title":"Array Problems"},{"location":"arrays/array-problems/#problems-on-arrays","text":"","title":"Problems on arrays"},{"location":"arrays/array-problems/#dutch-national-flag-partitioning","text":"","title":"Dutch National Flag Partitioning"},{"location":"arrays/array-problems/#problem-statement","text":"Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color.","title":"Problem Statement"},{"location":"arrays/array-problems/#solution-pattern","text":"Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an average \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Average running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time.","title":"Solution Pattern"},{"location":"arrays/array-problems/#string-compression-problem","text":"","title":"String Compression Problem"},{"location":"arrays/array-problems/#problem-statement_1","text":"Implement a method to perform basic string compression, like this \"aaaabbbcccaa\" -> \"a4b3c3a2\"","title":"Problem Statement"},{"location":"arrays/array-problems/#my-first-approach","text":"Make a one key dictionary. Add and count the subsequent characters, Once you find a new element then drop the key, add the contents to the builder string and count again. def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2'","title":"My first Approach"},{"location":"arrays/array-problems/#time-complexity","text":"This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string.","title":"Time complexity"},{"location":"arrays/array-problems/#find-all-numbers-disappeared-in-an-array","text":"","title":"Find All Numbers Disappeared in an Array"},{"location":"arrays/array-problems/#problem-statement_2","text":"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.","title":"Problem Statement"},{"location":"arrays/array-problems/#examples","text":"Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Input: nums = [1,1] Output: [2]","title":"Examples"},{"location":"arrays/array-problems/#constraints","text":"n == len(nums) 1 <= n <= 105 1 <= nums[i] <= n Algorithm must run in \\(O(N)\\) time and no extra space. def findDisappearedNumbers ( self , nums : list [ int ]) -> list [ int ]: pass","title":"Constraints"},{"location":"arrays/arrays/","tags":["introduction","Python"],"text":"Arrays Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array. Example problem Problem Statement ```{admonition} Problem Your input is an array of integers, and you have to reorder its entries so that the even entries appear first. ### Solution We can solve the problem with $O(N)$ space trivially. But to solve the problem with constant space we have to reuse space inside the given array. ![array1](../images/arrays.png) #### Algorithm - Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from $0 \\to (N-1)$ to $0 \\to (N-2)$ - If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from $0 \\to(N-1)$ to $1 \\to (N-1)$ - Repeat until pointers pointing start of the array crosses pointers pointing end of the array. #### Python Code [Python 3.9 and above] ```python def even_odd_separation(array: list[int]): start: int, end: int = 0, len(array) - 1 # Don't stop until start crosses end while start < end: if array[start] % 2 == 0: # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else: # Number infront of the array is odd array[start], array[end] = array[end], array[start] end -= 1 Time and space complexity The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . ```{admonition} Test cases Test PASSED (1001/1001) [ 7 ms] Average running time: 22 us Median running time: 7 us ## Things to remember before solving Array Questions - Array problems often have simple brute.force solutions that use $O(n)$ space, but there are subtler solutions that use the array itself to reduce space complexity to $O(1)$, - Filling an array from the front is slow, so see if it's possible to write values from the back, with `append()` method, - Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case $O(N)$, beacuse all the elements to the right have to swapped one step left, - `A.reverse()` is inplace reversal of array, - `reversed(A)` returns an iterator, - `del A[i]` removes the i th element, - `A[::-1]` reverses the array, - Try using more of the list comprehension methods. ## One toy problem ```{admonition} Problem statement Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Examples Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Solution Approach Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element. Code def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Intro to Arrays"},{"location":"arrays/arrays/#arrays","text":"Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array.","title":"Arrays"},{"location":"arrays/arrays/#example-problem","text":"","title":"Example problem"},{"location":"arrays/arrays/#problem-statement","text":"```{admonition} Problem Your input is an array of integers, and you have to reorder its entries so that the even entries appear first. ### Solution We can solve the problem with $O(N)$ space trivially. But to solve the problem with constant space we have to reuse space inside the given array. ![array1](../images/arrays.png) #### Algorithm - Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from $0 \\to (N-1)$ to $0 \\to (N-2)$ - If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from $0 \\to(N-1)$ to $1 \\to (N-1)$ - Repeat until pointers pointing start of the array crosses pointers pointing end of the array. #### Python Code [Python 3.9 and above] ```python def even_odd_separation(array: list[int]): start: int, end: int = 0, len(array) - 1 # Don't stop until start crosses end while start < end: if array[start] % 2 == 0: # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else: # Number infront of the array is odd array[start], array[end] = array[end], array[start] end -= 1","title":"Problem Statement"},{"location":"arrays/arrays/#time-and-space-complexity","text":"The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . ```{admonition} Test cases Test PASSED (1001/1001) [ 7 ms] Average running time: 22 us Median running time: 7 us ## Things to remember before solving Array Questions - Array problems often have simple brute.force solutions that use $O(n)$ space, but there are subtler solutions that use the array itself to reduce space complexity to $O(1)$, - Filling an array from the front is slow, so see if it's possible to write values from the back, with `append()` method, - Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case $O(N)$, beacuse all the elements to the right have to swapped one step left, - `A.reverse()` is inplace reversal of array, - `reversed(A)` returns an iterator, - `del A[i]` removes the i th element, - `A[::-1]` reverses the array, - Try using more of the list comprehension methods. ## One toy problem ```{admonition} Problem statement Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","title":"Time and space complexity"},{"location":"arrays/arrays/#examples","text":"Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.","title":"Examples"},{"location":"arrays/arrays/#solution","text":"","title":"Solution"},{"location":"arrays/arrays/#approach","text":"Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element.","title":"Approach"},{"location":"arrays/arrays/#code","text":"def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Code"},{"location":"arrays/sliding-window/","text":"Sliding Windows Problem Introduction Linked list or arrays find something among all contigious sub array of some given size. Example problem Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8] Brute force apprach A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8] Problems with this apporach Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs Optimized approach with while loop def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8] Maximum Sum subarray of size K Problem Statement Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 . Examples Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4]. Approach [Naive on back of the envelope approach] def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7 Time complexity Only one pass of the array so the time complexity is \\(O(N)\\) Smallest subarray with a given sum Problem statement Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists. Examples Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6]. Brute force approach Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3 Time complexity \\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\) Better Optimized approach First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ... Longest Substring with K Distinct Characters Problem statement Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Sliding window problems"},{"location":"arrays/sliding-window/#sliding-windows-problem-introduction","text":"Linked list or arrays find something among all contigious sub array of some given size.","title":"Sliding Windows Problem Introduction"},{"location":"arrays/sliding-window/#example-problem","text":"Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Example problem"},{"location":"arrays/sliding-window/#brute-force-apprach","text":"A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Brute force apprach"},{"location":"arrays/sliding-window/#problems-with-this-apporach","text":"Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs","title":"Problems with this apporach"},{"location":"arrays/sliding-window/#optimized-approach-with-while-loop","text":"def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Optimized approach with while loop"},{"location":"arrays/sliding-window/#maximum-sum-subarray-of-size-k","text":"","title":"Maximum Sum subarray of size K"},{"location":"arrays/sliding-window/#problem-statement","text":"Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 .","title":"Problem Statement"},{"location":"arrays/sliding-window/#examples","text":"Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4].","title":"Examples"},{"location":"arrays/sliding-window/#approach-naive-on-back-of-the-envelope-approach","text":"def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7","title":"Approach [Naive on back of the envelope approach]"},{"location":"arrays/sliding-window/#time-complexity","text":"Only one pass of the array so the time complexity is \\(O(N)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#smallest-subarray-with-a-given-sum","text":"","title":"Smallest subarray with a given sum"},{"location":"arrays/sliding-window/#problem-statement_1","text":"Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists.","title":"Problem statement"},{"location":"arrays/sliding-window/#examples_1","text":"Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6].","title":"Examples"},{"location":"arrays/sliding-window/#brute-force-approach","text":"Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3","title":"Brute force approach"},{"location":"arrays/sliding-window/#time-complexity_1","text":"\\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#better-optimized-approach","text":"First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ...","title":"Better Optimized approach"},{"location":"arrays/sliding-window/#longest-substring-with-k-distinct-characters","text":"","title":"Longest Substring with K Distinct Characters"},{"location":"arrays/sliding-window/#problem-statement_2","text":"Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Problem statement"},{"location":"graph/bfs-dfs/","text":"Breath first and depth-first search BFS and DFS are two of the most common graph as well as tree traversal techniques that ever existed. You should always understand the basic understanding behind these traversals. Things to remember about BFS uses a queue and FIFO ordering is something that it uses. DFS uses recursion, and recursively goes in-depth until the element is found. Standard Graph implementation We'll use our standard implementation for graphs and will write BFS and DFS to work on that standard graph. The following graph implementation may not be the very best implementation that you'll find, but it is good enough and most importantly you'll be able to implement this in an interview setting. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; public : void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; Now on top of this custom graph [adjacency list] representation, we'll implement BFS and DFS the 2 most common algorithms in graphs and trees ever. BFS with standard graph Implementation follows the CLRS textbook for reference although is not a blind copy. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> #include <queue> vector < char > BFS ( Graph & g , char startFromVertex ){ // create a queue queue < char > q ; // result order for the bfs vector < char > bfstree ; // the graph as a map unordered_map < char , list < pair < char , int >>> graphView = g . view (); // visited map unordered_map < char , bool > visited ; for ( auto vertex : graphView ) visited [ vertex . first ] = false ; q . push ( startFromVertex ); // startFromVertex must be in graph g while ( ! q . empty ()){ char vert = q . front (); if ( visited [ vert ] == false ){ // if we did not visit this vertex please process bfstree . push_back ( vert ); auto neighbors = graphView [ vert ]; for ( auto neighbor : neighbors ){ q . push ( neighbor . first ); } visited [ vert ] = true ; } // now remove the vertex q . pop (); } return bfstree ; } DFS on standard Graph Implementation of DFS is recursive, it recursively goes into the graph then backtracks once there is nowhere to go. But in this implementation, I'll strictly avoid recursion because the graph is a little hard to grasp, and doing recursion on a graph may seem \\(\\text{BLACK MAGIC}\\) . Instead, I'll implement DFS using a stack data structure to mimic recursion. It's an iterative implementation that is much easier to grasp. vector < char > DFS ( Graph & g , char startFromVertex ){ vector < char > stack ; unordered_map < char , bool > visited ; vector < char > dfsOrder ; auto graphView = g . view (); // initialize all the visited == false for ( auto vertex : graphView ) visited [ vertex . first ] = false ; // push whatever with you are starting with stack . push_back ( startFromVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ // if this top of the stack is not visited then mark it // visited and push into the answer array [dfsOrder]. visited [ tos ] = true ; dfsOrder . push_back ( tos ); } for ( auto adj_list : graphView [ tos ]){ // look at the adj_list of tos vertex if ( visited [ adj_list . first ] == false ){ stack . push_back ( adj_list . first ); } } } return dfsOrder ; } Application of depth first search Find all the connected components of a graph Approach Using depth first search we can go in depth of a graph and for each connected components the DFS program will stop. We do this until we visit all the nodes in a graph. This way we'll find all the connected components of the graph. C++ Code #include <algorithm> #include <iostream> #include <vector> #include <unordered_map> #include <forward_list> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertices ){ for ( char vert : vertices ){ forward_list < char > neighbor ; adj_list . insert ({ vert , neighbor }); } } unordered_map < char , forward_list < char >> view (){ return adj_list ; } void add_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } }; vector < char > DFSOrder ( Graph & g , char startingVertex ){ unordered_map < char , bool > visited ; vector < char > stack ; vector < char > order ; auto view = g . view (); // mark all node to visited == false for ( auto y : view ) visited [ y . first ] = false ; stack . push_back ( startingVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ visited [ tos ] = true ; order . push_back ( tos ); } for ( auto nbr : view [ tos ]){ if ( visited [ nbr ] == false ){ stack . push_back ( nbr ); } } } return order ; } void connected_components ( Graph & g ){ unordered_map < char , bool > visited ; auto view = g . view (); // mark all node to visited == false // doesn't matter what is the value for each (key, value) pair in map; // we'll be deleting upon seeing a key that is visited. // we could have made a vector then the delete would become O(n); for ( auto y : view ) visited [ y . first ] = false ; // while( visited == all not true) // use dfs; int connected_component_number = 0 ; while ( ! visited . empty ()){ // take any random vertex that is not yet visited char startingVertex = visited . begin () -> first ; vector < char > dfs = DFSOrder ( g , startingVertex ); cout << \"Connected Component Number: \" << connected_component_number << \" -> \" ; // now remove all the visited in this call of dfs for ( char this_component_vertex : dfs ){ cout << this_component_vertex << \" \" ; visited . erase ( this_component_vertex ); } connected_component_number ++ ; cout << endl ; } } // DRIVER CODE int main (){ int number_of_vertices ; vector < char > v ; cin >> number_of_vertices ; while ( number_of_vertices ){ char vertex ; cin >> vertex ; v . push_back ( vertex ); number_of_vertices -- ; } Graph g = Graph ( v ); int number_of_edges ; cin >> number_of_edges ; while ( number_of_edges ){ char from , to ; cin >> from >> to ; g . add_edge ( from , to ); number_of_edges -- ; } auto view = g . view (); for ( auto vert : view ){ cout << vert . first << \" -> \" ; for ( auto nbr : vert . second ) cout << nbr << \" \" ; cout << endl ; } vector < char > dfs = DFSOrder ( g , 'a' ); cout << \"DFS ORDER Starting From 'a' -> \" ; for ( auto i : dfs ) cout << i << \" \" ; cout << endl ; connected_components ( g ); } Let's run the above program on a random graph Input Pattern 5 <- Number of vertices a b c <- all the vertices of the graph d e 3 <- number of edges a b <- Edges in between vertices, undirected edges b c c e Example Output e -> c d -> c -> e b a -> b b -> c a DFS ORDER Starting From 'a' -> a b c e Connected Component Number: 0 -> b a c e Connected Component Number: 1 -> d","title":"BFS and DFS"},{"location":"graph/bfs-dfs/#breath-first-and-depth-first-search","text":"BFS and DFS are two of the most common graph as well as tree traversal techniques that ever existed. You should always understand the basic understanding behind these traversals.","title":"Breath first and depth-first search"},{"location":"graph/bfs-dfs/#things-to-remember-about","text":"BFS uses a queue and FIFO ordering is something that it uses. DFS uses recursion, and recursively goes in-depth until the element is found.","title":"Things to remember about"},{"location":"graph/bfs-dfs/#standard-graph-implementation","text":"We'll use our standard implementation for graphs and will write BFS and DFS to work on that standard graph. The following graph implementation may not be the very best implementation that you'll find, but it is good enough and most importantly you'll be able to implement this in an interview setting. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; public : void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; Now on top of this custom graph [adjacency list] representation, we'll implement BFS and DFS the 2 most common algorithms in graphs and trees ever.","title":"Standard Graph implementation"},{"location":"graph/bfs-dfs/#bfs-with-standard-graph","text":"Implementation follows the CLRS textbook for reference although is not a blind copy. #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> #include <queue> vector < char > BFS ( Graph & g , char startFromVertex ){ // create a queue queue < char > q ; // result order for the bfs vector < char > bfstree ; // the graph as a map unordered_map < char , list < pair < char , int >>> graphView = g . view (); // visited map unordered_map < char , bool > visited ; for ( auto vertex : graphView ) visited [ vertex . first ] = false ; q . push ( startFromVertex ); // startFromVertex must be in graph g while ( ! q . empty ()){ char vert = q . front (); if ( visited [ vert ] == false ){ // if we did not visit this vertex please process bfstree . push_back ( vert ); auto neighbors = graphView [ vert ]; for ( auto neighbor : neighbors ){ q . push ( neighbor . first ); } visited [ vert ] = true ; } // now remove the vertex q . pop (); } return bfstree ; }","title":"BFS with standard graph"},{"location":"graph/bfs-dfs/#dfs-on-standard-graph","text":"Implementation of DFS is recursive, it recursively goes into the graph then backtracks once there is nowhere to go. But in this implementation, I'll strictly avoid recursion because the graph is a little hard to grasp, and doing recursion on a graph may seem \\(\\text{BLACK MAGIC}\\) . Instead, I'll implement DFS using a stack data structure to mimic recursion. It's an iterative implementation that is much easier to grasp. vector < char > DFS ( Graph & g , char startFromVertex ){ vector < char > stack ; unordered_map < char , bool > visited ; vector < char > dfsOrder ; auto graphView = g . view (); // initialize all the visited == false for ( auto vertex : graphView ) visited [ vertex . first ] = false ; // push whatever with you are starting with stack . push_back ( startFromVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ // if this top of the stack is not visited then mark it // visited and push into the answer array [dfsOrder]. visited [ tos ] = true ; dfsOrder . push_back ( tos ); } for ( auto adj_list : graphView [ tos ]){ // look at the adj_list of tos vertex if ( visited [ adj_list . first ] == false ){ stack . push_back ( adj_list . first ); } } } return dfsOrder ; }","title":"DFS on standard Graph"},{"location":"graph/bfs-dfs/#application-of-depth-first-search","text":"","title":"Application of depth first search"},{"location":"graph/bfs-dfs/#find-all-the-connected-components-of-a-graph","text":"","title":"Find all the connected components of a graph"},{"location":"graph/bfs-dfs/#approach","text":"Using depth first search we can go in depth of a graph and for each connected components the DFS program will stop. We do this until we visit all the nodes in a graph. This way we'll find all the connected components of the graph.","title":"Approach"},{"location":"graph/bfs-dfs/#c-code","text":"#include <algorithm> #include <iostream> #include <vector> #include <unordered_map> #include <forward_list> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertices ){ for ( char vert : vertices ){ forward_list < char > neighbor ; adj_list . insert ({ vert , neighbor }); } } unordered_map < char , forward_list < char >> view (){ return adj_list ; } void add_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } }; vector < char > DFSOrder ( Graph & g , char startingVertex ){ unordered_map < char , bool > visited ; vector < char > stack ; vector < char > order ; auto view = g . view (); // mark all node to visited == false for ( auto y : view ) visited [ y . first ] = false ; stack . push_back ( startingVertex ); while ( ! stack . empty ()){ char tos = stack . back (); stack . pop_back (); if ( visited [ tos ] == false ){ visited [ tos ] = true ; order . push_back ( tos ); } for ( auto nbr : view [ tos ]){ if ( visited [ nbr ] == false ){ stack . push_back ( nbr ); } } } return order ; } void connected_components ( Graph & g ){ unordered_map < char , bool > visited ; auto view = g . view (); // mark all node to visited == false // doesn't matter what is the value for each (key, value) pair in map; // we'll be deleting upon seeing a key that is visited. // we could have made a vector then the delete would become O(n); for ( auto y : view ) visited [ y . first ] = false ; // while( visited == all not true) // use dfs; int connected_component_number = 0 ; while ( ! visited . empty ()){ // take any random vertex that is not yet visited char startingVertex = visited . begin () -> first ; vector < char > dfs = DFSOrder ( g , startingVertex ); cout << \"Connected Component Number: \" << connected_component_number << \" -> \" ; // now remove all the visited in this call of dfs for ( char this_component_vertex : dfs ){ cout << this_component_vertex << \" \" ; visited . erase ( this_component_vertex ); } connected_component_number ++ ; cout << endl ; } } // DRIVER CODE int main (){ int number_of_vertices ; vector < char > v ; cin >> number_of_vertices ; while ( number_of_vertices ){ char vertex ; cin >> vertex ; v . push_back ( vertex ); number_of_vertices -- ; } Graph g = Graph ( v ); int number_of_edges ; cin >> number_of_edges ; while ( number_of_edges ){ char from , to ; cin >> from >> to ; g . add_edge ( from , to ); number_of_edges -- ; } auto view = g . view (); for ( auto vert : view ){ cout << vert . first << \" -> \" ; for ( auto nbr : vert . second ) cout << nbr << \" \" ; cout << endl ; } vector < char > dfs = DFSOrder ( g , 'a' ); cout << \"DFS ORDER Starting From 'a' -> \" ; for ( auto i : dfs ) cout << i << \" \" ; cout << endl ; connected_components ( g ); } Let's run the above program on a random graph","title":"C++ Code"},{"location":"graph/bfs-dfs/#input-pattern","text":"5 <- Number of vertices a b c <- all the vertices of the graph d e 3 <- number of edges a b <- Edges in between vertices, undirected edges b c c e","title":"Input Pattern"},{"location":"graph/bfs-dfs/#example-output","text":"e -> c d -> c -> e b a -> b b -> c a DFS ORDER Starting From 'a' -> a b c e Connected Component Number: 0 -> b a c e Connected Component Number: 1 -> d","title":"Example Output"},{"location":"graph/problems/","text":"More Graph Problems Cycle Detection in Undirected Graph Using simple traversal techniques we can detect cycles in undirected graphs. Here first we'll implement this using breath first search then we'll also show how to do this using depth first search. // UNDIRECTED GRAPH DEFINITION class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ) { for ( auto i : vertexSet ) { forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_edge ( char from , char to ) { // undirected graph adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } unordered_map < char , forward_list < char >> view () { return adj_list ; } }; Approach using breath first search The apporach is very simple, if during traversal if you find any one of the neighbor of some vertex previously visited other than the immediate parent/neighbor means there is a cycle. So put the vertex and it's immediate parent inside a Queue (to run BFS). bool CYCLE_DETECTABLE_SEARCH ( Graph & g , char startingVertex ) { // For BFS we need a queue and this queue has vertex and it's // immediate parent as a pair<char, char> queue < pair < char , char >> q ; unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; // for starting vertex parent = 'N' for NULL; q . push ({ startingVertex , 'N' }); visited [ startingVertex ] = true ; while ( ! q . empty ()) { pair < char , char > front = q . front (); q . pop (); char thisvertex = front . first ; char parent = front . second ; // for all the neighbors for thisvertex insert into queue // mark thisvertex as their immediate parents // if we see some visited vertex other than it's immediate neighbor/parent // return true for ( char nbr : graphView [ thisvertex ]) { if ( visited [ nbr ] == false ) { visited [ nbr ] = true ; q . push ({ nbr , thisvertex }); } else if ( visited [ nbr ] == true and nbr != parent ) { // this neighbor of the vertex is already visited // and this neighbor is not the immediate parent // meaning there must be a cycle. return true ; } } } return false ; } bool hasCycle ( Graph & g ) { // assuming multiple connected components are there unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; bool hasCycleForThisComponent ; for ( auto vertex : graphView ) { if ( ! visited [ vertex . first ]) { hasCycleForThisComponent = CYCLE_DETECTABLE_SEARCH ( g , vertex . first ); } if ( hasCycleForThisComponent ) { return true ; } } return false ; } Bipartite Graph Check Problem Statement Given a graph G find out if this is a bipartite graph? For a bipartite graph, the graph has 2 set of vertices, in each set vertices are not connected to each other. Approach Bi-partite graph is a 2 colorable graph, one approach could be if we check a graph if it's 2 colorable then it's bipartite. Bipartite is equivalent to 2-colorable. Here we'll traverse through the graph and color every vertex. Now if we find some vertex that takes other than the 2 color considered first we'll say it is not bipartite. Else if the entire graph is 2 colorable then we'll return true. Also we can approach this problem as this \\(\\to\\) any odd length cycle containing graph is not a bipartite graph. // Any 2 Colorable graph is a bipartite graph Approach is much simpler to go through. enum class Color { black , red , gray }; // gray is to indicate that the vertex is not visted yet bool isBipartite ( Graph & g ) { // set all the graph vertex color as gray auto graph = g . view (); unordered_map < char , Color > color ; for ( auto vertex : graph ) { color [ vertex . first ] = Color :: gray ; } // set a starting index where to start the journey char startingVertex = graph . begin () -> first ; // create a queue for bfs queue < char > q ; q . push ( startingVertex ); color [ startingVertex ] = Color :: red ; // run a bfs while ( ! q . empty ()) { char thisvertex = q . front (); q . pop (); for ( char nbr : graph [ thisvertex ]) { if ( color [ nbr ] == Color :: gray ) { // if not visited then only process if ( color [ thisvertex ] == Color :: red ) { color [ nbr ] = Color :: black ; } else if ( color [ thisvertex ] == Color :: black ) { color [ nbr ] = Color :: red ; } // push into the queue for bfs q . push ( nbr ); } else { // check for termination condition if ( color [ nbr ] == color [ thisvertex ]) { return false ; } } } } return true ; } Directed Graph Problems In this section the given graph has directed edges, below are some standard directed graph problems that is the building block for many other graph problems in general. Topological Sort Problem Cycle Detection Strongly connected components (Kosaraju's algorithm). Topological Sorting of a Directed graph Problem Statement Topological sorting for Directed Acyclic Graph is a linear ordering of vertices such that for every directed \\((u, v) \\in \\mathbf{V}\\) , \\(u\\) comes before \\(v\\) . In other words in order to reach \\(v\\) you must go through \\(u\\) . Approach In order to start our topological sorting we must indentify a node that has no dependencies. We'll start from one of such nodes. This can be automated with the algorithm or can be relied on the user to give as an input. In this implementation we'll assume no such event. User will only give the Graph G and we'll find some node to start on on our own. // Directed Graph Varient #include <iostream> #include <unordered_map> #include <forward_list> #include <vector> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ){ for ( auto i : vertexSet ){ forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_directed_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); } unordered_map < char , forward_list < char >> view (){ return adj_list ; } };","title":"Graph Problems"},{"location":"graph/problems/#more-graph-problems","text":"","title":"More Graph Problems"},{"location":"graph/problems/#cycle-detection-in-undirected-graph","text":"Using simple traversal techniques we can detect cycles in undirected graphs. Here first we'll implement this using breath first search then we'll also show how to do this using depth first search. // UNDIRECTED GRAPH DEFINITION class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ) { for ( auto i : vertexSet ) { forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_edge ( char from , char to ) { // undirected graph adj_list [ from ]. push_front ( to ); adj_list [ to ]. push_front ( from ); } unordered_map < char , forward_list < char >> view () { return adj_list ; } };","title":"Cycle Detection in Undirected Graph"},{"location":"graph/problems/#approach-using-breath-first-search","text":"The apporach is very simple, if during traversal if you find any one of the neighbor of some vertex previously visited other than the immediate parent/neighbor means there is a cycle. So put the vertex and it's immediate parent inside a Queue (to run BFS). bool CYCLE_DETECTABLE_SEARCH ( Graph & g , char startingVertex ) { // For BFS we need a queue and this queue has vertex and it's // immediate parent as a pair<char, char> queue < pair < char , char >> q ; unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; // for starting vertex parent = 'N' for NULL; q . push ({ startingVertex , 'N' }); visited [ startingVertex ] = true ; while ( ! q . empty ()) { pair < char , char > front = q . front (); q . pop (); char thisvertex = front . first ; char parent = front . second ; // for all the neighbors for thisvertex insert into queue // mark thisvertex as their immediate parents // if we see some visited vertex other than it's immediate neighbor/parent // return true for ( char nbr : graphView [ thisvertex ]) { if ( visited [ nbr ] == false ) { visited [ nbr ] = true ; q . push ({ nbr , thisvertex }); } else if ( visited [ nbr ] == true and nbr != parent ) { // this neighbor of the vertex is already visited // and this neighbor is not the immediate parent // meaning there must be a cycle. return true ; } } } return false ; } bool hasCycle ( Graph & g ) { // assuming multiple connected components are there unordered_map < char , bool > visited ; auto graphView = g . view (); for ( auto vertexName : graphView ) visited [ vertexName . first ] = false ; bool hasCycleForThisComponent ; for ( auto vertex : graphView ) { if ( ! visited [ vertex . first ]) { hasCycleForThisComponent = CYCLE_DETECTABLE_SEARCH ( g , vertex . first ); } if ( hasCycleForThisComponent ) { return true ; } } return false ; }","title":"Approach using breath first search"},{"location":"graph/problems/#bipartite-graph-check","text":"","title":"Bipartite Graph Check"},{"location":"graph/problems/#problem-statement","text":"Given a graph G find out if this is a bipartite graph? For a bipartite graph, the graph has 2 set of vertices, in each set vertices are not connected to each other.","title":"Problem Statement"},{"location":"graph/problems/#approach","text":"Bi-partite graph is a 2 colorable graph, one approach could be if we check a graph if it's 2 colorable then it's bipartite. Bipartite is equivalent to 2-colorable. Here we'll traverse through the graph and color every vertex. Now if we find some vertex that takes other than the 2 color considered first we'll say it is not bipartite. Else if the entire graph is 2 colorable then we'll return true. Also we can approach this problem as this \\(\\to\\) any odd length cycle containing graph is not a bipartite graph. // Any 2 Colorable graph is a bipartite graph Approach is much simpler to go through. enum class Color { black , red , gray }; // gray is to indicate that the vertex is not visted yet bool isBipartite ( Graph & g ) { // set all the graph vertex color as gray auto graph = g . view (); unordered_map < char , Color > color ; for ( auto vertex : graph ) { color [ vertex . first ] = Color :: gray ; } // set a starting index where to start the journey char startingVertex = graph . begin () -> first ; // create a queue for bfs queue < char > q ; q . push ( startingVertex ); color [ startingVertex ] = Color :: red ; // run a bfs while ( ! q . empty ()) { char thisvertex = q . front (); q . pop (); for ( char nbr : graph [ thisvertex ]) { if ( color [ nbr ] == Color :: gray ) { // if not visited then only process if ( color [ thisvertex ] == Color :: red ) { color [ nbr ] = Color :: black ; } else if ( color [ thisvertex ] == Color :: black ) { color [ nbr ] = Color :: red ; } // push into the queue for bfs q . push ( nbr ); } else { // check for termination condition if ( color [ nbr ] == color [ thisvertex ]) { return false ; } } } } return true ; }","title":"Approach"},{"location":"graph/problems/#directed-graph-problems","text":"In this section the given graph has directed edges, below are some standard directed graph problems that is the building block for many other graph problems in general. Topological Sort Problem Cycle Detection Strongly connected components (Kosaraju's algorithm).","title":"Directed Graph Problems"},{"location":"graph/problems/#topological-sorting-of-a-directed-graph","text":"","title":"Topological Sorting of a Directed graph"},{"location":"graph/problems/#problem-statement_1","text":"Topological sorting for Directed Acyclic Graph is a linear ordering of vertices such that for every directed \\((u, v) \\in \\mathbf{V}\\) , \\(u\\) comes before \\(v\\) . In other words in order to reach \\(v\\) you must go through \\(u\\) .","title":"Problem Statement"},{"location":"graph/problems/#approach_1","text":"In order to start our topological sorting we must indentify a node that has no dependencies. We'll start from one of such nodes. This can be automated with the algorithm or can be relied on the user to give as an input. In this implementation we'll assume no such event. User will only give the Graph G and we'll find some node to start on on our own. // Directed Graph Varient #include <iostream> #include <unordered_map> #include <forward_list> #include <vector> using namespace std ; class Graph { private : unordered_map < char , forward_list < char >> adj_list ; public : Graph ( vector < char > vertexSet ){ for ( auto i : vertexSet ){ forward_list < char > l ; adj_list . insert ({ i , l }); } } void add_directed_edge ( char from , char to ){ adj_list [ from ]. push_front ( to ); } unordered_map < char , forward_list < char >> view (){ return adj_list ; } };","title":"Approach"},{"location":"graph/usage/","text":"Graphs The graph is one of the most common and important data structures. With C++ and STL I'll show you the best possible implementation for the graph that you'll be able to implement and analyze in your code at FAANG interviews within the time constraints. Graph Adjacency List vs Adjacency Matrix Most of cases the List representation is good enough, if the graph is sparse then it will take less space, and if the graph is dense you should use the adjacency matrix representation. In my opinion any graph with less than 70% of the all possible edges : \\(\\text{Count(E)} \\geq 0.7 * {n \\choose 2}\\) present can be considered to be implemented as adjacency list. C++ Graph representation #include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; The following code shows how to make a graph and use it int main () { Graph g ; vector < char > v = { 'a' , 'b' , 'c' }; g . register_vertex ( v ); g . add_edge ( 'a' , 'c' , 32 ); g . add_edge ( 'a' , 'd' , 2 ); g . add_edge ( 'b' , 'd' , 12 ); g . add_edge ( 'b' , 'c' , 98 ); g . add_edge ( 'c' , 'a' , 1 ); unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } }","title":"Graph Usage"},{"location":"graph/usage/#graphs","text":"The graph is one of the most common and important data structures. With C++ and STL I'll show you the best possible implementation for the graph that you'll be able to implement and analyze in your code at FAANG interviews within the time constraints.","title":" Graphs"},{"location":"graph/usage/#graph-adjacency-list-vs-adjacency-matrix","text":"Most of cases the List representation is good enough, if the graph is sparse then it will take less space, and if the graph is dense you should use the adjacency matrix representation. In my opinion any graph with less than 70% of the all possible edges : \\(\\text{Count(E)} \\geq 0.7 * {n \\choose 2}\\) present can be considered to be implemented as adjacency list.","title":"Graph Adjacency List vs Adjacency Matrix"},{"location":"graph/usage/#c-graph-representation","text":"#include <iostream> #include <list> #include <unordered_map> #include <vector> #include <utility> using namespace std ; // Directed graph implementation class Graph { private : unordered_map < char , list < pair < char , int >>> adj_list ; vector < pair < char , char >> E ; // edge set public : vector < pair < char , char >> edges (){ return E ; } void add_edge ( char vertex1 , char vertex2 , int weight ){ adj_list [ vertex1 ]. push_front ( make_pair ( vertex2 , weight )); E . push_back ({ vertex1 , vertex2 }); } void register_vertex ( vector < char > vertices ){ for ( auto v : vertices ){ list < pair < char , int >> l ; adj_list . insert ({ v , l }); } } unordered_map < char , list < pair < char , int >>> view (){ return adj_list ; } }; The following code shows how to make a graph and use it int main () { Graph g ; vector < char > v = { 'a' , 'b' , 'c' }; g . register_vertex ( v ); g . add_edge ( 'a' , 'c' , 32 ); g . add_edge ( 'a' , 'd' , 2 ); g . add_edge ( 'b' , 'd' , 12 ); g . add_edge ( 'b' , 'c' , 98 ); g . add_edge ( 'c' , 'a' , 1 ); unordered_map < char , list < pair < char , int >>> map = g . view (); for ( auto data : map ){ cout << data . first << \" \" ; for ( auto neighbor : data . second ) cout << \"[\" << neighbor . first << \": \" << neighbor . second << \"]\" ; cout << \" \\n \" ; } // print all the edges auto edges = g . edges (); for ( auto edge : edges ){ cout << edge . first << \"->\" << edge . second << \" \\n \" ; } }","title":"C++  Graph representation"},{"location":"heaps/heap-pq/","text":"Priority Queues and Binary Heaps What are these priority queues? A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm. Identification You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq. STL Usage A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap]. Functions to remember top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container. Recommended use of heaps instead of using STL Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code Things to look out before you start First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time. Heap Build Subroutines There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap. C++ Code #include <iostream> #include <vector> using std :: cout ; using std :: endl ; /** * Interface: MaxHeapify of std::vector vector, and the violation is at atIndex * Only solves a single violation * This is for maintaining the heap property */ void maxHeapify ( std :: vector < int > * vector , int atIndex ){ int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } /** * Build heap procedure. Runs in O(N) time in-place. * Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the * tree and runs MAX-HEAPIFY on each one */ void buildHeap ( std :: vector < int > * vector ){ int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } } Heap Sorting with min heap implementation Using min heap we can get the smallest element in \\(O(\\log n)\\) time. For \\(n\\) elements it will take \\(O(n \\log n)\\) time. This is the best a comparison sort can get. This solution takes no extra memory as the out array is filled one by one and the nums array is reduced one by one in the public sortArray() method. The following buildHeap procedure actually builds the min heap in \\(O(N)\\) time in-place. class Solution { private : int leftChild ( int index ){ return ( index * 2 ) + 1 ; } int rightChild ( int index ){ return ( index * 2 ) + 2 ; } void minHeapify ( vector < int > & nums , int index ){ int smallest = index ; int leftindex = leftChild ( index ); int rightindex = rightChild ( index ); int size = nums . size (); if (( leftindex < size ) && ( nums [ leftindex ] < nums [ smallest ])){ smallest = leftindex ; } if (( rightindex < size ) && ( nums [ rightindex ] < nums [ smallest ])){ smallest = rightindex ; } if ( smallest != index ){ swap ( nums [ smallest ], nums [ index ]); minHeapify ( nums , smallest ); } } void buildHeap ( vector < int > & nums ){ int size = nums . size (); int lastparent = ( size / 2 ) - 1 ; for ( int i = lastparent ; i >= 0 ; i -- ){ minHeapify ( nums , i ); } } public : vector < int > sortArray ( vector < int >& nums ) { vector < int > out ; buildHeap ( nums ); while ( nums . size () != 0 ){ std :: swap ( nums [ 0 ], nums . back ()); out . push_back ( nums . back ()); nums . pop_back (); minHeapify ( nums , 0 ); } return out ; } };","title":"Heaps Introduction, STL"},{"location":"heaps/heap-pq/#priority-queues-and-binary-heaps","text":"","title":" Priority Queues and Binary Heaps"},{"location":"heaps/heap-pq/#what-are-these-priority-queues","text":"A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm.","title":"What are these priority queues?"},{"location":"heaps/heap-pq/#identification","text":"You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq.","title":"Identification"},{"location":"heaps/heap-pq/#stl-usage","text":"A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap].","title":"STL Usage"},{"location":"heaps/heap-pq/#functions-to-remember","text":"top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container.","title":"Functions to remember"},{"location":"heaps/heap-pq/#recommended-use-of-heaps-instead-of-using-stl","text":"Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code","title":"Recommended use of heaps instead of using STL"},{"location":"heaps/heap-pq/#things-to-look-out-before-you-start","text":"First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time.","title":"Things to look out before you start"},{"location":"heaps/heap-pq/#heap-build-subroutines","text":"There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap.","title":"Heap Build Subroutines"},{"location":"heaps/heap-pq/#c-code","text":"#include <iostream> #include <vector> using std :: cout ; using std :: endl ; /** * Interface: MaxHeapify of std::vector vector, and the violation is at atIndex * Only solves a single violation * This is for maintaining the heap property */ void maxHeapify ( std :: vector < int > * vector , int atIndex ){ int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } /** * Build heap procedure. Runs in O(N) time in-place. * Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the * tree and runs MAX-HEAPIFY on each one */ void buildHeap ( std :: vector < int > * vector ){ int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } }","title":"C++ Code"},{"location":"heaps/heap-pq/#heap-sorting-with-min-heap-implementation","text":"Using min heap we can get the smallest element in \\(O(\\log n)\\) time. For \\(n\\) elements it will take \\(O(n \\log n)\\) time. This is the best a comparison sort can get. This solution takes no extra memory as the out array is filled one by one and the nums array is reduced one by one in the public sortArray() method. The following buildHeap procedure actually builds the min heap in \\(O(N)\\) time in-place. class Solution { private : int leftChild ( int index ){ return ( index * 2 ) + 1 ; } int rightChild ( int index ){ return ( index * 2 ) + 2 ; } void minHeapify ( vector < int > & nums , int index ){ int smallest = index ; int leftindex = leftChild ( index ); int rightindex = rightChild ( index ); int size = nums . size (); if (( leftindex < size ) && ( nums [ leftindex ] < nums [ smallest ])){ smallest = leftindex ; } if (( rightindex < size ) && ( nums [ rightindex ] < nums [ smallest ])){ smallest = rightindex ; } if ( smallest != index ){ swap ( nums [ smallest ], nums [ index ]); minHeapify ( nums , smallest ); } } void buildHeap ( vector < int > & nums ){ int size = nums . size (); int lastparent = ( size / 2 ) - 1 ; for ( int i = lastparent ; i >= 0 ; i -- ){ minHeapify ( nums , i ); } } public : vector < int > sortArray ( vector < int >& nums ) { vector < int > out ; buildHeap ( nums ); while ( nums . size () != 0 ){ std :: swap ( nums [ 0 ], nums . back ()); out . push_back ( nums . back ()); nums . pop_back (); minHeapify ( nums , 0 ); } return out ; } };","title":"Heap Sorting with min heap implementation"},{"location":"heaps/problems/","text":"Heap Problems Kth Largest Element in an Array (Medium) Problem Statement Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Examples Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints \\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\) Approach There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k-1th largest will be removed minHeap . pop (); } } return minHeap . top (); } }; K Largest Elements in the array Problem Statement This problem is a bit different than the previous one. Here you have to return K largest elements from a given sequence. For example flowchart LR 10-->12 12-->13 13-->167 167-->46 46-->2157 For the above sequence the \\(K = 3\\) largest elements should be the following: flowchart LR 2157-->167-->46 Approach From the above code if we look closely enough, we find that after all the operations done the remaining elements in the k sized heap contains all the elements that are greater or equal to the \\(K^{\\text{th}}\\) largest element in the given sequence. So return all the elements from the heap. C++ Code std :: vector < int > kLargestElements ( std :: vector < int > & vector , int k ){ std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; for ( auto element : vector ){ if ( minHeap . size () != k ){ minHeap . push ( element ); } else { minHeap . push ( element ); minHeap . pop (); } } while ( ! minHeap . empty ()){ out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; } Sort a K Sorted array Problem Statement Each element in the array must be within the range k from it's desired position, Now sort the array as efficiently as possible. Approach For each index, the corresponding sorted element is in the array is within k to the left and k to the right of that index. Now we make a min-heap of size k+1, Now we push first k+1 elements into the heap. Now for each index extract the min, then slide the window by 1 distance adding the \\((k+1) + 1^{th}\\) element to the heap and remove the min element from the min heap. In the next step do the same with \\((k+1) + 2^{th}\\) element, unitl this pointer reaches to the end. At the end extract the remaining min elements from the heap and add it to the out vector. #include <iostream> #include <queue> #include <vector> /* \ud83d\uddff Implementation for sorting a k sorted array using heap \ud83d\uddff \ud83d\uddff Input is given a k sorted array [\ud83d\uddff pass by address \ud83d\uddff] \ud83d\uddff returns the sorted array. */ std :: vector < int > kSortedArray ( std :: vector < int > & array , int k ) { int size = array . size (); int index = 0 ; std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; // initially push k element into the min heap int nextuptoK = k + 1 ; while ( nextuptoK ) { minHeap . push ( array [ nextuptoK ]); nextuptoK -- ; } // Now move forward with the array and put one new element into the min heap and // pop last element from the min heap [the minimum]. This popped element is the minimum element // so put it into the out vector. int window_last = k + 2 ; while ( window_last != size ) { out . push_back ( minHeap . top ()); minHeap . pop (); minHeap . push ( array [ window_last ]); window_last ++ ; } while ( ! minHeap . empty ()) { out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; } Find K Closest Elements (Medium) Problem Statement Given a sorted integer array arr , two integers k and x , return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: |a - x| < |b - x| |a - x| == |b - x| and a < b Examples Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] Input: arr = [1,2,3,4,5], k = 4, x = -1 Output: [1,2,3,4] Approach One approach could be that we subtract x from each element of the array and return whose difference with \\(x\\) is in \\(\\{0 \\to k\\}\\) Other approach would be to use a heap. Like the previous problem we pushed K largest or smallest elements into the array. Here what we'll do is Make a minHeap, Top K Frequent Elements (Medium) Problem Statement Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Examples Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] Constraints 1 <= nums.length <= 10 5 k is in the range [1, the number of unique elements in the array] . It is guaranteed that the answer is unique . Follow up: The algorithm's time complexity must be better than \\(O(n \\log n)\\) , where n is the array's size. Approach Code","title":"Heap Problems"},{"location":"heaps/problems/#heap-problems","text":"","title":" Heap Problems"},{"location":"heaps/problems/#kth-largest-element-in-an-array-medium","text":"","title":"Kth Largest Element in an Array (Medium)"},{"location":"heaps/problems/#problem-statement","text":"Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.","title":"Problem Statement"},{"location":"heaps/problems/#examples","text":"Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4","title":"Examples"},{"location":"heaps/problems/#constraints","text":"\\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\)","title":"Constraints"},{"location":"heaps/problems/#approach","text":"There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k-1th largest will be removed minHeap . pop (); } } return minHeap . top (); } };","title":"Approach"},{"location":"heaps/problems/#k-largest-elements-in-the-array","text":"","title":"K Largest Elements in the array"},{"location":"heaps/problems/#problem-statement_1","text":"This problem is a bit different than the previous one. Here you have to return K largest elements from a given sequence. For example flowchart LR 10-->12 12-->13 13-->167 167-->46 46-->2157 For the above sequence the \\(K = 3\\) largest elements should be the following: flowchart LR 2157-->167-->46","title":"Problem Statement"},{"location":"heaps/problems/#approach_1","text":"From the above code if we look closely enough, we find that after all the operations done the remaining elements in the k sized heap contains all the elements that are greater or equal to the \\(K^{\\text{th}}\\) largest element in the given sequence. So return all the elements from the heap.","title":"Approach"},{"location":"heaps/problems/#c-code","text":"std :: vector < int > kLargestElements ( std :: vector < int > & vector , int k ){ std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; for ( auto element : vector ){ if ( minHeap . size () != k ){ minHeap . push ( element ); } else { minHeap . push ( element ); minHeap . pop (); } } while ( ! minHeap . empty ()){ out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; }","title":"C++ Code"},{"location":"heaps/problems/#sort-a-k-sorted-array","text":"","title":"Sort a K Sorted array"},{"location":"heaps/problems/#problem-statement_2","text":"Each element in the array must be within the range k from it's desired position, Now sort the array as efficiently as possible.","title":"Problem Statement"},{"location":"heaps/problems/#approach_2","text":"For each index, the corresponding sorted element is in the array is within k to the left and k to the right of that index. Now we make a min-heap of size k+1, Now we push first k+1 elements into the heap. Now for each index extract the min, then slide the window by 1 distance adding the \\((k+1) + 1^{th}\\) element to the heap and remove the min element from the min heap. In the next step do the same with \\((k+1) + 2^{th}\\) element, unitl this pointer reaches to the end. At the end extract the remaining min elements from the heap and add it to the out vector. #include <iostream> #include <queue> #include <vector> /* \ud83d\uddff Implementation for sorting a k sorted array using heap \ud83d\uddff \ud83d\uddff Input is given a k sorted array [\ud83d\uddff pass by address \ud83d\uddff] \ud83d\uddff returns the sorted array. */ std :: vector < int > kSortedArray ( std :: vector < int > & array , int k ) { int size = array . size (); int index = 0 ; std :: priority_queue < int , std :: vector < int > , std :: greater < int >> minHeap ; std :: vector < int > out ; // initially push k element into the min heap int nextuptoK = k + 1 ; while ( nextuptoK ) { minHeap . push ( array [ nextuptoK ]); nextuptoK -- ; } // Now move forward with the array and put one new element into the min heap and // pop last element from the min heap [the minimum]. This popped element is the minimum element // so put it into the out vector. int window_last = k + 2 ; while ( window_last != size ) { out . push_back ( minHeap . top ()); minHeap . pop (); minHeap . push ( array [ window_last ]); window_last ++ ; } while ( ! minHeap . empty ()) { out . push_back ( minHeap . top ()); minHeap . pop (); } return out ; }","title":"Approach"},{"location":"heaps/problems/#find-k-closest-elements-medium","text":"","title":"Find K Closest Elements (Medium)"},{"location":"heaps/problems/#problem-statement_3","text":"Given a sorted integer array arr , two integers k and x , return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: |a - x| < |b - x| |a - x| == |b - x| and a < b","title":"Problem Statement"},{"location":"heaps/problems/#examples_1","text":"Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] Input: arr = [1,2,3,4,5], k = 4, x = -1 Output: [1,2,3,4]","title":"Examples"},{"location":"heaps/problems/#approach_3","text":"One approach could be that we subtract x from each element of the array and return whose difference with \\(x\\) is in \\(\\{0 \\to k\\}\\) Other approach would be to use a heap. Like the previous problem we pushed K largest or smallest elements into the array. Here what we'll do is Make a minHeap,","title":"Approach"},{"location":"heaps/problems/#top-k-frequent-elements-medium","text":"","title":"Top K Frequent Elements (Medium)"},{"location":"heaps/problems/#problem-statement_4","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.","title":"Problem Statement"},{"location":"heaps/problems/#examples_2","text":"Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]","title":"Examples"},{"location":"heaps/problems/#constraints_1","text":"1 <= nums.length <= 10 5 k is in the range [1, the number of unique elements in the array] . It is guaranteed that the answer is unique . Follow up: The algorithm's time complexity must be better than \\(O(n \\log n)\\) , where n is the array's size.","title":"Constraints"},{"location":"heaps/problems/#approach_4","text":"","title":"Approach"},{"location":"heaps/problems/#code","text":"","title":"Code"},{"location":"recursion/intro/","text":"Introduction to recursion Recursion is when a [function] calls itself until some condition is met. Following things we need to understand very clearly before proceeding with recursion What is this making problem space smaller idea? We are not specifically looking for to reduce the problem space, instead we'll be making some decisions that will reduce the problem space. Reduction of problem space is a by-product of the decisions that we'll be making in a specific stage of the algorithm. For recursive function calls a new stack space is created and the function will have no memory of what were the variables in the previous function call. To avoid this we use parameterized recursive calls. Note static is just a global variable with visibility limited to one function. So if you declare it static , there is exactly one variable shared by all the levels of recursion. Without static , the variable is local, which means each function invocation has its own copy of variable's state. Easier Recursion problems Print some useful information 10 times Following is the code for printing \"something useful\" 10 times with recursion, Approach Static and global variables are stored in heap which is shared across all function calls. So we'll store a counter inside the heap to keep track of the counter across all function calls. void print (){ static int count = 10 ; if ( count != 0 ){ cout << \"Something \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; } Similarly print 1 to 10 using recursive calls void print (){ static int count = 10 ; if ( count != 0 ){ cout << count << \" \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; } Functional apporach In this apporach we will think of the problem [solution] as a recursion tree and the function calls to a smaller problem. Example: Sum of first N numbers int sumOfFirstNNumbers ( int startFrom , int UpTo ){ if ( startFrom <= UpTo ){ sum = startFrom + sumOfFirstNNumbers ( startFrom + 1 , UpTo ); } return sum ; } // OR int sumOfFirstNNumbers_2 ( int N ){ if ( N == 0 ) return 0 ; return N + sumOfFirstNNumbers_static ( N - 1 ); } int main () { std :: cout << sumOfFirstNNumbers ( 1 , 4 ); } Stepwise recursive calls for this apporach. Other approaches Using a static variable that is shared accross multiple function calls also works. int sumOfFirstNNumbers_static ( int N ){ static int sum = 0 ; // THIS is the ACCUMULATOR if ( N == 0 ) return 0 ; sum += N ; // Accumulate the \"N\"s into the SUM. sumOfFirstNNumbers_static ( N - 1 ); return sum ; } Reverse an array of numbers using recursive calls only Approach : Add n th element and recursively call the function from 1 to \\(n-1\\) , and add \\(n-1^{th}\\) elements to the answer array, again recursively call the function until we reach \\(0^{th}\\) element. std :: vector < int > reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only static std :: vector < int > ans ; if ( to != -1 ){ ans . push_back ( arr [ to ]); reverse ( arr , from , to -1 ); } return ans ; } We can also modify the original to avoid extra spaces. We can swap the last and first elements until first pointer crosses last pointer. The following is \\(O(N)\\) auxiliary space solution. Code void reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only if ( from <= to ){ std :: swap ( arr [ from ], arr [ to ]); reverse ( arr , from + 1 , to -1 ); } } Find all the sub-sequences that sums up to K. Problem Statement You'll be given a sequence and with recursive calls find out all the sub-sequences that sum up to K. Approach First we can either take or not take one element of the sequence, each time we'll check if the number is taken the sum is greater than the required or not, If greater we stop and return else we include it and check if the sum is equal to K? If equal we simply print the sequence. Code #include <iostream> #include <vector> using std :: cout ; using std :: endl ; void solver ( std :: vector < int > & v , int index , int k , int sum ){ // sub-seq whose sum is K from the given sequence V // shared across all recursive calls static std :: vector < int > b ; if ( index > v . size () - 1 ) return ; if ( sum < k ){ // try with the current value b . push_back ( v [ index ]); sum = sum + v [ index ]; solver ( v , index + 1 , k , sum ); // again try without the current value b . pop_back (); sum = sum - v [ index ]; solver ( v , index + 1 , k , sum ); } if ( sum == k ){ for ( auto i : b ){ cout << i << \" \" ; } cout << endl ; } }","title":"Recursion Introduction"},{"location":"recursion/intro/#introduction-to-recursion","text":"Recursion is when a [function] calls itself until some condition is met. Following things we need to understand very clearly before proceeding with recursion","title":" Introduction to recursion"},{"location":"recursion/intro/#what-is-this-making-problem-space-smaller-idea","text":"We are not specifically looking for to reduce the problem space, instead we'll be making some decisions that will reduce the problem space. Reduction of problem space is a by-product of the decisions that we'll be making in a specific stage of the algorithm. For recursive function calls a new stack space is created and the function will have no memory of what were the variables in the previous function call. To avoid this we use parameterized recursive calls. Note static is just a global variable with visibility limited to one function. So if you declare it static , there is exactly one variable shared by all the levels of recursion. Without static , the variable is local, which means each function invocation has its own copy of variable's state.","title":"What is this making problem space smaller idea?"},{"location":"recursion/intro/#easier-recursion-problems","text":"","title":"Easier Recursion problems"},{"location":"recursion/intro/#print-some-useful-information-10-times","text":"Following is the code for printing \"something useful\" 10 times with recursion,","title":"Print some useful information 10 times"},{"location":"recursion/intro/#approach","text":"Static and global variables are stored in heap which is shared across all function calls. So we'll store a counter inside the heap to keep track of the counter across all function calls. void print (){ static int count = 10 ; if ( count != 0 ){ cout << \"Something \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; }","title":"Approach"},{"location":"recursion/intro/#similarly-print-1-to-10-using-recursive-calls","text":"void print (){ static int count = 10 ; if ( count != 0 ){ cout << count << \" \\n \" ; count -- ; print (); } else { return ; } } int main () { print (); return 0 ; }","title":"Similarly print 1 to 10 using recursive calls"},{"location":"recursion/intro/#functional-apporach","text":"In this apporach we will think of the problem [solution] as a recursion tree and the function calls to a smaller problem.","title":"Functional apporach"},{"location":"recursion/intro/#example-sum-of-first-n-numbers","text":"int sumOfFirstNNumbers ( int startFrom , int UpTo ){ if ( startFrom <= UpTo ){ sum = startFrom + sumOfFirstNNumbers ( startFrom + 1 , UpTo ); } return sum ; } // OR int sumOfFirstNNumbers_2 ( int N ){ if ( N == 0 ) return 0 ; return N + sumOfFirstNNumbers_static ( N - 1 ); } int main () { std :: cout << sumOfFirstNNumbers ( 1 , 4 ); } Stepwise recursive calls for this apporach.","title":"Example: Sum of first N numbers"},{"location":"recursion/intro/#other-approaches","text":"Using a static variable that is shared accross multiple function calls also works. int sumOfFirstNNumbers_static ( int N ){ static int sum = 0 ; // THIS is the ACCUMULATOR if ( N == 0 ) return 0 ; sum += N ; // Accumulate the \"N\"s into the SUM. sumOfFirstNNumbers_static ( N - 1 ); return sum ; }","title":"Other approaches"},{"location":"recursion/intro/#reverse-an-array-of-numbers-using-recursive-calls-only","text":"Approach : Add n th element and recursively call the function from 1 to \\(n-1\\) , and add \\(n-1^{th}\\) elements to the answer array, again recursively call the function until we reach \\(0^{th}\\) element. std :: vector < int > reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only static std :: vector < int > ans ; if ( to != -1 ){ ans . push_back ( arr [ to ]); reverse ( arr , from , to -1 ); } return ans ; } We can also modify the original to avoid extra spaces. We can swap the last and first elements until first pointer crosses last pointer. The following is \\(O(N)\\) auxiliary space solution.","title":"Reverse an array of numbers using recursive calls only"},{"location":"recursion/intro/#code","text":"void reverse ( std :: vector < int > & arr , int from , int to ){ // reverse using recursion only if ( from <= to ){ std :: swap ( arr [ from ], arr [ to ]); reverse ( arr , from + 1 , to -1 ); } }","title":"Code"},{"location":"recursion/intro/#find-all-the-sub-sequences-that-sums-up-to-k","text":"","title":"Find all the sub-sequences that sums up to K."},{"location":"recursion/intro/#problem-statement","text":"You'll be given a sequence and with recursive calls find out all the sub-sequences that sum up to K.","title":"Problem Statement"},{"location":"recursion/intro/#approach_1","text":"First we can either take or not take one element of the sequence, each time we'll check if the number is taken the sum is greater than the required or not, If greater we stop and return else we include it and check if the sum is equal to K? If equal we simply print the sequence.","title":"Approach"},{"location":"recursion/intro/#code_1","text":"#include <iostream> #include <vector> using std :: cout ; using std :: endl ; void solver ( std :: vector < int > & v , int index , int k , int sum ){ // sub-seq whose sum is K from the given sequence V // shared across all recursive calls static std :: vector < int > b ; if ( index > v . size () - 1 ) return ; if ( sum < k ){ // try with the current value b . push_back ( v [ index ]); sum = sum + v [ index ]; solver ( v , index + 1 , k , sum ); // again try without the current value b . pop_back (); sum = sum - v [ index ]; solver ( v , index + 1 , k , sum ); } if ( sum == k ){ for ( auto i : b ){ cout << i << \" \" ; } cout << endl ; } }","title":"Code"},{"location":"recursion/problems/","text":"Recursion, Backtracking and Subset Problems These pattern of questions include subset formation, backtracking and recursive calls. Almost all of the questions are leetcode medium level questions. Solving these following problems will help people gain a better understanding of Backtracking, Recursion calls, Subset pattern of questions. Find all the subsets Problem on Leetcode \\(\\to\\) Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Approach With basic recursive approach, we first include an element and don't include an element. This is how we can generate all the unique subsets from a given set. We push the subset to the answer only at the last step of the recursion tree when the index reaches to the last element. Code class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& v , int index ) { static vector < int > b ; if ( index > v . size () - 1 ) { // Push the subset only at the last step of the recursion tree vector < int > c ( b ); // create a copy of b and add it into answer answer . push_back ( c ); return ; } // with the element b . push_back ( v [ index ]); recurse ( v , index + 1 ); // without the current element b . pop_back (); recurse ( v , index + 1 ); } public : vector < vector < int >> subsets ( vector < int >& nums ) { recurse ( nums , 0 ); return answer ; } }; Subsets II Subsets II is a little bit different, given an integer array nums that may contain duplicates , return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Approach The approach should be similar to the subset approach, now in order to avoid duplicates in the power set what we can do is the following We can first sort the input array then skip duplicates while traversing through the array in the recursive calls by instead of skipping 1 index, skip multiple indexes until we can't find a new value. This specific modification helps us avoid duplicates while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } Now we can avoid duplicates in the power set. Code class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& nums , int index ){ static vector < int > b ; if ( index >= nums . size ()) { // at the end of tree vector < int > c ( b ); answer . push_back ( c ); return ; } b . push_back ( nums [ index ]); recurse ( nums , index + 1 ); b . pop_back (); while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } recurse ( nums , index + 1 ); } public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); recurse ( nums , 0 ); return answer ; } }; Combination Sum Problem on Leetcode \\(\\to\\) Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Examples Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Input: candidates = [2], target = 1 Output: [] Constraints: \\(1 \\leq\\) candidates.length \\(\\leq 30\\) \\(1 \\leq\\) <= candidates[i] \\(\\leq 200\\) All elements of candidates are distinct. \\(1 \\leq\\) target \\(\\leq 500\\) Approach We'll create a recursive subroutine called recurse which will recursively find all the sub-sequences that sums up to target Recall a similar problem in the intro section where we solved Find all the sub-sequences that sums up to K. But here the problem is little different, here one element can be added multiple times. So we create a modification in the first recursive call: recurse(candidates, target, sum, index); . In this case we are again calling with the same index so that we can check if multiple times we can add the same element. For the case where we are not considering a particular element [as] we are not considering a particular element, we'll simply call the recursive call recurse(candidates, target, sum, index + 1; with \\(\\text{Index} + 1\\) . Code class Solution { public : vector < vector < int >> answer ; void recurse ( vector < int > & candidates , int target , int sum , int index ) { static vector < int > b ; // shared data structure if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { // check with the current index b . push_back ( candidates [ index ]); sum = sum + candidates [ index ]; recurse ( candidates , target , sum , index ); // can take the same index multiple times // remove the current index and check again b . pop_back (); sum = sum - candidates [ index ]; recurse ( candidates , target , sum , index + 1 ); // index+1 bcz we are no longer interested with that index } if ( sum == target ) { vector < int > bk ( b ); answer . push_back ( bk ); } } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { recurse ( candidates , target , 0 , 0 ); return answer ; } }; Combination Sum III Find the problem on Leetcode \\(\\to\\) This is a slight modification of the previous problem, find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.","title":"Recursion, Backtracking, Subset Pattern"},{"location":"recursion/problems/#recursion-backtracking-and-subset-problems","text":"These pattern of questions include subset formation, backtracking and recursive calls. Almost all of the questions are leetcode medium level questions. Solving these following problems will help people gain a better understanding of Backtracking, Recursion calls, Subset pattern of questions.","title":" Recursion, Backtracking and Subset Problems"},{"location":"recursion/problems/#find-all-the-subsets","text":"Problem on Leetcode \\(\\to\\) Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.","title":"Find all the subsets"},{"location":"recursion/problems/#approach","text":"With basic recursive approach, we first include an element and don't include an element. This is how we can generate all the unique subsets from a given set. We push the subset to the answer only at the last step of the recursion tree when the index reaches to the last element.","title":"Approach"},{"location":"recursion/problems/#code","text":"class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& v , int index ) { static vector < int > b ; if ( index > v . size () - 1 ) { // Push the subset only at the last step of the recursion tree vector < int > c ( b ); // create a copy of b and add it into answer answer . push_back ( c ); return ; } // with the element b . push_back ( v [ index ]); recurse ( v , index + 1 ); // without the current element b . pop_back (); recurse ( v , index + 1 ); } public : vector < vector < int >> subsets ( vector < int >& nums ) { recurse ( nums , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#subsets-ii","text":"Subsets II is a little bit different, given an integer array nums that may contain duplicates , return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.","title":"Subsets II"},{"location":"recursion/problems/#approach_1","text":"The approach should be similar to the subset approach, now in order to avoid duplicates in the power set what we can do is the following We can first sort the input array then skip duplicates while traversing through the array in the recursive calls by instead of skipping 1 index, skip multiple indexes until we can't find a new value. This specific modification helps us avoid duplicates while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } Now we can avoid duplicates in the power set.","title":"Approach"},{"location":"recursion/problems/#code_1","text":"class Solution { private : vector < vector < int >> answer ; void recurse ( vector < int >& nums , int index ){ static vector < int > b ; if ( index >= nums . size ()) { // at the end of tree vector < int > c ( b ); answer . push_back ( c ); return ; } b . push_back ( nums [ index ]); recurse ( nums , index + 1 ); b . pop_back (); while ( index < nums . size () - 1 and nums [ index ] == nums [ index + 1 ]){ index ++ ; } recurse ( nums , index + 1 ); } public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { std :: sort ( nums . begin (), nums . end ()); recurse ( nums , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#combination-sum","text":"Problem on Leetcode \\(\\to\\) Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.","title":"Combination Sum"},{"location":"recursion/problems/#examples","text":"Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Input: candidates = [2], target = 1 Output: []","title":"Examples"},{"location":"recursion/problems/#constraints","text":"\\(1 \\leq\\) candidates.length \\(\\leq 30\\) \\(1 \\leq\\) <= candidates[i] \\(\\leq 200\\) All elements of candidates are distinct. \\(1 \\leq\\) target \\(\\leq 500\\)","title":"Constraints:"},{"location":"recursion/problems/#approach_2","text":"We'll create a recursive subroutine called recurse which will recursively find all the sub-sequences that sums up to target Recall a similar problem in the intro section where we solved Find all the sub-sequences that sums up to K. But here the problem is little different, here one element can be added multiple times. So we create a modification in the first recursive call: recurse(candidates, target, sum, index); . In this case we are again calling with the same index so that we can check if multiple times we can add the same element. For the case where we are not considering a particular element [as] we are not considering a particular element, we'll simply call the recursive call recurse(candidates, target, sum, index + 1; with \\(\\text{Index} + 1\\) .","title":"Approach"},{"location":"recursion/problems/#code_2","text":"class Solution { public : vector < vector < int >> answer ; void recurse ( vector < int > & candidates , int target , int sum , int index ) { static vector < int > b ; // shared data structure if ( index > candidates . size () - 1 ) return ; if ( sum < target ) { // check with the current index b . push_back ( candidates [ index ]); sum = sum + candidates [ index ]; recurse ( candidates , target , sum , index ); // can take the same index multiple times // remove the current index and check again b . pop_back (); sum = sum - candidates [ index ]; recurse ( candidates , target , sum , index + 1 ); // index+1 bcz we are no longer interested with that index } if ( sum == target ) { vector < int > bk ( b ); answer . push_back ( bk ); } } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { recurse ( candidates , target , 0 , 0 ); return answer ; } };","title":"Code"},{"location":"recursion/problems/#combination-sum-iii","text":"Find the problem on Leetcode \\(\\to\\) This is a slight modification of the previous problem, find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.","title":"Combination Sum III"},{"location":"stacks/problems/","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"],"text":"Stack Problems Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution. Nearest greater to right or Next Largest Element Problem statement Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1 Brute Force approach Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None Optimized solution with Stacks Stack implementation from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0 Optimized apporach with stacks We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ])) Nearest greater to left (NGEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1 Approach Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1] Nearest smaller to left (NSEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2 Approach Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1] Minimum Stack with extra space Problem Statement Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called. Constraints \\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop. Approach We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } }; Time Complexity push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\) Space Complexity At the very worst total space complexity is \\(\\mathcal{O}(N)\\) Stock Span Problem Problem Statement Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day. Example testcase For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\) Approach If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; } Time Complexity At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() . Space Complexity Space complexity is \\(O(\\mathcal{N})\\) . Maximum Area Histogram Problem Statement Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram. Examples Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Thought process Brainstorm! Approach Proper Approach! Time and Space complexity \\(O(\\mathcal{N})\\) time and space is taken. Code Subroutines Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right. NSR (NSE, Nearest smaller to the Right) implementation #include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; } NSEle (Nearest smaller to the left) implementation vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; } The main function maxAreaHistogram() void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; } Testing the code out int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; } Output TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10 Max Area Rectangle under binary matrix Problem On leetcode \\(\\to\\) Problem Statement Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Constraints: rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) . Approach Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels. Rain water trapping Same Problem on Leetcode \\(\\to\\) Problem Statement Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining. Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Explainer Rain Water Trapping Explainer Approach For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer Solution For each building find the maximum height on both left and right sides [using heaps], then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system. The Skyline problem Same Problem on Leetcode \\(\\to\\) Problem Statement A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. Score of Parentheses Problem on leetcode \\(\\to\\) Problem Statement Given a balanced parentheses string s, return the score of the string - \"()\" has score 1, - AB has score A + B, where A and B are balanced parentheses strings, - (A) has score 2 * A, where A is a balanced parentheses string. Examples Input: s = \"()\" Output: 1 Input: s = \"(())\" Output: 2 Input: s = \"()()\" Output: 2 Constraints \\(2\\) <= s.length <= \\(50\\) s consists of only '(' and ')' . s is always a balanced parentheses string. Approach Using recursion because seems like a recursive problem with pattern of return (what is inside of(what is inside of (what is inside))) . C++ code class Solution { private : int globalTracker = 0 ; public : int scoreOfParentheses ( string s ) { int score = 0 ; // Using recursion bcz seems like a recursive problem // return (what is inside of(what is inside of (what is inside))) while ( globalTracker < s . size () - 1 ){ char first = s . at ( globalTracker ); globalTracker ++ ; char second = s . at ( globalTracker ); if ( first == '(' ){ if ( second == ')' ){ score = score + 1 ; globalTracker ++ ; } else { score = score + 2 * ( scoreOfParentheses ( s )); } } else { return score ; } } return score ; } };","title":"Stack Problems"},{"location":"stacks/problems/#stack-problems","text":"Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution.","title":" Stack Problems"},{"location":"stacks/problems/#nearest-greater-to-right-or-next-largest-element","text":"","title":"Nearest greater to right or Next Largest Element"},{"location":"stacks/problems/#problem-statement","text":"Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples","text":"Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1","title":"Examples"},{"location":"stacks/problems/#brute-force-approach","text":"Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None","title":"Brute Force approach"},{"location":"stacks/problems/#optimized-solution-with-stacks","text":"","title":"Optimized solution with Stacks"},{"location":"stacks/problems/#stack-implementation","text":"from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0","title":"Stack implementation"},{"location":"stacks/problems/#optimized-apporach-with-stacks","text":"We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ]))","title":"Optimized apporach with stacks"},{"location":"stacks/problems/#nearest-greater-to-left-ngele","text":"","title":"Nearest greater to left (NGEle)"},{"location":"stacks/problems/#problem-statement_1","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_1","text":"Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1","title":"Examples"},{"location":"stacks/problems/#approach","text":"Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#nearest-smaller-to-left-nsele","text":"","title":"Nearest smaller to left (NSEle)"},{"location":"stacks/problems/#problem-statement_2","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_2","text":"Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2","title":"Examples"},{"location":"stacks/problems/#approach_1","text":"Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#minimum-stack-with-extra-space","text":"","title":"Minimum Stack with extra space"},{"location":"stacks/problems/#problem-statement_3","text":"Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called.","title":"Problem Statement"},{"location":"stacks/problems/#constraints","text":"\\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop.","title":"Constraints"},{"location":"stacks/problems/#approach_2","text":"We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Approach"},{"location":"stacks/problems/#time-complexity","text":"push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\)","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity","text":"At the very worst total space complexity is \\(\\mathcal{O}(N)\\)","title":"Space Complexity"},{"location":"stacks/problems/#stock-span-problem","text":"","title":"Stock Span Problem"},{"location":"stacks/problems/#problem-statement_4","text":"Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day.","title":"Problem Statement"},{"location":"stacks/problems/#example-testcase","text":"For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\)","title":"Example testcase"},{"location":"stacks/problems/#approach_3","text":"If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; }","title":"Approach"},{"location":"stacks/problems/#time-complexity_1","text":"At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() .","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity_1","text":"Space complexity is \\(O(\\mathcal{N})\\) .","title":"Space Complexity"},{"location":"stacks/problems/#maximum-area-histogram","text":"","title":"Maximum Area Histogram"},{"location":"stacks/problems/#problem-statement_5","text":"Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram.","title":"Problem Statement"},{"location":"stacks/problems/#examples_3","text":"Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.","title":"Examples"},{"location":"stacks/problems/#thought-process","text":"Brainstorm!","title":"Thought process"},{"location":"stacks/problems/#approach_4","text":"Proper Approach!","title":"Approach"},{"location":"stacks/problems/#time-and-space-complexity","text":"\\(O(\\mathcal{N})\\) time and space is taken.","title":"Time and Space complexity"},{"location":"stacks/problems/#code","text":"","title":"Code"},{"location":"stacks/problems/#subroutines","text":"Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right.","title":"Subroutines"},{"location":"stacks/problems/#nsr-nse-nearest-smaller-to-the-right-implementation","text":"#include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; }","title":"NSR (NSE, Nearest smaller to the Right) implementation"},{"location":"stacks/problems/#nsele-nearest-smaller-to-the-left-implementation","text":"vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; }","title":"NSEle (Nearest smaller to the left) implementation"},{"location":"stacks/problems/#the-main-function-maxareahistogram","text":"void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; }","title":"The main function maxAreaHistogram()"},{"location":"stacks/problems/#testing-the-code-out","text":"int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; }","title":"Testing the code out"},{"location":"stacks/problems/#output","text":"TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10","title":"Output"},{"location":"stacks/problems/#max-area-rectangle-under-binary-matrix","text":"Problem On leetcode \\(\\to\\)","title":"Max Area Rectangle under binary matrix"},{"location":"stacks/problems/#problem-statement_6","text":"Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture.","title":"Problem Statement"},{"location":"stacks/problems/#constraints_1","text":"rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) .","title":"Constraints:"},{"location":"stacks/problems/#approach_5","text":"Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels.","title":"Approach"},{"location":"stacks/problems/#rain-water-trapping","text":"Same Problem on Leetcode \\(\\to\\)","title":"Rain water trapping"},{"location":"stacks/problems/#problem-statement_7","text":"Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining.","title":"Problem Statement"},{"location":"stacks/problems/#example","text":"Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.","title":"Example"},{"location":"stacks/problems/#explainer","text":"Rain Water Trapping Explainer","title":"Explainer"},{"location":"stacks/problems/#approach_6","text":"For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer","title":"Approach"},{"location":"stacks/problems/#solution","text":"For each building find the maximum height on both left and right sides [using heaps], then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system.","title":"Solution"},{"location":"stacks/problems/#the-skyline-problem","text":"Same Problem on Leetcode \\(\\to\\)","title":"The Skyline problem"},{"location":"stacks/problems/#problem-statement_8","text":"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.","title":"Problem Statement"},{"location":"stacks/problems/#score-of-parentheses","text":"Problem on leetcode \\(\\to\\)","title":"Score of Parentheses"},{"location":"stacks/problems/#problem-statement_9","text":"Given a balanced parentheses string s, return the score of the string - \"()\" has score 1, - AB has score A + B, where A and B are balanced parentheses strings, - (A) has score 2 * A, where A is a balanced parentheses string.","title":"Problem Statement"},{"location":"stacks/problems/#examples_4","text":"Input: s = \"()\" Output: 1 Input: s = \"(())\" Output: 2 Input: s = \"()()\" Output: 2","title":"Examples"},{"location":"stacks/problems/#constraints_2","text":"\\(2\\) <= s.length <= \\(50\\) s consists of only '(' and ')' . s is always a balanced parentheses string.","title":"Constraints"},{"location":"stacks/problems/#approach_7","text":"Using recursion because seems like a recursive problem with pattern of return (what is inside of(what is inside of (what is inside))) .","title":"Approach"},{"location":"stacks/problems/#c-code","text":"class Solution { private : int globalTracker = 0 ; public : int scoreOfParentheses ( string s ) { int score = 0 ; // Using recursion bcz seems like a recursive problem // return (what is inside of(what is inside of (what is inside))) while ( globalTracker < s . size () - 1 ){ char first = s . at ( globalTracker ); globalTracker ++ ; char second = s . at ( globalTracker ); if ( first == '(' ){ if ( second == ')' ){ score = score + 1 ; globalTracker ++ ; } else { score = score + 2 * ( scoreOfParentheses ( s )); } } else { return score ; } } return score ; } };","title":"C++ code"},{"location":"stacks/usage/","text":"Implementation of Stacks and Queues A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes. Source Code from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ]) Stacks implementation with Deque Module class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \" Stacks implementation with C++ With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks Usage"},{"location":"stacks/usage/#implementation-of-stacks-and-queues","text":"A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes.","title":" Implementation of Stacks and Queues"},{"location":"stacks/usage/#source-code","text":"from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ])","title":"Source Code"},{"location":"stacks/usage/#stacks-implementation-with-deque-module","text":"class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \"","title":"Stacks implementation with Deque Module"},{"location":"stacks/usage/#stacks-implementation-with-c","text":"With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks implementation with C++"},{"location":"trees/implementation/","text":"Tree implementation Tree is a non linear graph data structure which has no cycle. Tree is hiararchical data structure, any sort of data that has some sort of hiararchy we can use a tree to represent, get, delete efficiently. Tree Standard struct STL don't have general binary tree representation [has red black tree (height balanced binary search tree)]. The following struct can be used to represent a tree structure. struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; // Create a Tree Structure int main () { TreeNode * root = new TreeNode ( 12 ); root -> left = new TreeNode ( 112 ); root -> right = new TreeNode ( 44 ); } Visual representation of the structure : graph TD subgraph After Inserstions 12((12)) --> 44((44)) & 112((112)) 112 --> aa[null_ptr] & bb[null_ptr] 44 --> aaa[null_ptr] & bbb[null_ptr] end subgraph At the start A((12)) --> b[null_ptr] & c[null_ptr] end Tree from input stream Now for some cases you may have to take input from a stream of numbers and create a tree structure from them. Here is a detailed implementation on how to do that. First we create a character array and put the entire stream into that character array, // Get complete binray tree input from a stream char a [ 1000 ]; cin . getline ( a , 1000 ); Now we create a vector and we'll tokenize the character array and get all the numbers from them into the vector. vector < int > v ; // String TOKENIZER to get all the numbers and convert them into integers // then push it into the vector char * ans = strtok ( a , \" \" ); while ( ans != NULL ){ v . push_back ( stoi ( ans )); ans = strtok ( NULL , \" \" ); } Now most of the cases this will be some traversal order, and from this traversal order we create a binary tree. The most logical way one can provide the input is that they give you the level order traversal of the tree in that stream. Here is a Tree Class and a function to create a binary tree from a vector of numbers. // Tree Definition class Tree { public : int data ; Tree * left , * right ; Tree ( int d ){ data = d ; left = nullptr ; right = nullptr ; } }; Creating tree from the input vector Tree * createTreeFromVector ( vector < int > v ) { if ( v . size () == 0 ) return nullptr ; int root = v [ 0 ]; Tree * treeRoot = new Tree ( root ); // start from the 1st element and push into a queue and add it to left of root; // because we push data in from left to right in complete binary tree queue < Tree *> q ; q . push ( treeRoot ); int i = 1 ; while ( ! q . empty ()){ Tree * thisNode = q . front (); q . pop (); thisNode -> left = new Tree ( v [ i ++ ]); q . push ( thisNode -> left ); if ( i >= v . size ()) break ; thisNode -> right = new Tree ( v [ i ++ ]); q . push ( thisNode -> right ); if ( i >= v . size ()) break ; } return treeRoot ; } See the problem section now Tree Problem Section","title":"Tree Implementation"},{"location":"trees/implementation/#tree-implementation","text":"Tree is a non linear graph data structure which has no cycle. Tree is hiararchical data structure, any sort of data that has some sort of hiararchy we can use a tree to represent, get, delete efficiently.","title":" Tree implementation"},{"location":"trees/implementation/#tree-standard-struct","text":"STL don't have general binary tree representation [has red black tree (height balanced binary search tree)]. The following struct can be used to represent a tree structure. struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; // Create a Tree Structure int main () { TreeNode * root = new TreeNode ( 12 ); root -> left = new TreeNode ( 112 ); root -> right = new TreeNode ( 44 ); } Visual representation of the structure : graph TD subgraph After Inserstions 12((12)) --> 44((44)) & 112((112)) 112 --> aa[null_ptr] & bb[null_ptr] 44 --> aaa[null_ptr] & bbb[null_ptr] end subgraph At the start A((12)) --> b[null_ptr] & c[null_ptr] end","title":"Tree Standard struct"},{"location":"trees/implementation/#tree-from-input-stream","text":"Now for some cases you may have to take input from a stream of numbers and create a tree structure from them. Here is a detailed implementation on how to do that. First we create a character array and put the entire stream into that character array, // Get complete binray tree input from a stream char a [ 1000 ]; cin . getline ( a , 1000 ); Now we create a vector and we'll tokenize the character array and get all the numbers from them into the vector. vector < int > v ; // String TOKENIZER to get all the numbers and convert them into integers // then push it into the vector char * ans = strtok ( a , \" \" ); while ( ans != NULL ){ v . push_back ( stoi ( ans )); ans = strtok ( NULL , \" \" ); } Now most of the cases this will be some traversal order, and from this traversal order we create a binary tree. The most logical way one can provide the input is that they give you the level order traversal of the tree in that stream. Here is a Tree Class and a function to create a binary tree from a vector of numbers. // Tree Definition class Tree { public : int data ; Tree * left , * right ; Tree ( int d ){ data = d ; left = nullptr ; right = nullptr ; } }; Creating tree from the input vector Tree * createTreeFromVector ( vector < int > v ) { if ( v . size () == 0 ) return nullptr ; int root = v [ 0 ]; Tree * treeRoot = new Tree ( root ); // start from the 1st element and push into a queue and add it to left of root; // because we push data in from left to right in complete binary tree queue < Tree *> q ; q . push ( treeRoot ); int i = 1 ; while ( ! q . empty ()){ Tree * thisNode = q . front (); q . pop (); thisNode -> left = new Tree ( v [ i ++ ]); q . push ( thisNode -> left ); if ( i >= v . size ()) break ; thisNode -> right = new Tree ( v [ i ++ ]); q . push ( thisNode -> right ); if ( i >= v . size ()) break ; } return treeRoot ; }","title":"Tree from input stream"},{"location":"trees/implementation/#see-the-problem-section-now","text":"Tree Problem Section","title":"See the problem section now"},{"location":"trees/problems/","text":"Tree Problems Traversal problems Inorder, preorder, and postorder traversal Let's don't waste time and finish the \"confusing\" topic of pre order, post order and in order traversal on binary trees. Most of my friends tell me that they often forget how each traversal works and ask me how to remember them. Well, here you go When running through a tree (binary or binary search tree) we start from the root. Now arrange the queue of nodes like this if we visit the node for the first time we add that to the pre-order queue, the node for the second time we add that to the in-order queue, the node for the 3rd time we add that to the post-order queue. And now you have 3 queues each with pre-in-post order traversal path. Also make a note that if the binary tree is a binary search tree, then the in-order traversal will give a sorted array. We can use this property to check if the binary tree is a binary search tree or not. More formal definition Pre order traversal is implemented like this: \\(\\text{Root} \\to \\text{Left} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Root} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) C++ Code // Definition of the tree node struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; void inOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { inOrderTraversal ( nodePointer -> left ); printf ( \"%d \" , nodePointer -> data ); inOrderTraversal ( nodePointer -> right ); } } void preOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { printf ( \"%d \" , nodePointer -> data ); preOrderTraversal ( nodePointer -> left ); preOrderTraversal ( nodePointer -> right ); } } void postOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { postOrderTraversal ( nodePointer -> left ); postOrderTraversal ( nodePointer -> right ); printf ( \"%d \" , nodePointer -> data ); } } Level order traversal for binary trees For the following binary tree graph TB 12((12)) --> 44((44)) & 112((112)) 112 --> aa((34)) & bb((55)) 44 --> aaa((69)) & bbb((420)) The equivalent level order traversal should be graph LR a[12] --> b[44] --> c[112] --> 34 --> 55 --> 69 --> 420 Approach If you see there is a queuing order, every level of the tree gets processed from left to right. Then in the next level they are processed from left to right as well as their parent's order. So if we use a queue we can solve this problem. With queue we can solve this problem, and here is a step by step approach Balanced Binary Tree Problem on leetcode \\(\\to\\) Problem Statement Given a binary tree, determine if it is height-balanced. Approach If a binary tree is height-balanced then the difference of height of the right subtree and left subtree should not be greater than 2. Now from the last problem we can recursivly find the height of the left and right subtrees and check if the difference between them is > 1. If at any point we find that the height difference is > 1, we indicate this some how to the main function and say it's not height balanced. Code class Solution { public : int height ( TreeNode * root ) { if ( ! root ) return 0 ; // recursively find the height of subtrees int leftheight = height ( root -> left ); int rightheight = height ( root -> right ); // if we find a height imbalance we inform it to the parent. if ( std :: abs ( leftheight - rightheight ) > 1 ) return -1 ; // If [at parent] we find one of the subtrees has height imbalance // we return -1 and exit the program if ( leftheight == -1 or rightheight == -1 ) return -1 ; return 1 + max ( leftheight , rightheight ); } bool isBalanced ( TreeNode * root ) { // if the subroutine finds anywhere in the tree a height imbalance // we return false. return height ( root ) != -1 ; } }; Branch Sum Problem Problem Statement You'll be given the root node of the binary tree. Now you have to return all the branch's \"SUM\" in a vector. Example: Approach The code should be almost similar to the height finding recursive approach for binary trees. Here we will change the code slightly so that we pass a int sum with each recursion and continue to add until we reach the bottom of the tree. At leaf node we check if (tree->left == nullptr and tree->right == nullptr) then we just push the sum to the answer and return. Code void branchSum ( vector < int > & v , Tree * tree , int sum ) { if ( tree -> left == nullptr and tree -> right == nullptr ) { v . push_back ( sum + tree -> data ); return ; } branchSum ( v , tree -> left , sum + tree -> data ); branchSum ( v , tree -> right , sum + tree -> data ); } int main (){ vector < int > v ; branchSum ( v , root , 0 ); for ( auto t : v ) cout << t << \" \" ; } Output INORDER TRAVERSAL OF THE TREE 4 2 5 1 6 3 7 Branch Sum of TREE 7 8 10 11 Invert a binary tree Problem statement You'll be given a binary tree, find out the inverted equivalent of the tree. It is prefered to do the inversion in place. Example Let's say we have a binary tree B. Inverting the binary tree will result into the mirror immage of the tree. Apporach This is probably one of the best tree questions, it seems that there are a lot of things to track here. So solving this problem requires attention to lot of details. The apporach to solve this is to swap the nodes instead of the values. First we swap the left node with the right node for the head and then recursively swap the left and right nodes for the left and right nodes. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root ){ TreeNode * temp = root -> left ; root -> left = root -> right ; root -> right = temp ; invertTree ( root -> left ); invertTree ( root -> right ); } return root ; } }; Approach With BFS I personally don't prefer any recursive approach. With BFS also we can easily solve this problem. We put the node in queue to be processed and when we are at this node if this is not NULL we swap it's left and right children. This is the way we can swap left and right thus inverting it level by level because BFS works level order. class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()){ TreeNode * thisNode = q . front (); // get front of the queue to process q . pop (); if ( thisNode != nullptr ){ // swap it's left and right TreeNode * left = thisNode -> left ; thisNode -> left = thisNode -> right ; thisNode -> right = left ; q . push ( thisNode -> left ); // put both the children to be processed later q . push ( thisNode -> right ); } } return root ; } }; Iterative In Order Traversal As you probably guessed, I don't like to use recursive approaches all that much. In tree traversals you have to iterate over the tree in the following order: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) . Now how can we avoid recursion? One possible solution could be to use stack and imitate the call stack. Code We should mimic the behavior of the recursion in the recursive implementation of the in order traversal. void iterativeInOrderTraversal ( Tree * root ){ vector < Tree *> stack ; Tree * traveller = root ; while ( true ){ if ( traveller != nullptr ){ stack . push_back ( traveller ); traveller = traveller -> left ; } else { if ( stack . empty ()) break ; traveller = stack . back (); stack . pop_back (); cout << traveller -> data << \" \" ; traveller = traveller -> right ; } } } Now that we've seen the code, we should analyse the code using a dry run. This is the starting of the algorithm . In first step we go left until the first NULL is found, and we put all the nodes into the stack so to process later. Now at this point we've reached the point where we should start processing the node. This node stack.top() do not have any left children so for left we don't do anything, and print this node, then we should go to right and process that. We keep on deleting from stack and print until we go right of Node 1. Now we reached to a non-NULL node so the if part will be executed. It will put all the left of 3 into the stack until a NULL is reached. At the very last step \\(\\text{NODE}(5)\\) will be processed which I did not show. It's a genuinely good problem and there is a lot to keep track of in the iterative version for a easy recursive problem. This goes to show how much the recursion stack actually helps, but at the cost of proper mental gymnastics to come up with a recursive approach. Minimum Depth of a Binary Tree Find the Problem on Leetcode \\(\\to\\) Problem statement Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node. Examples: Depth = Path of 1 \\(\\to\\) 3. So the code should return 2. graph TD 1((1)) --> 2((2)) & 3((3)) 2 --> 4((4)) & 5((5)) style 1 fill:#bbf, color:#fff style 3 fill:#bbf, color:#fff Depth = Path of 12 \\(\\to\\) 7 \\(\\to\\) 9. So the code should return 3. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff Approach This is a pattern related to breath first search traversal. Think of this logically, if you traverse level by level and you find the first node that is a leaf node. This means you found the shallowest node in the binary tree. You track and return the depth of that shallowest node. C++ Code /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , 1 }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int nextDepth = q . front (). second + 1 ; q . pop (); if ( front -> left ) q . push ({ front -> left , nextDepth }); if ( front -> right ) q . push ({ front -> right , nextDepth }); if ( ! front -> left and ! front -> right ) return nextDepth - 1 ; depth = nextDepth ; } return depth ; } };","title":"Tree Problems"},{"location":"trees/problems/#tree-problems","text":"","title":" Tree Problems"},{"location":"trees/problems/#traversal-problems","text":"","title":"Traversal problems"},{"location":"trees/problems/#inorder-preorder-and-postorder-traversal","text":"Let's don't waste time and finish the \"confusing\" topic of pre order, post order and in order traversal on binary trees. Most of my friends tell me that they often forget how each traversal works and ask me how to remember them. Well, here you go When running through a tree (binary or binary search tree) we start from the root. Now arrange the queue of nodes like this if we visit the node for the first time we add that to the pre-order queue, the node for the second time we add that to the in-order queue, the node for the 3rd time we add that to the post-order queue. And now you have 3 queues each with pre-in-post order traversal path. Also make a note that if the binary tree is a binary search tree, then the in-order traversal will give a sorted array. We can use this property to check if the binary tree is a binary search tree or not.","title":"Inorder, preorder, and postorder traversal"},{"location":"trees/problems/#more-formal-definition","text":"Pre order traversal is implemented like this: \\(\\text{Root} \\to \\text{Left} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Root} \\to \\text{Right}\\) In-order traversal is implemented like this: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\)","title":"More formal definition"},{"location":"trees/problems/#c-code","text":"// Definition of the tree node struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int value ) { data = value ; left = nullptr ; right = nullptr ; } }; void inOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { inOrderTraversal ( nodePointer -> left ); printf ( \"%d \" , nodePointer -> data ); inOrderTraversal ( nodePointer -> right ); } } void preOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { printf ( \"%d \" , nodePointer -> data ); preOrderTraversal ( nodePointer -> left ); preOrderTraversal ( nodePointer -> right ); } } void postOrderTraversal ( TreeNode * nodePointer ){ if ( nodePointer != nullptr ) { postOrderTraversal ( nodePointer -> left ); postOrderTraversal ( nodePointer -> right ); printf ( \"%d \" , nodePointer -> data ); } }","title":"C++ Code"},{"location":"trees/problems/#level-order-traversal-for-binary-trees","text":"For the following binary tree graph TB 12((12)) --> 44((44)) & 112((112)) 112 --> aa((34)) & bb((55)) 44 --> aaa((69)) & bbb((420)) The equivalent level order traversal should be graph LR a[12] --> b[44] --> c[112] --> 34 --> 55 --> 69 --> 420","title":"Level order traversal for binary trees"},{"location":"trees/problems/#approach","text":"If you see there is a queuing order, every level of the tree gets processed from left to right. Then in the next level they are processed from left to right as well as their parent's order. So if we use a queue we can solve this problem. With queue we can solve this problem, and here is a step by step approach","title":"Approach"},{"location":"trees/problems/#balanced-binary-tree","text":"Problem on leetcode \\(\\to\\)","title":"Balanced Binary Tree"},{"location":"trees/problems/#problem-statement","text":"Given a binary tree, determine if it is height-balanced.","title":"Problem Statement"},{"location":"trees/problems/#approach_1","text":"If a binary tree is height-balanced then the difference of height of the right subtree and left subtree should not be greater than 2. Now from the last problem we can recursivly find the height of the left and right subtrees and check if the difference between them is > 1. If at any point we find that the height difference is > 1, we indicate this some how to the main function and say it's not height balanced.","title":"Approach"},{"location":"trees/problems/#code","text":"class Solution { public : int height ( TreeNode * root ) { if ( ! root ) return 0 ; // recursively find the height of subtrees int leftheight = height ( root -> left ); int rightheight = height ( root -> right ); // if we find a height imbalance we inform it to the parent. if ( std :: abs ( leftheight - rightheight ) > 1 ) return -1 ; // If [at parent] we find one of the subtrees has height imbalance // we return -1 and exit the program if ( leftheight == -1 or rightheight == -1 ) return -1 ; return 1 + max ( leftheight , rightheight ); } bool isBalanced ( TreeNode * root ) { // if the subroutine finds anywhere in the tree a height imbalance // we return false. return height ( root ) != -1 ; } };","title":"Code"},{"location":"trees/problems/#branch-sum-problem","text":"","title":"Branch Sum Problem"},{"location":"trees/problems/#problem-statement_1","text":"You'll be given the root node of the binary tree. Now you have to return all the branch's \"SUM\" in a vector.","title":"Problem Statement"},{"location":"trees/problems/#example","text":"","title":"Example:"},{"location":"trees/problems/#approach_2","text":"The code should be almost similar to the height finding recursive approach for binary trees. Here we will change the code slightly so that we pass a int sum with each recursion and continue to add until we reach the bottom of the tree. At leaf node we check if (tree->left == nullptr and tree->right == nullptr) then we just push the sum to the answer and return.","title":"Approach"},{"location":"trees/problems/#code_1","text":"void branchSum ( vector < int > & v , Tree * tree , int sum ) { if ( tree -> left == nullptr and tree -> right == nullptr ) { v . push_back ( sum + tree -> data ); return ; } branchSum ( v , tree -> left , sum + tree -> data ); branchSum ( v , tree -> right , sum + tree -> data ); } int main (){ vector < int > v ; branchSum ( v , root , 0 ); for ( auto t : v ) cout << t << \" \" ; } Output INORDER TRAVERSAL OF THE TREE 4 2 5 1 6 3 7 Branch Sum of TREE 7 8 10 11","title":"Code"},{"location":"trees/problems/#invert-a-binary-tree","text":"","title":"Invert a binary tree"},{"location":"trees/problems/#problem-statement_2","text":"You'll be given a binary tree, find out the inverted equivalent of the tree. It is prefered to do the inversion in place. Example Let's say we have a binary tree B. Inverting the binary tree will result into the mirror immage of the tree.","title":"Problem statement"},{"location":"trees/problems/#apporach","text":"This is probably one of the best tree questions, it seems that there are a lot of things to track here. So solving this problem requires attention to lot of details. The apporach to solve this is to swap the nodes instead of the values. First we swap the left node with the right node for the head and then recursively swap the left and right nodes for the left and right nodes. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root ){ TreeNode * temp = root -> left ; root -> left = root -> right ; root -> right = temp ; invertTree ( root -> left ); invertTree ( root -> right ); } return root ; } };","title":"Apporach"},{"location":"trees/problems/#approach-with-bfs","text":"I personally don't prefer any recursive approach. With BFS also we can easily solve this problem. We put the node in queue to be processed and when we are at this node if this is not NULL we swap it's left and right children. This is the way we can swap left and right thus inverting it level by level because BFS works level order. class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()){ TreeNode * thisNode = q . front (); // get front of the queue to process q . pop (); if ( thisNode != nullptr ){ // swap it's left and right TreeNode * left = thisNode -> left ; thisNode -> left = thisNode -> right ; thisNode -> right = left ; q . push ( thisNode -> left ); // put both the children to be processed later q . push ( thisNode -> right ); } } return root ; } };","title":"Approach With BFS"},{"location":"trees/problems/#iterative-in-order-traversal","text":"As you probably guessed, I don't like to use recursive approaches all that much. In tree traversals you have to iterate over the tree in the following order: \\(\\text{Left} \\to \\text{Right} \\to \\text{Root}\\) . Now how can we avoid recursion? One possible solution could be to use stack and imitate the call stack.","title":"Iterative In Order Traversal"},{"location":"trees/problems/#code_2","text":"We should mimic the behavior of the recursion in the recursive implementation of the in order traversal. void iterativeInOrderTraversal ( Tree * root ){ vector < Tree *> stack ; Tree * traveller = root ; while ( true ){ if ( traveller != nullptr ){ stack . push_back ( traveller ); traveller = traveller -> left ; } else { if ( stack . empty ()) break ; traveller = stack . back (); stack . pop_back (); cout << traveller -> data << \" \" ; traveller = traveller -> right ; } } } Now that we've seen the code, we should analyse the code using a dry run. This is the starting of the algorithm . In first step we go left until the first NULL is found, and we put all the nodes into the stack so to process later. Now at this point we've reached the point where we should start processing the node. This node stack.top() do not have any left children so for left we don't do anything, and print this node, then we should go to right and process that. We keep on deleting from stack and print until we go right of Node 1. Now we reached to a non-NULL node so the if part will be executed. It will put all the left of 3 into the stack until a NULL is reached. At the very last step \\(\\text{NODE}(5)\\) will be processed which I did not show. It's a genuinely good problem and there is a lot to keep track of in the iterative version for a easy recursive problem. This goes to show how much the recursion stack actually helps, but at the cost of proper mental gymnastics to come up with a recursive approach.","title":"Code"},{"location":"trees/problems/#minimum-depth-of-a-binary-tree","text":"Find the Problem on Leetcode \\(\\to\\)","title":"Minimum Depth of a Binary Tree"},{"location":"trees/problems/#problem-statement_3","text":"Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node.","title":"Problem statement"},{"location":"trees/problems/#examples","text":"Depth = Path of 1 \\(\\to\\) 3. So the code should return 2. graph TD 1((1)) --> 2((2)) & 3((3)) 2 --> 4((4)) & 5((5)) style 1 fill:#bbf, color:#fff style 3 fill:#bbf, color:#fff Depth = Path of 12 \\(\\to\\) 7 \\(\\to\\) 9. So the code should return 3. graph TD 12((12)) --> 7((7)) & 1((1)) 7 --> 9((9)) 1 --> 10((10)) & 5((5)) 10 --> 11((11)) style 12 fill:#bbf, color:white style 7 fill:#bbf, color:#ffffff style 9 fill:#bbf, color:#ffffff","title":"Examples:"},{"location":"trees/problems/#approach_3","text":"This is a pattern related to breath first search traversal. Think of this logically, if you traverse level by level and you find the first node that is a leaf node. This means you found the shallowest node in the binary tree. You track and return the depth of that shallowest node.","title":"Approach"},{"location":"trees/problems/#c-code_1","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; queue < pair < TreeNode * , int >> q ; int depth = 1 ; q . push ({ root , 1 }); while ( ! q . empty ()){ TreeNode * front = q . front (). first ; int nextDepth = q . front (). second + 1 ; q . pop (); if ( front -> left ) q . push ({ front -> left , nextDepth }); if ( front -> right ) q . push ({ front -> right , nextDepth }); if ( ! front -> left and ! front -> right ) return nextDepth - 1 ; depth = nextDepth ; } return depth ; } };","title":"C++ Code"}]}